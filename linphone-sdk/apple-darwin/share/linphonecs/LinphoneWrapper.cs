/*
LinphoneWrapper.cs
Copyright (c) 2010-2022 Belledonne Communications SARL.

This file is part of Liblinphone 
(see https://gitlab.linphone.org/BC/public/liblinphone).

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU Affero General Public License as
published by the Free Software Foundation, either version 3 of the
License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Affero General Public License for more details.

You should have received a copy of the GNU Affero General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
#if __IOS__
using ObjCRuntime;
#endif

namespace Linphone
{
#region Wrapper specifics
	/// <summary>
	/// Only contains the LIB_NAME value that represents the library in which all DllImport are made
	/// </summary>
	public class LinphoneWrapper
	{
		public const string VERSION = "5.3.74";
#if __IOS__
		public const string LIB_NAME = "__Internal"; // With this, it automatically finds the frameworks
#elif (_WIN32 || WINDOWS_UWP)
		public const string LIB_NAME = "liblinphone"; // With this, it automatically finds liblinphone.dll
#else
		public const string LIB_NAME = "linphone"; // With this, it automatically finds liblinphone.so
#endif

#if (_WIN32 || WINDOWS_UWP)
		public const string BELLE_SIP_LIB_NAME = "bellesip";
		public const string BCTOOLBOX_LIB_NAME = "bctoolbox";
		public const string MEDIASTREAMER_LIB_NAME = "mediastreamer";
#else
		public const string BELLE_SIP_LIB_NAME = LIB_NAME;
		public const string BCTOOLBOX_LIB_NAME = LIB_NAME;
		public const string MEDIASTREAMER_LIB_NAME = LIB_NAME;
#endif
/// https://docs.microsoft.com/fr-fr/xamarin/cross-platform/app-fundamentals/building-cross-platform-applications/platform-divergence-abstraction-divergent-implementation#android
#if __ANDROID__
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void setAndroidLogHandler();
#endif
#if __IOS__
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_iphone_enable_logs();
#endif

		/// <summary>
		/// Registers the native log handler in Linphone.
		/// </summary>
		public static void setNativeLogHandler()
		{
#if __ANDROID__
			setAndroidLogHandler();
#elif __IOS__
			linphone_iphone_enable_logs();
#endif
		}
	}

	/// <summary>
	/// All methods that returns a LinphoneStatus with a value != 0 as an error code in C are translated in C# by throwing a LinphoneException
	/// </summary>
#if (_WIN32 || WINDOWS_UWP)
	public class LinphoneException : System.Exception
	{
		public LinphoneException() : base() { }
		public LinphoneException(string message) : base(message) { }
		public LinphoneException(string message, System.Exception inner) : base(message, inner) { }
	}
#else
	[Serializable()]
	public class LinphoneException : System.Exception
	{
		public LinphoneException() : base() { }
		public LinphoneException(string message) : base(message) { }
		public LinphoneException(string message, System.Exception inner) : base(message, inner) { }
		protected LinphoneException(System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context) { }
	}
#endif

	[StructLayout(LayoutKind.Sequential)]
	/// <summary>
	/// Parent class for a Linphone public objects
	/// </summary>
	public class LinphoneObject
	{
		internal IntPtr nativePtr;

		internal GCHandle handle;

		internal bool isListener;

		internal List<IntPtr> string_ptr_list;

		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		internal delegate void OnLinphoneObjectDataDestroyed(IntPtr data);

		[DllImport(LinphoneWrapper.BELLE_SIP_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		internal static extern int belle_sip_object_data_set(IntPtr ptr, string name, IntPtr data, IntPtr cb);
#else
		internal static extern int belle_sip_object_data_set(IntPtr ptr, string name, IntPtr data, OnLinphoneObjectDataDestroyed cb);
#endif

		[DllImport(LinphoneWrapper.BELLE_SIP_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr belle_sip_object_data_get(IntPtr ptr, string name);

		[DllImport(LinphoneWrapper.BELLE_SIP_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr belle_sip_object_ref(IntPtr ptr);

		[DllImport(LinphoneWrapper.BELLE_SIP_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void belle_sip_object_unref(IntPtr ptr);

		[DllImport(LinphoneWrapper.BELLE_SIP_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void belle_sip_object_data_remove(IntPtr ptr, string name);

		[DllImport(LinphoneWrapper.BCTOOLBOX_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr bctbx_list_next(IntPtr ptr);

		[DllImport(LinphoneWrapper.BCTOOLBOX_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr bctbx_list_get_data(IntPtr ptr);

		[DllImport(LinphoneWrapper.BCTOOLBOX_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr bctbx_list_append(IntPtr elem, IntPtr data);

		internal OnLinphoneObjectDataDestroyed onLinphoneListenerObjectDestroyed;

#if __IOS__
		[MonoPInvokeCallback((typeof(OnLinphoneObjectDataDestroyed)))]
		internal static void on_linphone_cbs_data_destroyed(IntPtr data) {
#else
		internal void on_linphone_cbs_data_destroyed(IntPtr data) {
#endif
			if (data != IntPtr.Zero)
			{
				GCHandle handle = GCHandle.FromIntPtr(data);
				if (handle.IsAllocated) {
					handle.Free();
				}
			}
		}

		~LinphoneObject()
		{
			if (nativePtr != IntPtr.Zero && !isListener) {
				belle_sip_object_data_remove(nativePtr, "cs_obj");
				belle_sip_object_unref(nativePtr);
				handle.Free();
			}
		}

		internal static T fromNativePtr<T>(IntPtr ptr, bool takeRef=true, bool isListener=false) where T : LinphoneObject, new()
		{
			if (ptr == IntPtr.Zero) return null;
			IntPtr objPtr = belle_sip_object_data_get(ptr, "cs_obj");
			if (objPtr != IntPtr.Zero)
			{
				T obj = null;
				GCHandle handle = GCHandle.FromIntPtr(objPtr);
				if (handle.IsAllocated)
				{
					obj = (T)handle.Target;
				}
				if (obj == null)
				{
					objPtr = IntPtr.Zero;
				}
				else
				{
					return obj;
				}
			}
			if (objPtr == IntPtr.Zero)
			{
				T obj = new T();
				if (takeRef)
				{
					ptr = belle_sip_object_ref(ptr);
				}
				obj.nativePtr = ptr;
				obj.isListener = isListener;

				if (isListener) {
					obj.handle = GCHandle.Alloc(obj, GCHandleType.Normal);
				} else {
					obj.handle = GCHandle.Alloc(obj, GCHandleType.WeakTrackResurrection);
				}
				objPtr = GCHandle.ToIntPtr(obj.handle);

				if (isListener) {
#if (_WIN32 || WINDOWS_UWP)
					obj.onLinphoneListenerObjectDestroyed = obj.on_linphone_cbs_data_destroyed;
					IntPtr cb = Marshal.GetFunctionPointerForDelegate(obj.onLinphoneListenerObjectDestroyed);
					belle_sip_object_data_set(ptr, "cs_obj", objPtr, cb);
#elif __IOS__
					belle_sip_object_data_set(ptr, "cs_obj", objPtr, on_linphone_cbs_data_destroyed);
#else
					belle_sip_object_data_set(ptr, "cs_obj", objPtr, obj.on_linphone_cbs_data_destroyed);
#endif
				} else {
#if (_WIN32 || WINDOWS_UWP)
					belle_sip_object_data_set(ptr, "cs_obj", objPtr, IntPtr.Zero);
#else
					belle_sip_object_data_set(ptr, "cs_obj", objPtr, null);
#endif
				}
				return obj;
			}
			return null;
		}

		internal static IEnumerable<string> MarshalStringArray(IntPtr listPtr)
		{
			if (listPtr != IntPtr.Zero)
			{
				IntPtr ptr = listPtr;
				while (ptr != IntPtr.Zero)
				{
					IntPtr dataPtr = bctbx_list_get_data(ptr);
					if (dataPtr == IntPtr.Zero)
					{
						break;
					}
					string key = Marshal.PtrToStringAnsi(dataPtr);
					yield return key;
					ptr = bctbx_list_next(ptr);
				}
			}
		}

		internal static IEnumerable<T> MarshalBctbxList<T>(IntPtr listPtr, bool takeRef=true) where T : LinphoneObject, new()
		{
			if (listPtr != IntPtr.Zero)
			{
				IntPtr ptr = listPtr;
				while (ptr != IntPtr.Zero)
				{
					IntPtr dataPtr = bctbx_list_get_data(ptr);
					if (dataPtr == IntPtr.Zero)
					{
						break;
					}
					T obj = fromNativePtr<T>(dataPtr, takeRef);
					yield return obj;
					ptr = bctbx_list_next(ptr);
				}
			}
		}

		internal protected IntPtr StringArrayToBctbxList(IEnumerable<string> stringlist)
		{
			IntPtr bctbx_list = IntPtr.Zero;
			string_ptr_list = new List<IntPtr>();
			foreach (string s in stringlist)
			{
				IntPtr string_ptr = Marshal.StringToHGlobalAnsi(s);
				bctbx_list = bctbx_list_append(bctbx_list, string_ptr);
				string_ptr_list.Add(string_ptr);
			}
			return bctbx_list;
		}

		internal protected void CleanStringArrayPtrs()
		{
			foreach (IntPtr string_ptr in string_ptr_list)
			{
				Marshal.FreeHGlobal(string_ptr);
			}
		}

		internal static IntPtr ObjectArrayToBctbxList<T>(IEnumerable<T> objlist) where T : LinphoneObject, new()
		{
			IntPtr bctbx_list = IntPtr.Zero;
			foreach (T ptr in objlist)
			{
				bctbx_list = bctbx_list_append(bctbx_list, ptr.nativePtr);
			}
			return bctbx_list;
		}

		/// Safely (no throw) convert a C++ char* to a .NET string (which are UTF-16).
		/// If the raw string contains illegal UTF-8 multi-byte sequences,
		/// replace them silently.
		internal static string PtrToStringSafe(IntPtr str)
		{
			try  // the happy path first
			{
				return Marshal.PtrToStringAnsi(str);
			}
			catch (Exception)  // fallback to safe decoding
			{
				// Assume null-terminated and load into buffer
				var buffer = new List<byte>();
				byte current_byte;
				int offset = 0;
				do {
					current_byte = Marshal.ReadByte(str, offset);
					buffer.Add(current_byte);
					offset++;
				} while (current_byte != 0);
				// Decode as UTF-8
				return System.Text.Encoding.UTF8.GetString(buffer.ToArray());
			}
			// Notes:
			// We could get rid of the try{} and always use safe decoding, however:
			//  1. Most strings are correctly encoded
			//  2. Safe decoding is expensive: The data is copied twice (from C++
			//     to buffer, then from buffer to string). Since this is a hot path
			//     (used in log message callbacks), we need performance, and we can
			//     assume builtin marshalling will be faster (untested).
			//  3. The exception, "Illegal byte sequence encounted in the input." (sic),
			//     seems to happen only with the Mono runtime (Xamarin).
			//     .NET Core either does no check, or replaces invalid characters
			//     as part of marshalling, but does not throw an exception.
		}
	}

	public class MediastreamerFactory
	{
		public IntPtr nativePtr;

		[DllImport(LinphoneWrapper.MEDIASTREAMER_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int ms_factory_enable_filter_from_name(IntPtr nativePtr, string name, char enabled);

		public void enableFilterFromName(string name, bool enabled)
		{
			ms_factory_enable_filter_from_name(nativePtr, name, enabled ? (char)1 : (char)0);
		}

		[DllImport(LinphoneWrapper.MEDIASTREAMER_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void ms_devices_info_add(IntPtr devices_info, string manufacturer, string model, string platform, uint flags, int delay, int recommended_rate);

		[DllImport(LinphoneWrapper.MEDIASTREAMER_LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr ms_factory_get_devices_info(IntPtr factory);

		public void addDevicesInfo(string manufacturer, string model, string platform, uint flags, int delay, int recommended_rate)
		{
			ms_devices_info_add(ms_factory_get_devices_info(nativePtr), manufacturer, model, platform, flags, delay, recommended_rate);
		}
	}
#endregion

#region Enums

	/// <summary>
	/// Enum describing RTP AVPF activation modes. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AVPFMode
	{
		/// <summary>
		/// Use default value defined at upper level. 
		/// <para>
		/// </para>
		/// </summary>
		Default = -1,
		/// <summary>
		/// AVPF is disabled. 
		/// <para>
		/// </para>
		/// </summary>
		Disabled = 0,
		/// <summary>
		/// AVPF is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		Enabled = 1,
	}

	/// <summary>
	/// Enum describing activation code checking, used by the <see cref="Linphone.AccountCreator">
	/// Linphone.AccountCreator</see>. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorActivationCodeStatus
	{
		/// <summary>
		/// Activation code ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Activation code too short. 
		/// <para>
		/// </para>
		/// </summary>
		TooShort = 1,
		/// <summary>
		/// Activation code too long. 
		/// <para>
		/// </para>
		/// </summary>
		TooLong = 2,
		/// <summary>
		/// Contain invalid characters. 
		/// <para>
		/// </para>
		/// </summary>
		InvalidCharacters = 3,
	}

	/// <summary>
	/// Enum describing algorithm checking, used by the <see cref="Linphone.AccountCreator">
	/// Linphone.AccountCreator</see>. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorAlgoStatus
	{
		/// <summary>
		/// Algorithm ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Algorithm not supported. 
		/// <para>
		/// </para>
		/// </summary>
		NotSupported = 1,
	}

	/// <summary>
	/// Enum describing backend used in the <see cref="Linphone.AccountCreator">
	/// Linphone.AccountCreator</see>. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorBackend
	{
		/// <summary>
		/// XMLRPC Backend. 
		/// <para>
		/// </para>
		/// </summary>
		XMLRPC = 0,
		/// <summary>
		/// FlexiAPI Backend. 
		/// <para>
		/// </para>
		/// </summary>
		FlexiAPI = 1,
	}

	/// <summary>
	/// Enum describing domain checking, used by the <see cref="Linphone.AccountCreator">
	/// Linphone.AccountCreator</see>. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorDomainStatus
	{
		/// <summary>
		/// Domain ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Domain invalid. 
		/// <para>
		/// </para>
		/// </summary>
		Invalid = 1,
	}

	/// <summary>
	/// Enum describing email checking, used by the <see cref="Linphone.AccountCreator">
	/// Linphone.AccountCreator</see>. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorEmailStatus
	{
		/// <summary>
		/// Email ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Email malformed. 
		/// <para>
		/// </para>
		/// </summary>
		Malformed = 1,
		/// <summary>
		/// Contain invalid characters. 
		/// <para>
		/// </para>
		/// </summary>
		InvalidCharacters = 2,
	}

	/// <summary>
	/// Enum describing language checking, used by the <see cref="Linphone.AccountCreator">
	/// Linphone.AccountCreator</see>. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorLanguageStatus
	{
		/// <summary>
		/// Language ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
	}

	/// <summary>
	/// Enum describing password checking, used by the <see cref="Linphone.AccountCreator">
	/// Linphone.AccountCreator</see>. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorPasswordStatus
	{
		/// <summary>
		/// Password ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Password too short. 
		/// <para>
		/// </para>
		/// </summary>
		TooShort = 1,
		/// <summary>
		/// Password too long. 
		/// <para>
		/// </para>
		/// </summary>
		TooLong = 2,
		/// <summary>
		/// Contain invalid characters. 
		/// <para>
		/// </para>
		/// </summary>
		InvalidCharacters = 3,
		/// <summary>
		/// Missing specific characters. 
		/// <para>
		/// </para>
		/// </summary>
		MissingCharacters = 4,
	}

	/// <summary>
	/// Enum describing phone number checking, used by the <see cref="Linphone.AccountCreator">
	/// Linphone.AccountCreator</see>. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorPhoneNumberStatus
	{
		/// <summary>
		/// Phone number ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 1,
		/// <summary>
		/// Phone number too short. 
		/// <para>
		/// </para>
		/// </summary>
		TooShort = 2,
		/// <summary>
		/// Phone number too long. 
		/// <para>
		/// </para>
		/// </summary>
		TooLong = 4,
		/// <summary>
		/// Country code invalid. 
		/// <para>
		/// </para>
		/// </summary>
		InvalidCountryCode = 8,
		/// <summary>
		/// Phone number invalid. 
		/// <para>
		/// </para>
		/// </summary>
		Invalid = 16,
	}

	/// <summary>
	/// Enum describing the status of server request, used by the <see cref="Linphone.AccountCreator">
	/// Linphone.AccountCreator</see>. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorStatus
	{
		/// <summary>
		/// Request status. 
		/// <para>
		/// Request passed 
		/// </para>
		/// </summary>
		RequestOk = 0,
		/// <summary>
		/// Request failed. 
		/// <para>
		/// </para>
		/// </summary>
		RequestFailed = 1,
		/// <summary>
		/// Request failed due to missing argument(s) 
		/// <para>
		/// </para>
		/// </summary>
		MissingArguments = 2,
		/// <summary>
		/// Request failed due to missing callback(s) 
		/// <para>
		/// </para>
		/// </summary>
		MissingCallbacks = 3,
		/// <summary>
		/// Account status. 
		/// <para>
		/// Account created 
		/// </para>
		/// </summary>
		AccountCreated = 4,
		/// <summary>
		/// Account not created. 
		/// <para>
		/// </para>
		/// </summary>
		AccountNotCreated = 5,
		/// <summary>
		/// Account exist. 
		/// <para>
		/// </para>
		/// </summary>
		AccountExist = 6,
		/// <summary>
		/// Account exist with alias. 
		/// <para>
		/// </para>
		/// </summary>
		AccountExistWithAlias = 7,
		/// <summary>
		/// Account not exist. 
		/// <para>
		/// </para>
		/// </summary>
		AccountNotExist = 8,
		/// <summary>
		/// Account was created with Alias. 
		/// <para>
		/// </para>
		/// </summary>
		AliasIsAccount = 9,
		/// <summary>
		/// Alias exist. 
		/// <para>
		/// </para>
		/// </summary>
		AliasExist = 10,
		/// <summary>
		/// Alias not exist. 
		/// <para>
		/// </para>
		/// </summary>
		AliasNotExist = 11,
		/// <summary>
		/// Account activated. 
		/// <para>
		/// </para>
		/// </summary>
		AccountActivated = 12,
		/// <summary>
		/// Account already activated. 
		/// <para>
		/// </para>
		/// </summary>
		AccountAlreadyActivated = 13,
		/// <summary>
		/// Account not activated. 
		/// <para>
		/// </para>
		/// </summary>
		AccountNotActivated = 14,
		/// <summary>
		/// Account linked. 
		/// <para>
		/// </para>
		/// </summary>
		AccountLinked = 15,
		/// <summary>
		/// Account not linked. 
		/// <para>
		/// </para>
		/// </summary>
		AccountNotLinked = 16,
		/// <summary>
		/// Server. 
		/// <para>
		/// Error server 
		/// </para>
		/// </summary>
		ServerError = 17,
		/// <summary>
		/// Error cannot send SMS. 
		/// <para>
		/// </para>
		/// </summary>
		PhoneNumberInvalid = 18,
		/// <summary>
		/// Error key doesn&apos;t match. 
		/// <para>
		/// </para>
		/// </summary>
		WrongActivationCode = 19,
		/// <summary>
		/// Error too many SMS sent. 
		/// <para>
		/// </para>
		/// </summary>
		PhoneNumberOverused = 20,
		/// <summary>
		/// Error algo isn&apos;t MD5 or SHA-256. 
		/// <para>
		/// </para>
		/// </summary>
		AlgoNotSupported = 21,
		/// <summary>
		/// Generic error. 
		/// <para>
		/// </para>
		/// </summary>
		UnexpectedError = 22,
		/// <summary>
		/// This API isn&apos;t implemented in the current backend. 
		/// <para>
		/// </para>
		/// </summary>
		NotImplementedError = 23,
		/// <summary>
		/// Request has been denied, probably due to invalid auth token. 
		/// <para>
		/// </para>
		/// </summary>
		RequestNotAuthorized = 24,
		/// <summary>
		/// Request has been denied, due to too many requests sent in given period. 
		/// <para>
		/// </para>
		/// </summary>
		RequestTooManyRequests = 25,
	}

	/// <summary>
	/// Enum describing transport checking, used by the <see cref="Linphone.AccountCreator">
	/// Linphone.AccountCreator</see>. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorTransportStatus
	{
		/// <summary>
		/// Transport ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Transport invalid. 
		/// <para>
		/// </para>
		/// </summary>
		Unsupported = 1,
	}

	/// <summary>
	/// Enum describing username checking, used by the <see cref="Linphone.AccountCreator">
	/// Linphone.AccountCreator</see>. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AccountCreatorUsernameStatus
	{
		/// <summary>
		/// Username ok. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Username too short. 
		/// <para>
		/// </para>
		/// </summary>
		TooShort = 1,
		/// <summary>
		/// Username too long. 
		/// <para>
		/// </para>
		/// </summary>
		TooLong = 2,
		/// <summary>
		/// Contain invalid characters. 
		/// <para>
		/// </para>
		/// </summary>
		InvalidCharacters = 3,
		/// <summary>
		/// Invalid username. 
		/// <para>
		/// </para>
		/// </summary>
		Invalid = 4,
	}

	/// <summary>
	/// Enum describing Ip family. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AddressFamily
	{
		/// <summary>
		/// IpV4. 
		/// <para>
		/// </para>
		/// </summary>
		Inet = 0,
		/// <summary>
		/// IpV6. 
		/// <para>
		/// </para>
		/// </summary>
		Inet6 = 1,
		/// <summary>
		/// Unknown. 
		/// <para>
		/// </para>
		/// </summary>
		Unspec = 2,
	}

	/// <summary>
	/// All kinds of alerts. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AlertType
	{
		/// <summary>
		/// Camera is not working. 
		/// <para>
		/// No other information </para>
		/// </summary>
		/// <remarks>Note : Use the key &quot;camera_misfunction_interval&quot; in the
		/// section &quot;alerts::camera&quot; to set the interval at which the problem is
		/// checked in a <see cref="Linphone.Config">Linphone.Config</see>. </remarks>
		QoSCameraMisfunction = 0,
		/// <summary>
		/// Camera is capturing low framerate. 
		/// <para>
		/// Information supplied : float framerate; </para>
		/// </summary>
		/// <remarks>Note : Use the key &quot;low_framerate_interval&quot; in the section
		/// &quot;alerts::camera&quot; to set or get the interval at which the problem is
		/// checked in a <see cref="Linphone.Config">Linphone.Config</see>. </remarks>
		QoSCameraLowFramerate = 1,
		/// <summary>
		/// Video decoding has stopped for a given period (10 s by default). 
		/// <para>
		/// No other information. </para>
		/// </summary>
		/// <remarks>Note : Use the key &quot;video_stalled_interval&quot; in the section
		/// &quot;alerts::camera&quot; to set or get the interval at which the problem is
		/// checked in a <see cref="Linphone.Config">Linphone.Config</see>. </remarks>
		QoSVideoStalled = 2,
		/// <summary>
		/// A received media stream suffers from high loss or late rate. 
		/// <para>
		/// Information provided is:
		/// </para>
		/// </summary>
		QoSHighLossLateRate = 3,
		/// <summary>
		/// A report of high loss rate is received from remote party. 
		/// <para>
		/// Information provided: loss-rate (float). </para>
		/// </summary>
		/// <remarks>Note : Use the key &quot;remote_loss_rate_interval&quot; in the
		/// section &quot;alerts::network&quot; to set or get the interval at which the
		/// problem is checked in a <see cref="Linphone.Config">Linphone.Config</see>.
		/// </remarks>
		QoSHighRemoteLossRate = 4,
		/// <summary>
		/// Packet Burst phenomenon. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Note : Use the key &quot;burst_occured_interval&quot; in the section
		/// &quot;alerts::network&quot; to set or get the interval at which the problem is
		/// checked in a <see cref="Linphone.Config">Linphone.Config</see>. </remarks>
		QoSBurstOccured = 5,
		/// <summary>
		/// Loss rate is significant but retransmissions fail to arrive on time. 
		/// <para>
		/// Information provided: nack-performance (float) the fraction of lost packets
		/// recovered thanks to nack-triggered retransmissions. </para>
		/// </summary>
		/// <remarks>Note : Use the key &quot;nack_check_interval&quot; in the section
		/// &quot;alerts::network&quot; to set or get the interval at which the problem is
		/// checked in a <see cref="Linphone.Config">Linphone.Config</see>. </remarks>
		QoSRetransmissionFailures = 6,
		/// <summary>
		/// Low bandwidth detected. 
		/// <para>
		/// Information provided: bandwidth (float) in kbit/s. </para>
		/// </summary>
		/// <remarks>Note : Use the key &quot;download_bandwidth_interval&quot; in the
		/// section &quot;alerts::video&quot; to set or get the interval at which the
		/// problem is checked in a <see cref="Linphone.Config">Linphone.Config</see>.
		/// </remarks>
		QoSLowDownloadBandwidthEstimation = 7,
		/// <summary>
		/// Low quality (bitrate) video received. 
		/// <para>
		/// Information provided: bitrate (float) in kbit/s, width (integer), int height
		/// (integer). </para>
		/// </summary>
		/// <remarks>Note : Use the key &quot;low_quality_received_interval&quot; in the
		/// section &quot;alerts::video&quot; to set or get the interval at which the
		/// problem is checked in a <see cref="Linphone.Config">Linphone.Config</see>.
		/// </remarks>
		QoSLowQualityReceivedVideo = 8,
		/// <summary>
		/// Low quality video is being sent. 
		/// <para>
		/// Information provided: bitrate (float)in kbit/s, width (integer), height
		/// (integer). </para>
		/// </summary>
		/// <remarks>Note : Use the key &quot;quality_sent_interval&quot; in the section
		/// &quot;alerts::camera&quot; to set or get the interval at which the problem is
		/// checked in a <see cref="Linphone.Config">Linphone.Config</see>. </remarks>
		QoSLowQualitySentVideo = 9,
		/// <summary>
		/// The operating system reports a low radio signal (wifi or mobile) 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Note : Use the key &quot;low_signal_interval&quot; in the section
		/// &quot;alerts::network&quot; to set or get the interval at which the problem is
		/// checked in a <see cref="Linphone.Config">Linphone.Config</see>. </remarks>
		QoSLowSignal = 10,
		/// <summary>
		/// The operating system reports a loss of radio signal (wifi or mobile). 
		/// <para>
		/// Information provided: rssi-value (float), signal-type (string) with values
		/// {&quot;wifi&quot;, &quot;mobile&quot;, &quot;other&quot;}. </para>
		/// </summary>
		/// <remarks>Note : Use the key &quot;lost_signal_interval&quot; in the section
		/// &quot;alerts::network&quot; to set or get the interval at which the problem is
		/// checked in a <see cref="Linphone.Config">Linphone.Config</see>. </remarks>
		QoSLostSignal = 11,
	}

	/// <summary>
	/// <see cref="Linphone.AudioDeviceCapabilities">
	/// Linphone.AudioDeviceCapabilities</see> enum represents whether a device can
	/// record audio, play audio or both 
	/// <para>
	/// </para>
	/// </summary>
	[Flags]
	public enum AudioDeviceCapabilities
	{
		/// <summary>
		/// Can record audio. 
		/// <para>
		/// </para>
		/// </summary>
		CapabilityRecord = 1<<0,
		/// <summary>
		/// Can play audio. 
		/// <para>
		/// </para>
		/// </summary>
		CapabilityPlay = 1<<1,
		/// <summary>
		/// Can play and record audio. 
		/// <para>
		/// </para>
		/// </summary>
		CapabilityAll = 3,
	}

	/// <summary>
	/// <see cref="Linphone.AudioDeviceType">Linphone.AudioDeviceType</see> enum
	/// represents the different types of an audio device. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AudioDeviceType
	{
		/// <summary>
		/// Unknown. 
		/// <para>
		/// </para>
		/// </summary>
		Unknown = 0,
		/// <summary>
		/// Microphone. 
		/// <para>
		/// </para>
		/// </summary>
		Microphone = 1,
		/// <summary>
		/// Earpiece. 
		/// <para>
		/// </para>
		/// </summary>
		Earpiece = 2,
		/// <summary>
		/// Speaker. 
		/// <para>
		/// </para>
		/// </summary>
		Speaker = 3,
		/// <summary>
		/// Bluetooth. 
		/// <para>
		/// </para>
		/// </summary>
		Bluetooth = 4,
		/// <summary>
		/// Bluetooth A2DP. 
		/// <para>
		/// </para>
		/// </summary>
		BluetoothA2DP = 5,
		/// <summary>
		/// Telephony. 
		/// <para>
		/// </para>
		/// </summary>
		Telephony = 6,
		/// <summary>
		/// AuxLine. 
		/// <para>
		/// </para>
		/// </summary>
		AuxLine = 7,
		/// <summary>
		/// GenericUsb. 
		/// <para>
		/// </para>
		/// </summary>
		GenericUsb = 8,
		/// <summary>
		/// Headset. 
		/// <para>
		/// </para>
		/// </summary>
		Headset = 9,
		/// <summary>
		/// Headphones. 
		/// <para>
		/// </para>
		/// </summary>
		Headphones = 10,
		/// <summary>
		/// Hearing Aid. 
		/// <para>
		/// </para>
		/// </summary>
		HearingAid = 11,
	}

	/// <summary>
	/// Enum describing the authentication methods. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum AuthMethod
	{
		/// <summary>
		/// Digest authentication requested. 
		/// <para>
		/// </para>
		/// </summary>
		HttpDigest = 0,
		/// <summary>
		/// Client certificate requested. 
		/// <para>
		/// </para>
		/// </summary>
		Tls = 1,
	}

	/// <summary>
	/// Enum representing the direction of a call. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum CallDir
	{
		/// <summary>
		/// outgoing calls 
		/// <para>
		/// </para>
		/// </summary>
		Outgoing = 0,
		/// <summary>
		/// incoming calls 
		/// <para>
		/// </para>
		/// </summary>
		Incoming = 1,
	}

	/// <summary>
	/// <see cref="Linphone.CallState">Linphone.CallState</see> enum represents the
	/// different states a call can reach into. 
	/// <para>
	/// The application is notified of a state change through the
	/// LinphoneCoreVTable::call_state_changed callback. 
	/// </para>
	/// </summary>
	
	public enum CallState
	{
		/// <summary>
		/// Initial state. 
		/// <para>
		/// </para>
		/// </summary>
		Idle = 0,
		/// <summary>
		/// Incoming call received. 
		/// <para>
		/// </para>
		/// </summary>
		IncomingReceived = 1,
		/// <summary>
		/// PushIncoming call received. 
		/// <para>
		/// </para>
		/// </summary>
		PushIncomingReceived = 2,
		/// <summary>
		/// Outgoing call initialized. 
		/// <para>
		/// </para>
		/// </summary>
		OutgoingInit = 3,
		/// <summary>
		/// Outgoing call in progress. 
		/// <para>
		/// </para>
		/// </summary>
		OutgoingProgress = 4,
		/// <summary>
		/// Outgoing call ringing. 
		/// <para>
		/// </para>
		/// </summary>
		OutgoingRinging = 5,
		/// <summary>
		/// Outgoing call early media. 
		/// <para>
		/// </para>
		/// </summary>
		OutgoingEarlyMedia = 6,
		/// <summary>
		/// Connected. 
		/// <para>
		/// </para>
		/// </summary>
		Connected = 7,
		/// <summary>
		/// Streams running. 
		/// <para>
		/// </para>
		/// </summary>
		StreamsRunning = 8,
		/// <summary>
		/// Pausing. 
		/// <para>
		/// </para>
		/// </summary>
		Pausing = 9,
		/// <summary>
		/// Paused. 
		/// <para>
		/// </para>
		/// </summary>
		Paused = 10,
		/// <summary>
		/// Resuming. 
		/// <para>
		/// </para>
		/// </summary>
		Resuming = 11,
		/// <summary>
		/// Referred. 
		/// <para>
		/// </para>
		/// </summary>
		Referred = 12,
		/// <summary>
		/// Error. 
		/// <para>
		/// </para>
		/// </summary>
		Error = 13,
		/// <summary>
		/// Call end. 
		/// <para>
		/// </para>
		/// </summary>
		End = 14,
		/// <summary>
		/// Paused by remote. 
		/// <para>
		/// </para>
		/// </summary>
		PausedByRemote = 15,
		/// <summary>
		/// The call&apos;s parameters are updated for example when video is asked by
		/// remote. 
		/// <para>
		/// </para>
		/// </summary>
		UpdatedByRemote = 16,
		/// <summary>
		/// We are proposing early media to an incoming call. 
		/// <para>
		/// </para>
		/// </summary>
		IncomingEarlyMedia = 17,
		/// <summary>
		/// We have initiated a call update. 
		/// <para>
		/// </para>
		/// </summary>
		Updating = 18,
		/// <summary>
		/// The call object is now released. 
		/// <para>
		/// </para>
		/// </summary>
		Released = 19,
		/// <summary>
		/// The call is updated by remote while not yet answered (SIP UPDATE in early
		/// dialog received) 
		/// <para>
		/// </para>
		/// </summary>
		EarlyUpdatedByRemote = 20,
		/// <summary>
		/// We are updating the call while not yet answered (SIP UPDATE in early dialog
		/// sent) 
		/// <para>
		/// </para>
		/// </summary>
		EarlyUpdating = 21,
	}

	/// <summary>
	/// Enum representing the status of a call. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum CallStatus
	{
		/// <summary>
		/// The call was sucessful. 
		/// <para>
		/// </para>
		/// </summary>
		Success = 0,
		/// <summary>
		/// The call was aborted (caller hanged up) 
		/// <para>
		/// </para>
		/// </summary>
		Aborted = 1,
		/// <summary>
		/// The call was missed (incoming call timed out without being answered or hanged
		/// up) 
		/// <para>
		/// </para>
		/// </summary>
		Missed = 2,
		/// <summary>
		/// The call was declined, either locally or by remote end. 
		/// <para>
		/// </para>
		/// </summary>
		Declined = 3,
		/// <summary>
		/// The call was aborted before being advertised to the application - for protocol
		/// reasons. 
		/// <para>
		/// </para>
		/// </summary>
		EarlyAborted = 4,
		/// <summary>
		/// The call was answered on another device. 
		/// <para>
		/// </para>
		/// </summary>
		AcceptedElsewhere = 5,
		/// <summary>
		/// The call was declined on another device. 
		/// <para>
		/// </para>
		/// </summary>
		DeclinedElsewhere = 6,
	}

	/// <summary>
	/// <see cref="Linphone.ChatMessageDirection">Linphone.ChatMessageDirection</see>
	/// is used to indicate if a message is outgoing or incoming. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ChatMessageDirection
	{
		/// <summary>
		/// Incoming message. 
		/// <para>
		/// </para>
		/// </summary>
		Incoming = 0,
		/// <summary>
		/// Outgoing message. 
		/// <para>
		/// </para>
		/// </summary>
		Outgoing = 1,
	}

	/// <summary>
	/// <see cref="Linphone.ChatMessageState">Linphone.ChatMessageState</see> is used
	/// to notify if messages have been successfully delivered or not. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ChatMessageState
	{
		/// <summary>
		/// Initial state. 
		/// <para>
		/// </para>
		/// </summary>
		Idle = 0,
		/// <summary>
		/// Delivery in progress. 
		/// <para>
		/// </para>
		/// </summary>
		InProgress = 1,
		/// <summary>
		/// Message successfully delivered and acknowledged by the server. 
		/// <para>
		/// </para>
		/// </summary>
		Delivered = 2,
		/// <summary>
		/// Message was not delivered. 
		/// <para>
		/// </para>
		/// </summary>
		NotDelivered = 3,
		/// <summary>
		/// Message was received and acknowledged but cannot get file from server. 
		/// <para>
		/// </para>
		/// </summary>
		FileTransferError = 4,
		/// <summary>
		/// File transfer has been completed successfully. 
		/// <para>
		/// </para>
		/// </summary>
		FileTransferDone = 5,
		/// <summary>
		/// Message successfully delivered an acknowledged by the remote user. 
		/// <para>
		/// </para>
		/// </summary>
		DeliveredToUser = 6,
		/// <summary>
		/// Message successfully displayed to the remote user. 
		/// <para>
		/// </para>
		/// </summary>
		Displayed = 7,
		/// <summary>
		/// File transfer is in progress. 
		/// <para>
		/// If message is incoming it&apos;s a download, otherwise it&apos;s an upload. 
		/// </para>
		/// </summary>
		FileTransferInProgress = 8,
	}

	/// <summary>
	/// <see cref="Linphone.ChatRoomBackend">Linphone.ChatRoomBackend</see> is used to
	/// indicate the backend implementation of a chat room. 
	/// <para>
	/// </para>
	/// </summary>
	[Flags]
	public enum ChatRoomBackend
	{
		/// <summary>
		/// Basic (client-to-client) chat room. 
		/// <para>
		/// </para>
		/// </summary>
		Basic = 1<<0,
		/// <summary>
		/// Server-based chat room. 
		/// <para>
		/// </para>
		/// </summary>
		FlexisipChat = 1<<1,
	}

	/// <summary>
	/// <see cref="Linphone.ChatRoomCapabilities">Linphone.ChatRoomCapabilities</see>
	/// is used to indicate the capabilities of a chat room. 
	/// <para>
	/// </para>
	/// </summary>
	[Flags]
	public enum ChatRoomCapabilities
	{
		/// <summary>
		/// No capabilities. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// No server. 
		/// <para>
		/// It&apos;s a direct communication 
		/// </para>
		/// </summary>
		Basic = 1<<0,
		/// <summary>
		/// Supports RTT. 
		/// <para>
		/// </para>
		/// </summary>
		RealTimeText = 1<<1,
		/// <summary>
		/// Use server (supports group chat) 
		/// <para>
		/// </para>
		/// </summary>
		Conference = 1<<2,
		/// <summary>
		/// Special proxy chat room flag. 
		/// <para>
		/// </para>
		/// </summary>
		Proxy = 1<<3,
		/// <summary>
		/// Chat room migratable from Basic to Conference. 
		/// <para>
		/// </para>
		/// </summary>
		Migratable = 1<<4,
		/// <summary>
		/// A communication between two participants (can be Basic or Conference) 
		/// <para>
		/// </para>
		/// </summary>
		OneToOne = 1<<5,
		/// <summary>
		/// Chat room is encrypted. 
		/// <para>
		/// </para>
		/// </summary>
		Encrypted = 1<<6,
		/// <summary>
		/// Chat room can enable ephemeral messages. 
		/// <para>
		/// </para>
		/// </summary>
		Ephemeral = 1<<7,
	}

	/// <summary>
	/// <see cref="Linphone.ChatRoomEncryptionBackend">
	/// Linphone.ChatRoomEncryptionBackend</see> is used to indicate the encryption
	/// engine used by a chat room. 
	/// <para>
	/// </para>
	/// </summary>
	[Flags]
	public enum ChatRoomEncryptionBackend
	{
		/// <summary>
		/// No encryption. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Lime x3dh encryption. 
		/// <para>
		/// </para>
		/// </summary>
		Lime = 1<<0,
	}

	/// <summary>
	/// <see cref="Linphone.ChatRoomEphemeralMode">Linphone.ChatRoomEphemeralMode</see>
	/// is used to the ephemeral message mode used by a chat room. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ChatRoomEphemeralMode
	{
		/// <summary>
		/// Each device manages its own ephemeral settings. 
		/// <para>
		/// </para>
		/// </summary>
		DeviceManaged = 0,
		/// <summary>
		/// Ephemeral settings are chatroom wide and only admins can change them. 
		/// <para>
		/// </para>
		/// </summary>
		AdminManaged = 1,
	}

	/// <summary>
	/// TODO move to encryption engine object when available <see cref="Linphone.ChatRoomSecurityLevel">
	/// Linphone.ChatRoomSecurityLevel</see> is used to indicate the encryption
	/// security level of a chat room. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ChatRoomSecurityLevel
	{
		/// <summary>
		/// Security failure. 
		/// <para>
		/// </para>
		/// </summary>
		Unsafe = 0,
		/// <summary>
		/// No encryption. 
		/// <para>
		/// </para>
		/// </summary>
		ClearText = 1,
		/// <summary>
		/// Encrypted. 
		/// <para>
		/// </para>
		/// </summary>
		Encrypted = 2,
		/// <summary>
		/// Encrypted and verified. 
		/// <para>
		/// </para>
		/// </summary>
		Safe = 3,
	}

	/// <summary>
	/// <see cref="Linphone.ChatRoomState">Linphone.ChatRoomState</see> is used to
	/// indicate the current state of a chat room. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ChatRoomState
	{
		/// <summary>
		/// Initial state. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Chat room is now instantiated on local. 
		/// <para>
		/// </para>
		/// </summary>
		Instantiated = 1,
		/// <summary>
		/// One creation request was sent to the server. 
		/// <para>
		/// </para>
		/// </summary>
		CreationPending = 2,
		/// <summary>
		/// Chat room was created on the server. 
		/// <para>
		/// </para>
		/// </summary>
		Created = 3,
		/// <summary>
		/// Chat room creation failed. 
		/// <para>
		/// </para>
		/// </summary>
		CreationFailed = 4,
		/// <summary>
		/// Wait for chat room termination. 
		/// <para>
		/// </para>
		/// </summary>
		TerminationPending = 5,
		/// <summary>
		/// Chat room exists on server but not in local. 
		/// <para>
		/// </para>
		/// </summary>
		Terminated = 6,
		/// <summary>
		/// The chat room termination failed. 
		/// <para>
		/// </para>
		/// </summary>
		TerminationFailed = 7,
		/// <summary>
		/// Chat room was deleted on the server. 
		/// <para>
		/// </para>
		/// </summary>
		Deleted = 8,
	}

	/// <summary>
	/// Codec priority policies. 
	/// <para>
	/// This enum represents different policies for managing offered codec lists during
	/// calls, as well as the offer-answer logic. Currently, policies can be applied
	/// only for video codecs. 
	/// </para>
	/// </summary>
	
	public enum CodecPriorityPolicy
	{
		/// <summary>
		/// In this mode, codecs have initial default ordering, that can be changed by the
		/// application The answerer of a call accepts codecs with the order given in the
		/// offer. 
		/// <para>
		/// </para>
		/// </summary>
		Basic = 0,
		/// <summary>
		/// In this mode, the codec list is managed by the <see cref="Linphone.Core">
		/// Linphone.Core</see> according to hardware capabilities in the goal of
		/// optimizing video quality and user experience. 
		/// <para>
		/// The answerer of call may re-order the offerer&apos;s list in its answer in
		/// order to give preference to certain codecs. 
		/// </para>
		/// </summary>
		Auto = 1,
	}

	/// <summary>
	/// <see cref="Linphone.ConferenceInfoState">Linphone.ConferenceInfoState</see> is
	/// used to list all states of a conference info object 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ConferenceInfoState
	{
		/// <summary>
		/// New conference. 
		/// <para>
		/// </para>
		/// </summary>
		New = 0,
		/// <summary>
		/// Conference has been updated. 
		/// <para>
		/// </para>
		/// </summary>
		Updated = 1,
		/// <summary>
		/// Canceling a conference. 
		/// <para>
		/// </para>
		/// </summary>
		Cancelled = 2,
	}

	/// <summary>
	/// Mode of joining conference. 
	/// <para>
	/// </para>
	/// </summary>
	/// <remarks>Warning : It is only valid at the creation of the conferece </remarks> 
	
	public enum ConferenceJoiningMode
	{
		/// <summary>
		/// Participants must dial the conference server. 
		/// <para>
		/// </para>
		/// </summary>
		DialIn = 0,
		/// <summary>
		/// Conference server dials participants. 
		/// <para>
		/// </para>
		/// </summary>
		DialOut = 1,
	}

	/// <summary>
	/// <see cref="Linphone.ConferenceLayout">Linphone.ConferenceLayout</see> is used
	/// to indicate the layout used by the conference. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ConferenceLayout
	{
		/// <summary>
		/// Grid - each participant is given an equal sized image size. 
		/// <para>
		/// </para>
		/// </summary>
		Grid = 0,
		/// <summary>
		/// Active speaker - participant who speaks is prominently displayed in the center
		/// of the screen and other participants are minimized. 
		/// <para>
		/// </para>
		/// </summary>
		ActiveSpeaker = 1,
	}

	/// <summary>
	/// Type of conference participant list. 
	/// <para>
	/// When participant list is closed, no more participants can be added other than
	/// those declared when creating the conference When participant list is open,
	/// other people can join the conference upon invitation of a participant no more
	/// participants can be added other than those declared when creating the
	/// conference 
	/// </para>
	/// </summary>
	
	public enum ConferenceParticipantListType
	{
		/// <summary>
		/// Only participants in the initiating INVITE are allowed to join the conference. 
		/// <para>
		/// </para>
		/// </summary>
		Closed = 0,
		/// <summary>
		/// All devices calling the conference URI are allowed to join the conference. 
		/// <para>
		/// </para>
		/// </summary>
		Open = 1,
	}

	/// <summary>
	/// Describes conference scheduler possible states. 
	/// <para>
	/// It is notified via the conference_scheduler_state_changed callback in <see cref="Linphone.ConferenceSchedulerListener">
	/// Linphone.ConferenceSchedulerListener</see>. 
	/// </para>
	/// </summary>
	
	public enum ConferenceSchedulerState
	{
		/// <summary>
		/// Default state of a freshly created <see cref="Linphone.ConferenceScheduler">
		/// Linphone.ConferenceScheduler</see>. 
		/// <para>
		/// </para>
		/// </summary>
		Idle = 0,
		/// <summary>
		/// An error has happened during conference creation. 
		/// <para>
		/// </para>
		/// </summary>
		Error = 1,
		/// <summary>
		/// Conference creation is in progress. 
		/// <para>
		/// </para>
		/// </summary>
		AllocationPending = 2,
		/// <summary>
		/// Confererence has been created. 
		/// <para>
		/// </para>
		/// </summary>
		Ready = 3,
		/// <summary>
		/// Conference has been updated. 
		/// <para>
		/// </para>
		/// </summary>
		Updating = 4,
	}

	/// <summary>
	/// Conference minimum security level. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ConferenceSecurityLevel
	{
		/// <summary>
		/// No security. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Point-to-point encryption. 
		/// <para>
		/// </para>
		/// </summary>
		PointToPoint = 1,
		/// <summary>
		/// End-to-end encryption. 
		/// <para>
		/// </para>
		/// </summary>
		EndToEnd = 2,
	}

	/// <summary>
	/// <see cref="Linphone.ConferenceState">Linphone.ConferenceState</see> is used to
	/// indicate the current state of a conference. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ConferenceState
	{
		/// <summary>
		/// Initial state. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Conference is now instantiated locally. 
		/// <para>
		/// </para>
		/// </summary>
		Instantiated = 1,
		/// <summary>
		/// One creation request was sent to the service. 
		/// <para>
		/// </para>
		/// </summary>
		CreationPending = 2,
		/// <summary>
		/// Conference was created on the service. 
		/// <para>
		/// </para>
		/// </summary>
		Created = 3,
		/// <summary>
		/// Conference creation on service failed. 
		/// <para>
		/// </para>
		/// </summary>
		CreationFailed = 4,
		/// <summary>
		/// Wait for conference termination. 
		/// <para>
		/// </para>
		/// </summary>
		TerminationPending = 5,
		/// <summary>
		/// The conference is terminated locally, though it may still exist on the service
		/// for other participants. 
		/// <para>
		/// </para>
		/// </summary>
		Terminated = 6,
		/// <summary>
		/// Conference termination failed. 
		/// <para>
		/// </para>
		/// </summary>
		TerminationFailed = 7,
		/// <summary>
		/// Conference was deleted locally and on the service. 
		/// <para>
		/// </para>
		/// </summary>
		Deleted = 8,
	}

	/// <summary>
	/// Describes the state of the remote configuring process of the <see cref="Linphone.Core">
	/// Linphone.Core</see> object, &apos;Skipped&apos; when the feature is disabled. 
	/// <para>
	/// It is notified via the configuring_status() callback in <see cref="Linphone.CoreListener">
	/// Linphone.CoreListener</see>. 
	/// </para>
	/// </summary>
	
	public enum ConfiguringState
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Successful = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Failed = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Skipped = 2,
	}

	/// <summary>
	/// Consolidated presence information: &apos;online&apos; means the user is open
	/// for communication, &apos;busy&apos; means the user is open for communication
	/// but involved in an other activity, &apos;do not disturb&apos; means the user is
	/// not open for communication, and &apos;offline&apos; means that no presence
	/// information is available. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ConsolidatedPresence
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Online = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Busy = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		DoNotDisturb = 2,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Offline = 3,
	}

	/// <summary>
	/// Used to notify if log collection upload have been succesfully delivered or not. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum CoreLogCollectionUploadState
	{
		/// <summary>
		/// Delivery in progress. 
		/// <para>
		/// </para>
		/// </summary>
		InProgress = 0,
		/// <summary>
		/// Log collection upload successfully delivered and acknowledged by remote end
		/// point. 
		/// <para>
		/// </para>
		/// </summary>
		Delivered = 1,
		/// <summary>
		/// Log collection upload was not delivered. 
		/// <para>
		/// </para>
		/// </summary>
		NotDelivered = 2,
	}

	/// <summary>
	/// Enum describing the result of the echo canceller calibration process. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum EcCalibratorStatus
	{
		/// <summary>
		/// The echo canceller calibration process is on going. 
		/// <para>
		/// </para>
		/// </summary>
		InProgress = 0,
		/// <summary>
		/// The echo canceller calibration has been performed and produced an echo delay
		/// measure. 
		/// <para>
		/// </para>
		/// </summary>
		Done = 1,
		/// <summary>
		/// The echo canceller calibration process has failed. 
		/// <para>
		/// </para>
		/// </summary>
		Failed = 2,
		/// <summary>
		/// The echo canceller calibration has been performed and no echo has been
		/// detected. 
		/// <para>
		/// </para>
		/// </summary>
		DoneNoEcho = 3,
	}

	/// <summary>
	/// <see cref="Linphone.EventLogType">Linphone.EventLogType</see> is used to
	/// indicate the type of an event. 
	/// <para>
	/// Useful for cast. 
	/// </para>
	/// </summary>
	
	public enum EventLogType
	{
		/// <summary>
		/// No defined event. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Conference (created) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceCreated = 1,
		/// <summary>
		/// Conference (terminated) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceTerminated = 2,
		/// <summary>
		/// Conference call (start) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceCallStarted = 3,
		/// <summary>
		/// Conference call (connected) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceConnected = 21,
		/// <summary>
		/// Conference call (end) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceCallEnded = 4,
		/// <summary>
		/// Conference chat message event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceChatMessage = 5,
		/// <summary>
		/// Conference participant (added) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantAdded = 6,
		/// <summary>
		/// Conference participant (removed) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantRemoved = 7,
		/// <summary>
		/// Conference participant (role unknown) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantRoleUnknown = 25,
		/// <summary>
		/// Conference participant (role speaker) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantRoleSpeaker = 26,
		/// <summary>
		/// Conference participant (role listener) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantRoleListener = 27,
		/// <summary>
		/// Conference participant (set admin) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantSetAdmin = 8,
		/// <summary>
		/// Conference participant (unset admin) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantUnsetAdmin = 9,
		/// <summary>
		/// Conference participant device (added) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantDeviceAdded = 10,
		/// <summary>
		/// Conference participant device (removed) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantDeviceRemoved = 11,
		/// <summary>
		/// Conference participant device (media capability changed) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantDeviceMediaCapabilityChanged = 17,
		/// <summary>
		/// Conference participant device (media availability changed) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantDeviceMediaAvailabilityChanged = 23,
		/// <summary>
		/// Conference participant device (left) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceParticipantDeviceStatusChanged = 22,
		/// <summary>
		/// Conference subject event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceSubjectChanged = 12,
		/// <summary>
		/// Conference available media event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceAvailableMediaChanged = 18,
		/// <summary>
		/// Conference encryption security event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceSecurityEvent = 13,
		/// <summary>
		/// Conference ephemeral message (ephemeral message lifetime changed) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceEphemeralMessageLifetimeChanged = 14,
		/// <summary>
		/// Conference ephemeral message (ephemeral message enabled) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceEphemeralMessageEnabled = 15,
		/// <summary>
		/// Conference ephemeral message (ephemeral message disabled) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceEphemeralMessageDisabled = 16,
		/// <summary>
		/// Conference ephemeral message (ephemeral message settings managed by admin)
		/// event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceEphemeralMessageManagedByAdmin = 19,
		/// <summary>
		/// Conference ephemeral message (ephemeral message settings managed by
		/// participants) event. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceEphemeralMessageManagedByParticipants = 20,
		/// <summary>
		/// Reaction event to a chat message. 
		/// <para>
		/// </para>
		/// </summary>
		ConferenceChatMessageReaction = 24,
	}

	/// <summary>
	/// Enum describing the capabilities of a <see cref="Linphone.Friend">
	/// Linphone.Friend</see>, populated through presence subscribe/notify process. 
	/// <para>
	/// </para>
	/// </summary>
	[Flags]
	public enum FriendCapability
	{
		/// <summary>
		/// No capabilities populated. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// This friend can be invited in a Flexisip backend <see cref="Linphone.ChatRoom">
		/// Linphone.ChatRoom</see>. 
		/// <para>
		/// </para>
		/// </summary>
		GroupChat = 1<<0,
		/// <summary>
		/// This friend can be invited in a Flexisip backend end-to-end encrypted <see cref="Linphone.ChatRoom">
		/// Linphone.ChatRoom</see>. 
		/// <para>
		/// </para>
		/// </summary>
		LimeX3Dh = 1<<1,
		/// <summary>
		/// This friend is able to delete ephemeral messages once they have expired. 
		/// <para>
		/// </para>
		/// </summary>
		EphemeralMessages = 1<<2,
	}

	/// <summary>
	/// Enum describing the status of a LinphoneFriendList operation. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum FriendListStatus
	{
		/// <summary>
		/// Operation went fine. 
		/// <para>
		/// </para>
		/// </summary>
		OK = 0,
		/// <summary>
		/// <see cref="Linphone.Friend">Linphone.Friend</see> wasn&apos;t found in the <see cref="Linphone.FriendList">
		/// Linphone.FriendList</see> 
		/// <para>
		/// </para>
		/// </summary>
		NonExistentFriend = 1,
		/// <summary>
		/// <see cref="Linphone.Friend">Linphone.Friend</see> is already present in a <see cref="Linphone.FriendList">
		/// Linphone.FriendList</see> 
		/// <para>
		/// </para>
		/// </summary>
		InvalidFriend = 2,
	}

	/// <summary>
	/// Enum describing the status of a CardDAV synchronization. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum FriendListSyncStatus
	{
		/// <summary>
		/// Synchronization started. 
		/// <para>
		/// </para>
		/// </summary>
		Started = 0,
		/// <summary>
		/// Synchronization finished successfuly. 
		/// <para>
		/// </para>
		/// </summary>
		Successful = 1,
		/// <summary>
		/// Synchronization failed. 
		/// <para>
		/// </para>
		/// </summary>
		Failure = 2,
	}

	/// <summary>
	/// The types of FriendList. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum FriendListType
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Default = -1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		CardDAV = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		VCard4 = 1,
	}

	/// <summary>
	/// Describes the global state of the <see cref="Linphone.Core">Linphone.Core</see>
	/// object. 
	/// <para>
	/// It is notified via the global_state_changed() callback in <see cref="Linphone.CoreListener">
	/// Linphone.CoreListener</see>. 
	/// </para>
	/// </summary>
	
	public enum GlobalState
	{
		/// <summary>
		/// State in which we&apos;re in after <see cref="Linphone.Core.Stop()">
		/// Linphone.Core.Stop()</see>. 
		/// <para>
		/// Do not call any method while in this state except for <see cref="Linphone.Core.Start()">
		/// Linphone.Core.Start()</see> 
		/// </para>
		/// </summary>
		Off = 0,
		/// <summary>
		/// Transient state for when we call <see cref="Linphone.Core.Start()">
		/// Linphone.Core.Start()</see> 
		/// <para>
		/// </para>
		/// </summary>
		Startup = 1,
		/// <summary>
		/// Indicates <see cref="Linphone.Core">Linphone.Core</see> has been started and is
		/// up and running. 
		/// <para>
		/// </para>
		/// </summary>
		On = 2,
		/// <summary>
		/// Transient state for when we call <see cref="Linphone.Core.Stop()">
		/// Linphone.Core.Stop()</see> 
		/// <para>
		/// </para>
		/// </summary>
		Shutdown = 3,
		/// <summary>
		/// Transient state between Startup and On if there is a remote provisionning URI
		/// configured. 
		/// <para>
		/// </para>
		/// </summary>
		Configuring = 4,
		/// <summary>
		/// <see cref="Linphone.Core">Linphone.Core</see> state after being created by
		/// linphone_factory_create_core, generally followed by a call to <see cref="Linphone.Core.Start()">
		/// Linphone.Core.Start()</see> 
		/// <para>
		/// </para>
		/// </summary>
		Ready = 5,
	}

	/// <summary>
	/// Enum describing ICE states. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum IceState
	{
		/// <summary>
		/// ICE has not been activated for this call or stream. 
		/// <para>
		/// </para>
		/// </summary>
		NotActivated = 0,
		/// <summary>
		/// ICE processing has failed. 
		/// <para>
		/// </para>
		/// </summary>
		Failed = 1,
		/// <summary>
		/// ICE process is in progress. 
		/// <para>
		/// </para>
		/// </summary>
		InProgress = 2,
		/// <summary>
		/// ICE has established a direct connection to the remote host. 
		/// <para>
		/// </para>
		/// </summary>
		HostConnection = 3,
		/// <summary>
		/// ICE has established a connection to the remote host through one or several
		/// NATs. 
		/// <para>
		/// </para>
		/// </summary>
		ReflexiveConnection = 4,
		/// <summary>
		/// ICE has established a connection through a relay. 
		/// <para>
		/// </para>
		/// </summary>
		RelayConnection = 5,
	}

	/// <summary>
	/// Enum describing how the authentification will be made. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum LdapAuthMethod
	{
		/// <summary>
		/// Connection without passwords. 
		/// <para>
		/// </para>
		/// </summary>
		Anonymous = 0,
		/// <summary>
		/// Connection with username/password. 
		/// <para>
		/// </para>
		/// </summary>
		Simple = 1,
	}

	/// <summary>
	/// Enum describing server certificates verification modes. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum LdapCertVerificationMode
	{
		/// <summary>
		/// Use default value defined on core. 
		/// <para>
		/// </para>
		/// </summary>
		Default = -1,
		/// <summary>
		/// Verification is disabled. 
		/// <para>
		/// </para>
		/// </summary>
		Disabled = 0,
		/// <summary>
		/// Verification is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		Enabled = 1,
	}

	/// <summary>
	/// Enum describing errors in LDAP parameters. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum LdapCheck
	{
		/// <summary>
		/// No error. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 0,
		/// <summary>
		/// Server field is empty. 
		/// <para>
		/// </para>
		/// </summary>
		ServerEmpty = 1,
		/// <summary>
		/// The server is not an url. 
		/// <para>
		/// </para>
		/// </summary>
		ServerNotUrl = 2,
		/// <summary>
		/// The server doesn&apos;t contain a scheme. 
		/// <para>
		/// </para>
		/// </summary>
		ServerNoScheme = 4,
		/// <summary>
		/// The server is not a LDAP scheme. 
		/// <para>
		/// </para>
		/// </summary>
		ServerNotLdap = 8,
		/// <summary>
		/// LDAP over SSL is non-standardized and deprecated: ldaps has been specified. 
		/// <para>
		/// </para>
		/// </summary>
		ServerLdaps = 16,
		/// <summary>
		/// Base Object has been specified. 
		/// <para>
		/// </para>
		/// </summary>
		BaseObjectEmpty = 32,
		/// <summary>
		/// Some required fields are missing. 
		/// <para>
		/// </para>
		/// </summary>
		MissingFields = 64,
	}

	/// <summary>
	/// Enum Debug verbosity for OpenLdap. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum LdapDebugLevel
	{
		/// <summary>
		/// Set OpenLdap verbosity to none. 
		/// <para>
		/// </para>
		/// </summary>
		Off = 0,
		/// <summary>
		/// Set OpenLdap verbosity to debug level. 
		/// <para>
		/// </para>
		/// </summary>
		Verbose = 1,
	}

	/// <summary>
	/// <para>
	/// </para>
	/// </summary>
	
	public enum LimeState
	{
		/// <summary>
		/// Lime is not used at all. 
		/// <para>
		/// </para>
		/// </summary>
		Disabled = 0,
		/// <summary>
		/// Lime is always used. 
		/// <para>
		/// </para>
		/// </summary>
		Mandatory = 1,
		/// <summary>
		/// Lime is used only if we already shared a secret with remote. 
		/// <para>
		/// </para>
		/// </summary>
		Preferred = 2,
	}

	/// <summary>
	/// Whether or not to keep a file with the logs. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum LogCollectionState
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Disabled = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Enabled = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		EnabledWithoutPreviousLogHandler = 2,
	}

	/// <summary>
	/// Verbosity levels of log messages. 
	/// <para>
	/// </para>
	/// </summary>
	[Flags]
	public enum LogLevel
	{
		/// <summary>
		/// Level for debug messages. 
		/// <para>
		/// </para>
		/// </summary>
		Debug = 1<<0,
		/// <summary>
		/// Level for traces. 
		/// <para>
		/// </para>
		/// </summary>
		Trace = 1<<1,
		/// <summary>
		/// Level for information messages. 
		/// <para>
		/// </para>
		/// </summary>
		Message = 1<<2,
		/// <summary>
		/// Level for warning messages. 
		/// <para>
		/// </para>
		/// </summary>
		Warning = 1<<3,
		/// <summary>
		/// Level for error messages. 
		/// <para>
		/// </para>
		/// </summary>
		Error = 1<<4,
		/// <summary>
		/// Level for fatal error messages. 
		/// <para>
		/// </para>
		/// </summary>
		Fatal = 1<<5,
	}

	/// <summary>
	/// Enum describing how to merge <see cref="Linphone.SearchResult">
	/// Linphone.SearchResult</see> from <see cref="Linphone.MagicSearch">
	/// Linphone.MagicSearch</see>. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum MagicSearchAggregation
	{
		/// <summary>
		/// No aggregation is done, you can have multiple SearchResult with the same
		/// Friend. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Aggregation is done by friend, you will have at most a SearchResult per Friend. 
		/// <para>
		/// </para>
		/// </summary>
		Friend = 1,
	}

	/// <summary>
	/// Enum describing the search categories for Magic Search. 
	/// <para>
	/// </para>
	/// </summary>
	[Flags]
	public enum MagicSearchSource
	{
		/// <summary>
		/// no Source specified. 
		/// <para>
		/// If requested in search, the list should be empty 
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Search in friends only. 
		/// <para>
		/// </para>
		/// </summary>
		Friends = 1<<0,
		/// <summary>
		/// Search in Call Logs. 
		/// <para>
		/// </para>
		/// </summary>
		CallLogs = 1<<1,
		/// <summary>
		/// Search in LDAP servers. 
		/// <para>
		/// </para>
		/// </summary>
		LdapServers = 1<<2,
		/// <summary>
		/// Search in Chat rooms participants. 
		/// <para>
		/// </para>
		/// </summary>
		ChatRooms = 1<<3,
		/// <summary>
		/// Search from request : it is usually an address built from the request. 
		/// <para>
		/// </para>
		/// </summary>
		Request = 1<<4,
		/// <summary>
		/// Search in &quot;starred&quot; friends only. 
		/// <para>
		/// </para>
		/// </summary>
		FavoriteFriends = 1<<5,
		/// <summary>
		/// Search in conferences info (organizer and participants) 
		/// <para>
		/// </para>
		/// </summary>
		ConferencesInfo = 1<<6,
		/// <summary>
		/// Search in all sources. 
		/// <para>
		/// </para>
		/// </summary>
		All = -1,
	}

	/// <summary>
	/// Indicates for a given media the stream direction. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum MediaDirection
	{
		/// <summary>
		/// Default value, shouldn&apos;t be used. 
		/// <para>
		/// </para>
		/// </summary>
		Invalid = -1,
		/// <summary>
		/// No active media not supported yet. 
		/// <para>
		/// </para>
		/// </summary>
		Inactive = 0,
		/// <summary>
		/// Media is only being sent, it won&apos;t be received. 
		/// <para>
		/// </para>
		/// </summary>
		SendOnly = 1,
		/// <summary>
		/// Media will only be received, nothing will be sent. 
		/// <para>
		/// </para>
		/// </summary>
		RecvOnly = 2,
		/// <summary>
		/// Media will be sent and received. 
		/// <para>
		/// </para>
		/// </summary>
		SendRecv = 3,
	}

	/// <summary>
	/// Enum describing type of media encryption types. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum MediaEncryption
	{
		/// <summary>
		/// No media encryption is used. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Use SRTP media encryption. 
		/// <para>
		/// </para>
		/// </summary>
		SRTP = 1,
		/// <summary>
		/// Use ZRTP media encryption. 
		/// <para>
		/// </para>
		/// </summary>
		ZRTP = 2,
		/// <summary>
		/// Use DTLS media encryption. 
		/// <para>
		/// </para>
		/// </summary>
		DTLS = 3,
	}

	/// <summary>
	/// Media resource usage. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum MediaResourceMode
	{
		/// <summary>
		/// Media resources are not shared. 
		/// <para>
		/// </para>
		/// </summary>
		ExclusiveMediaResources = 0,
		/// <summary>
		/// Media resources are shared. 
		/// <para>
		/// </para>
		/// </summary>
		SharedMediaResources = 1,
	}

	/// <summary>
	/// <see cref="Linphone.ParticipantDeviceDisconnectionMethod">
	/// Linphone.ParticipantDeviceDisconnectionMethod</see> is used to indicate how a
	/// participant left a conference. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ParticipantDeviceDisconnectionMethod
	{
		/// <summary>
		/// an admin removes the device from a conference 
		/// <para>
		/// </para>
		/// </summary>
		Booted = 0,
		/// <summary>
		/// the device disconnects from the conference 
		/// <para>
		/// </para>
		/// </summary>
		Departed = 1,
		/// <summary>
		/// device is busy 
		/// <para>
		/// </para>
		/// </summary>
		Busy = 2,
		/// <summary>
		/// an error occurred while the device is leaving the conference or he declined a
		/// call from the server 
		/// <para>
		/// </para>
		/// </summary>
		Failed = 3,
	}

	/// <summary>
	/// <see cref="Linphone.ParticipantDeviceJoiningMethod">
	/// Linphone.ParticipantDeviceJoiningMethod</see> is used to indicate how a
	/// participant joined a conference or if it is the focus. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ParticipantDeviceJoiningMethod
	{
		/// <summary>
		/// device called the conference 
		/// <para>
		/// </para>
		/// </summary>
		DialedIn = 0,
		/// <summary>
		/// device is called the conference 
		/// <para>
		/// </para>
		/// </summary>
		DialedOut = 1,
		/// <summary>
		/// device is the focus 
		/// <para>
		/// </para>
		/// </summary>
		FocusOwner = 2,
	}

	/// <summary>
	/// <see cref="Linphone.ParticipantDeviceState">
	/// Linphone.ParticipantDeviceState</see> is used to list all states a participant
	/// device can be in 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ParticipantDeviceState
	{
		/// <summary>
		/// an INVITE has been sent 
		/// <para>
		/// </para>
		/// </summary>
		Joining = 0,
		/// <summary>
		/// the SIP session has been concluded, participant is part of the conference 
		/// <para>
		/// </para>
		/// </summary>
		Present = 1,
		/// <summary>
		/// A BYE is pending. 
		/// <para>
		/// </para>
		/// </summary>
		Leaving = 2,
		/// <summary>
		/// The Session is terminated. 
		/// <para>
		/// </para>
		/// </summary>
		Left = 3,
		/// <summary>
		/// Initial state for the server group chatroom, when the participant has not yet
		/// been INVITEd. 
		/// <para>
		/// </para>
		/// </summary>
		ScheduledForJoining = 4,
		/// <summary>
		/// Transitional state for a participant that will receive a BYE shortly. 
		/// <para>
		/// </para>
		/// </summary>
		ScheduledForLeaving = 5,
		/// <summary>
		/// the SIP session has been concluded, participant is not media mixed 
		/// <para>
		/// </para>
		/// </summary>
		OnHold = 6,
		/// <summary>
		/// 180 Ringing 
		/// <para>
		/// </para>
		/// </summary>
		Alerting = 7,
		/// <summary>
		/// Some medias have been muted by the focus. 
		/// <para>
		/// </para>
		/// </summary>
		MutedByFocus = 8,
	}

	/// <summary>
	/// <see cref="Linphone.ParticipantRole">Linphone.ParticipantRole</see> is used to
	/// define a role of a participant within a conference 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ParticipantRole
	{
		/// <summary>
		/// participant is a speaker in the conference 
		/// <para>
		/// </para>
		/// </summary>
		Speaker = 0,
		/// <summary>
		/// participant is a listener in the conference. 
		/// <para>
		/// He/She cannot speak 
		/// </para>
		/// </summary>
		Listener = 1,
		/// <summary>
		/// participant role is unknown 
		/// <para>
		/// </para>
		/// </summary>
		Unknown = 2,
	}

	/// <summary>
	/// The state of a <see cref="Linphone.Player">Linphone.Player</see>. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum PlayerState
	{
		/// <summary>
		/// No file is opened for playing. 
		/// <para>
		/// </para>
		/// </summary>
		Closed = 0,
		/// <summary>
		/// The player is paused. 
		/// <para>
		/// </para>
		/// </summary>
		Paused = 1,
		/// <summary>
		/// The player is playing. 
		/// <para>
		/// </para>
		/// </summary>
		Playing = 2,
	}

	/// <summary>
	/// Activities as defined in section 3.2 of RFC 4480. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum PresenceActivityType
	{
		/// <summary>
		/// The person has a calendar appointment, without specifying exactly of what type. 
		/// <para>
		/// This activity is indicated if more detailed information is not available or the
		/// person chooses not to reveal more information. 
		/// </para>
		/// </summary>
		Appointment = 0,
		/// <summary>
		/// The person is physically away from all interactive communication devices. 
		/// <para>
		/// </para>
		/// </summary>
		Away = 1,
		/// <summary>
		/// The person is eating the first meal of the day, usually eaten in the morning. 
		/// <para>
		/// </para>
		/// </summary>
		Breakfast = 2,
		/// <summary>
		/// The person is busy, without further details. 
		/// <para>
		/// </para>
		/// </summary>
		Busy = 3,
		/// <summary>
		/// The person is having his or her main meal of the day, eaten in the evening or
		/// at midday. 
		/// <para>
		/// </para>
		/// </summary>
		Dinner = 4,
		/// <summary>
		/// This is a scheduled national or local holiday. 
		/// <para>
		/// </para>
		/// </summary>
		Holiday = 5,
		/// <summary>
		/// The person is riding in a vehicle, such as a car, but not steering. 
		/// <para>
		/// </para>
		/// </summary>
		InTransit = 6,
		/// <summary>
		/// The person is looking for (paid) work. 
		/// <para>
		/// </para>
		/// </summary>
		LookingForWork = 7,
		/// <summary>
		/// The person is eating his or her midday meal. 
		/// <para>
		/// </para>
		/// </summary>
		Lunch = 8,
		/// <summary>
		/// The person is scheduled for a meal, without specifying whether it is breakfast,
		/// lunch, or dinner, or some other meal. 
		/// <para>
		/// </para>
		/// </summary>
		Meal = 9,
		/// <summary>
		/// The person is in an assembly or gathering of people, as for a business, social,
		/// or religious purpose. 
		/// <para>
		/// A meeting is a sub-class of an appointment. 
		/// </para>
		/// </summary>
		Meeting = 10,
		/// <summary>
		/// The person is talking on the telephone. 
		/// <para>
		/// </para>
		/// </summary>
		OnThePhone = 11,
		/// <summary>
		/// The person is engaged in an activity with no defined representation. 
		/// <para>
		/// A string describing the activity in plain text SHOULD be provided. 
		/// </para>
		/// </summary>
		Other = 12,
		/// <summary>
		/// A performance is a sub-class of an appointment and includes musical,
		/// theatrical, and cinematic performances as well as lectures. 
		/// <para>
		/// It is distinguished from a meeting by the fact that the person may either be
		/// lecturing or be in the audience, with a potentially large number of other
		/// people, making interruptions particularly noticeable. 
		/// </para>
		/// </summary>
		Performance = 13,
		/// <summary>
		/// The person will not return for the foreseeable future, e.g., because it is no
		/// longer working for the company. 
		/// <para>
		/// </para>
		/// </summary>
		PermanentAbsence = 14,
		/// <summary>
		/// The person is occupying himself or herself in amusement, sport, or other
		/// recreation. 
		/// <para>
		/// </para>
		/// </summary>
		Playing = 15,
		/// <summary>
		/// The person is giving a presentation, lecture, or participating in a formal
		/// round-table discussion. 
		/// <para>
		/// </para>
		/// </summary>
		Presentation = 16,
		/// <summary>
		/// The person is visiting stores in search of goods or services. 
		/// <para>
		/// </para>
		/// </summary>
		Shopping = 17,
		/// <summary>
		/// The person is sleeping. 
		/// <para>
		/// </para>
		/// </summary>
		Sleeping = 18,
		/// <summary>
		/// The person is observing an event, such as a sports event. 
		/// <para>
		/// </para>
		/// </summary>
		Spectator = 19,
		/// <summary>
		/// The person is controlling a vehicle, watercraft, or plane. 
		/// <para>
		/// </para>
		/// </summary>
		Steering = 20,
		/// <summary>
		/// The person is on a business or personal trip, but not necessarily in-transit. 
		/// <para>
		/// </para>
		/// </summary>
		Travel = 21,
		/// <summary>
		/// The person is watching television. 
		/// <para>
		/// </para>
		/// </summary>
		TV = 22,
		/// <summary>
		/// The activity of the person is unknown. 
		/// <para>
		/// </para>
		/// </summary>
		Unknown = 23,
		/// <summary>
		/// A period of time devoted to pleasure, rest, or relaxation. 
		/// <para>
		/// </para>
		/// </summary>
		Vacation = 24,
		/// <summary>
		/// The person is engaged in, typically paid, labor, as part of a profession or
		/// job. 
		/// <para>
		/// </para>
		/// </summary>
		Working = 25,
		/// <summary>
		/// The person is participating in religious rites. 
		/// <para>
		/// </para>
		/// </summary>
		Worship = 26,
	}

	/// <summary>
	/// Basic status as defined in section 4.1.4 of RFC 3863. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum PresenceBasicStatus
	{
		/// <summary>
		/// This value means that the associated contact element, if any, is ready to
		/// accept communication. 
		/// <para>
		/// </para>
		/// </summary>
		Open = 0,
		/// <summary>
		/// This value means that the associated contact element, if any, is unable to
		/// accept communication. 
		/// <para>
		/// </para>
		/// </summary>
		Closed = 1,
	}

	/// <summary>
	/// Defines privacy policy to apply as described by rfc3323. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum Privacy
	{
		/// <summary>
		/// Privacy services must not perform any privacy function. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Request that privacy services provide a user-level privacy function. 
		/// <para>
		/// With this mode, &quot;from&quot; header is hidden, usually replaced by From:
		/// &quot;Anonymous&quot; &lt;sip:anonymous@anonymous.invalid&gt; 
		/// </para>
		/// </summary>
		User = 1,
		/// <summary>
		/// Request that privacy services modify headers that cannot be set arbitrarily by
		/// the user (Contact/Via). 
		/// <para>
		/// </para>
		/// </summary>
		Header = 2,
		/// <summary>
		/// Request that privacy services provide privacy for session media. 
		/// <para>
		/// </para>
		/// </summary>
		Session = 4,
		/// <summary>
		/// rfc3325 The presence of this privacy type in a Privacy header field indicates
		/// that the user would like the Network Asserted Identity to be kept private with
		/// respect to SIP entities outside the Trust Domain with which the user
		/// authenticated. 
		/// <para>
		/// Note that a user requesting multiple types of privacy MUST include all of the
		/// requested privacy types in its Privacy header field value 
		/// </para>
		/// </summary>
		Id = 8,
		/// <summary>
		/// Privacy service must perform the specified services or fail the request. 
		/// <para>
		/// </para>
		/// </summary>
		Critical = 16,
		/// <summary>
		/// Special keyword to use privacy as defined either globally or by proxy using
		/// <see cref="Linphone.ProxyConfig.Privacy">Linphone.ProxyConfig.Privacy</see> 
		/// <para>
		/// </para>
		/// </summary>
		Default = 32768,
	}

	/// <summary>
	/// Enum for publish states. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum PublishState
	{
		/// <summary>
		/// Initial state, do not use. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// An incoming publish is received. 
		/// <para>
		/// </para>
		/// </summary>
		IncomingReceived = 1,
		/// <summary>
		/// Publish is accepted. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 2,
		/// <summary>
		/// Publish encoutered an error, <see cref="Linphone.Event.Reason">
		/// Linphone.Event.Reason</see> gives reason code. 
		/// <para>
		/// </para>
		/// </summary>
		Error = 3,
		/// <summary>
		/// Publish is about to expire, only sent if [sip]-&gt;refresh_generic_publish
		/// property is set to 0. 
		/// <para>
		/// </para>
		/// </summary>
		Expiring = 4,
		/// <summary>
		/// Event has been un published. 
		/// <para>
		/// </para>
		/// </summary>
		Cleared = 5,
		/// <summary>
		/// Publish is about to terminate. 
		/// <para>
		/// </para>
		/// </summary>
		Terminating = 6,
		/// <summary>
		/// An outgoing publish was created and submitted. 
		/// <para>
		/// </para>
		/// </summary>
		OutgoingProgress = 7,
	}

	/// <summary>
	/// Enum describing various failure reasons or contextual information for some
	/// events. 
	/// <para>
	/// </para>
	/// </summary>
	/// <remarks>See : <see cref="Linphone.Call.Reason">Linphone.Call.Reason</see>
	/// </remarks>
	/// <remarks>See : <see cref="Linphone.ProxyConfig.Error">
	/// Linphone.ProxyConfig.Error</see> </remarks>
	/// <remarks>See : <see cref="Linphone.ErrorInfo.Reason">
	/// Linphone.ErrorInfo.Reason</see> </remarks>
	
	public enum Reason
	{
		/// <summary>
		/// No reason has been set by the core. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// No response received from remote. 
		/// <para>
		/// </para>
		/// </summary>
		NoResponse = 1,
		/// <summary>
		/// Authentication failed due to bad credentials or resource forbidden. 
		/// <para>
		/// </para>
		/// </summary>
		Forbidden = 2,
		/// <summary>
		/// The call has been declined. 
		/// <para>
		/// </para>
		/// </summary>
		Declined = 3,
		/// <summary>
		/// Destination of the call was not found. 
		/// <para>
		/// </para>
		/// </summary>
		NotFound = 4,
		/// <summary>
		/// The call was not answered in time (request timeout) 
		/// <para>
		/// </para>
		/// </summary>
		NotAnswered = 5,
		/// <summary>
		/// Phone line was busy. 
		/// <para>
		/// </para>
		/// </summary>
		Busy = 6,
		/// <summary>
		/// Unsupported content. 
		/// <para>
		/// </para>
		/// </summary>
		UnsupportedContent = 7,
		/// <summary>
		/// Bad event. 
		/// <para>
		/// </para>
		/// </summary>
		BadEvent = 8,
		/// <summary>
		/// Transport error: connection failures, disconnections etc... 
		/// <para>
		/// </para>
		/// </summary>
		IOError = 9,
		/// <summary>
		/// Do not disturb reason. 
		/// <para>
		/// </para>
		/// </summary>
		DoNotDisturb = 10,
		/// <summary>
		/// Operation is unauthorized because missing credential. 
		/// <para>
		/// </para>
		/// </summary>
		Unauthorized = 11,
		/// <summary>
		/// Operation is rejected due to incompatible or unsupported media parameters. 
		/// <para>
		/// </para>
		/// </summary>
		NotAcceptable = 12,
		/// <summary>
		/// Operation could not be executed by server or remote client because it
		/// didn&apos;t have any context for it. 
		/// <para>
		/// </para>
		/// </summary>
		NoMatch = 13,
		/// <summary>
		/// Resource moved permanently. 
		/// <para>
		/// </para>
		/// </summary>
		MovedPermanently = 14,
		/// <summary>
		/// Resource no longer exists. 
		/// <para>
		/// </para>
		/// </summary>
		Gone = 15,
		/// <summary>
		/// Temporarily unavailable. 
		/// <para>
		/// </para>
		/// </summary>
		TemporarilyUnavailable = 16,
		/// <summary>
		/// Address incomplete. 
		/// <para>
		/// </para>
		/// </summary>
		AddressIncomplete = 17,
		/// <summary>
		/// Not implemented. 
		/// <para>
		/// </para>
		/// </summary>
		NotImplemented = 18,
		/// <summary>
		/// Bad gateway. 
		/// <para>
		/// </para>
		/// </summary>
		BadGateway = 19,
		/// <summary>
		/// The received request contains a Session-Expires header field with a duration
		/// below the minimum timer. 
		/// <para>
		/// </para>
		/// </summary>
		SessionIntervalTooSmall = 20,
		/// <summary>
		/// Server timeout. 
		/// <para>
		/// </para>
		/// </summary>
		ServerTimeout = 21,
		/// <summary>
		/// Unknown reason. 
		/// <para>
		/// </para>
		/// </summary>
		Unknown = 22,
		/// <summary>
		/// The call has been transferred. 
		/// <para>
		/// </para>
		/// </summary>
		Transferred = 23,
		/// <summary>
		/// Conditional Request Failed. 
		/// <para>
		/// </para>
		/// </summary>
		ConditionalRequestFailed = 24,
	}

	/// <summary>
	/// Enum representing the file format of a recording. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum RecorderFileFormat
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Unknown = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Wav = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Mkv = 2,
	}

	/// <summary>
	/// Enum representing the state of a recording. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum RecorderState
	{
		/// <summary>
		/// No file is opened for recording. 
		/// <para>
		/// </para>
		/// </summary>
		Closed = 0,
		/// <summary>
		/// The recorder is paused. 
		/// <para>
		/// </para>
		/// </summary>
		Paused = 1,
		/// <summary>
		/// The recorder is running. 
		/// <para>
		/// </para>
		/// </summary>
		Running = 2,
	}

	/// <summary>
	/// Describes proxy registration states. 
	/// <para>
	/// It is notified via the registration_state_changed() callback in <see cref="Linphone.CoreListener">
	/// Linphone.CoreListener</see>. 
	/// </para>
	/// </summary>
	
	public enum RegistrationState
	{
		/// <summary>
		/// Initial state for registrations. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Registration is in progress. 
		/// <para>
		/// </para>
		/// </summary>
		Progress = 1,
		/// <summary>
		/// Registration is successful. 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 2,
		/// <summary>
		/// Unregistration succeeded. 
		/// <para>
		/// </para>
		/// </summary>
		Cleared = 3,
		/// <summary>
		/// Registration failed. 
		/// <para>
		/// </para>
		/// </summary>
		Failed = 4,
		/// <summary>
		/// Registration refreshing. 
		/// <para>
		/// </para>
		/// </summary>
		Refreshing = 5,
	}

	/// <summary>
	/// <see cref="Linphone.SecurityEventType">Linphone.SecurityEventType</see> is used
	/// to indicate the type of security event. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum SecurityEventType
	{
		/// <summary>
		/// Event is not a security event. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// Chatroom security level downgraded event. 
		/// <para>
		/// </para>
		/// </summary>
		SecurityLevelDowngraded = 1,
		/// <summary>
		/// Participant has exceeded the maximum number of device event. 
		/// <para>
		/// </para>
		/// </summary>
		ParticipantMaxDeviceCountExceeded = 2,
		/// <summary>
		/// Peer device instant messaging encryption identity key has changed event. 
		/// <para>
		/// </para>
		/// </summary>
		EncryptionIdentityKeyChanged = 3,
		/// <summary>
		/// Man in the middle detected event. 
		/// <para>
		/// </para>
		/// </summary>
		ManInTheMiddleDetected = 4,
	}

	/// <summary>
	/// Session Timers refresher. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum SessionExpiresRefresher
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Unspecified = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		UAS = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		UAC = 2,
	}

	/// <summary>
	/// All signal units that a device can use. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum SignalStrengthUnit
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Rssi = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Dbm = 1,
	}

	/// <summary>
	/// All signal types that a device can use. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum SignalType
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Wifi = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Mobile = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Other = 2,
	}

	/// <summary>
	/// Enum describing type of SRTP encryption suite. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum SrtpSuite
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		AESCM128HMACSHA180 = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		AESCM128HMACSHA132 = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		AES192CMHMACSHA180 = 2,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		AES192CMHMACSHA132 = 3,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		AES256CMHMACSHA180 = 4,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		AES256CMHMACSHA132 = 5,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		AEADAES128GCM = 6,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		AEADAES256GCM = 7,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Invalid = 255,
	}

	/// <summary>
	/// Enum describing the stream types. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum StreamType
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Audio = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Video = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Text = 2,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Unknown = 3,
	}

	/// <summary>
	/// Enum controlling behavior for incoming subscription request. 
	/// <para>
	/// Use by <see cref="Linphone.Friend.IncSubscribePolicy">
	/// Linphone.Friend.IncSubscribePolicy</see> 
	/// </para>
	/// </summary>
	
	public enum SubscribePolicy
	{
		/// <summary>
		/// Does not automatically accept an incoming subscription request. 
		/// <para>
		/// This policy implies that a decision has to be taken for each incoming
		/// subscription request notified by callback
		/// LinphoneCoreVTable.new_subscription_requested 
		/// </para>
		/// </summary>
		SPWait = 0,
		/// <summary>
		/// Rejects incoming subscription request. 
		/// <para>
		/// </para>
		/// </summary>
		SPDeny = 1,
		/// <summary>
		/// Automatically accepts a subscription request. 
		/// <para>
		/// </para>
		/// </summary>
		SPAccept = 2,
	}

	/// <summary>
	/// Enum for subscription direction (incoming or outgoing). 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum SubscriptionDir
	{
		/// <summary>
		/// Incoming subscription. 
		/// <para>
		/// </para>
		/// </summary>
		Incoming = 0,
		/// <summary>
		/// Outgoing subscription. 
		/// <para>
		/// </para>
		/// </summary>
		Outgoing = 1,
		/// <summary>
		/// Invalid subscription direction. 
		/// <para>
		/// </para>
		/// </summary>
		InvalidDir = 2,
	}

	/// <summary>
	/// Enum for subscription states. 
	/// <para>
	/// <see cref="Linphone.SubscriptionState.Terminated">
	/// Linphone.SubscriptionState.Terminated</see> and <see cref="Linphone.SubscriptionState.Error">
	/// Linphone.SubscriptionState.Error</see> are final states. 
	/// </para>
	/// </summary>
	
	public enum SubscriptionState
	{
		/// <summary>
		/// Initial state, should not be used. 
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// An outgoing subcription was sent. 
		/// <para>
		/// </para>
		/// </summary>
		OutgoingProgress = 1,
		/// <summary>
		/// An incoming subcription is received. 
		/// <para>
		/// </para>
		/// </summary>
		IncomingReceived = 2,
		/// <summary>
		/// Subscription is pending, waiting for user approval. 
		/// <para>
		/// </para>
		/// </summary>
		Pending = 3,
		/// <summary>
		/// Subscription is accepted. 
		/// <para>
		/// </para>
		/// </summary>
		Active = 4,
		/// <summary>
		/// Subscription is terminated normally. 
		/// <para>
		/// </para>
		/// </summary>
		Terminated = 5,
		/// <summary>
		/// Subscription was terminated by an error, indicated by <see cref="Linphone.Event.Reason">
		/// Linphone.Event.Reason</see> 
		/// <para>
		/// </para>
		/// </summary>
		Error = 6,
		/// <summary>
		/// Subscription is about to expire, only sent if
		/// [sip]-&gt;refresh_generic_subscribe property is set to 0. 
		/// <para>
		/// </para>
		/// </summary>
		Expiring = 7,
	}

	/// <summary>
	/// <para>
	/// </para>
	/// </summary>
	
	public enum SupportLevel
	{
		/// <summary>
		/// No support for the feature. 
		/// <para>
		/// </para>
		/// </summary>
		NoSupport = 0,
		/// <summary>
		/// Optional support for the feature. 
		/// <para>
		/// </para>
		/// </summary>
		Optional = 1,
		/// <summary>
		/// Mandatory support for the feature. 
		/// <para>
		/// </para>
		/// </summary>
		Mandatory = 2,
	}

	/// <summary>
	/// Enum listing frequent telephony tones. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ToneID
	{
		/// <summary>
		/// Not a tone. 
		/// <para>
		/// </para>
		/// </summary>
		Undefined = 0,
		/// <summary>
		/// Busy tone. 
		/// <para>
		/// </para>
		/// </summary>
		Busy = 1,
		/// <summary>
		/// Call waiting tone. 
		/// <para>
		/// </para>
		/// </summary>
		CallWaiting = 2,
		/// <summary>
		/// Call on hold tone. 
		/// <para>
		/// </para>
		/// </summary>
		CallOnHold = 3,
		/// <summary>
		/// Tone played when call is abruptly disconnected (media lost) 
		/// <para>
		/// </para>
		/// </summary>
		CallLost = 4,
		/// <summary>
		/// When the call end for any reason but lost. 
		/// <para>
		/// </para>
		/// </summary>
		CallEnd = 5,
		/// <summary>
		/// When the call is not answered. 
		/// <para>
		/// </para>
		/// </summary>
		CallNotAnswered = 6,
	}

	/// <summary>
	/// Enum describing transport type for LinphoneAddress. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum TransportType
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Udp = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Tcp = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Tls = 2,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Dtls = 3,
	}

	/// <summary>
	/// Enum describing the tunnel modes. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum TunnelMode
	{
		/// <summary>
		/// The tunnel is disabled. 
		/// <para>
		/// </para>
		/// </summary>
		Disable = 0,
		/// <summary>
		/// The tunnel is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		Enable = 1,
		/// <summary>
		/// The tunnel is enabled automatically if it is required. 
		/// <para>
		/// </para>
		/// </summary>
		Auto = 2,
	}

	/// <summary>
	/// Enum describing uPnP states. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum UpnpState
	{
		/// <summary>
		/// uPnP is not activate 
		/// <para>
		/// </para>
		/// </summary>
		Idle = 0,
		/// <summary>
		/// uPnP process is in progress 
		/// <para>
		/// </para>
		/// </summary>
		Pending = 1,
		/// <summary>
		/// Internal use: Only used by port binding. 
		/// <para>
		/// </para>
		/// </summary>
		Adding = 2,
		/// <summary>
		/// Internal use: Only used by port binding. 
		/// <para>
		/// </para>
		/// </summary>
		Removing = 3,
		/// <summary>
		/// uPnP is not available 
		/// <para>
		/// </para>
		/// </summary>
		NotAvailable = 4,
		/// <summary>
		/// uPnP is enabled 
		/// <para>
		/// </para>
		/// </summary>
		Ok = 5,
		/// <summary>
		/// uPnP processing has failed 
		/// <para>
		/// </para>
		/// </summary>
		Ko = 6,
		/// <summary>
		/// IGD router is blacklisted. 
		/// <para>
		/// </para>
		/// </summary>
		Blacklisted = 7,
	}

	/// <summary>
	/// Enum describing the result of a version update check. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum VersionUpdateCheckResult
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		UpToDate = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		NewVersionAvailable = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Error = 2,
	}

	/// <summary>
	/// Enum representing the type of a video source. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum VideoSourceType
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Unknown = 0,
		/// <summary>
		/// The video source is another call. 
		/// <para>
		/// </para>
		/// </summary>
		Call = 1,
		/// <summary>
		/// The video source is a camera. 
		/// <para>
		/// </para>
		/// </summary>
		Camera = 2,
		/// <summary>
		/// The video source is an image. 
		/// <para>
		/// </para>
		/// </summary>
		Image = 3,
	}

	/// <summary>
	/// Enum describing the types of argument for LinphoneXmlRpcRequest. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum XmlRpcArgType
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		None = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Int = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		String = 2,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		StringStruct = 3,
	}

	/// <summary>
	/// Enum describing the status of a LinphoneXmlRpcRequest. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum XmlRpcStatus
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Pending = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Ok = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Failed = 2,
	}

	/// <summary>
	/// Enum describing the ZRTP key exchange algorithns. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ZrtpKeyAgreement
	{
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Invalid = 0,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Dh2K = 1,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Dh3K = 2,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Ec25 = 3,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Ec38 = 4,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Ec52 = 5,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		X255 = 6,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		X448 = 7,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		K255 = 8,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		K448 = 9,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Kyb1 = 10,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Kyb2 = 11,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Kyb3 = 12,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Hqc1 = 13,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Hqc2 = 14,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		Hqc3 = 15,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		K255Kyb512 = 16,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		K255Hqc128 = 17,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		K448Kyb1024 = 18,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		K448Hqc256 = 19,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		K255Kyb512Hqc128 = 20,
		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		K448Kyb1024Hqc256 = 21,
	}

	/// <summary>
	/// Enum describing the ZRTP SAS validation status of a peer URI. 
	/// <para>
	/// </para>
	/// </summary>
	
	public enum ZrtpPeerStatus
	{
		/// <summary>
		/// Peer URI unkown or never validated/invalidated the SAS. 
		/// <para>
		/// </para>
		/// </summary>
		Unknown = 0,
		/// <summary>
		/// Peer URI SAS rejected in database. 
		/// <para>
		/// </para>
		/// </summary>
		Invalid = 1,
		/// <summary>
		/// Peer URI SAS validated in database. 
		/// <para>
		/// </para>
		/// </summary>
		Valid = 2,
	}

#endregion

#region Listeners
	/// <summary>
	/// An object to handle the callbacks for the handling of <see cref="Linphone.Account">
	/// Linphone.Account</see> objects. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class AccountListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_cbs_set_registration_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_cbs_set_registration_state_changed(IntPtr thiz, OnRegistrationStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnRegistrationStateChangedDelegatePrivate(IntPtr account, int state, IntPtr message);

		/// <summary>
		/// Callback for notifying when a registration state has changed for the account. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="account">LinphoneAccount object whose registration state changed. 
		///   </param>
		/// <param name="state">The current LinphoneRegistrationState. </param>
		/// <param name="message">A non null informational message about the state.   
		/// </param>
		public delegate void OnRegistrationStateChangedDelegate(Linphone.Account account, Linphone.RegistrationState state, string message);
		private OnRegistrationStateChangedDelegatePrivate on_registration_state_changed_private;
		private OnRegistrationStateChangedDelegate on_registration_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnRegistrationStateChangedDelegatePrivate))]
#endif
		private static void on_registration_state_changed(IntPtr account, int state, IntPtr message)
		{
			Account thiz = fromNativePtr<Account>(account);

			IntPtr ptr = linphone_account_get_current_callbacks(thiz.nativePtr);
			AccountListener current_listener = fromNativePtr<AccountListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_registration_state_changed_public?.Invoke(thiz, (Linphone.RegistrationState)state, PtrToStringSafe(message));
			}
		}

		public OnRegistrationStateChangedDelegate OnRegistrationStateChanged
		{
			get
			{
				return on_registration_state_changed_public;
			}
			set
			{
				on_registration_state_changed_public = value;
				on_registration_state_changed_private = on_registration_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_registration_state_changed_private);
				linphone_account_cbs_set_registration_state_changed(nativePtr, cb);
#else
				linphone_account_cbs_set_registration_state_changed(nativePtr, on_registration_state_changed_private);
#endif
			}
		}
	}

	/// <summary>
	/// An object to handle the responses callbacks for handling the <see cref="Linphone.AccountCreator">
	/// Linphone.AccountCreator</see> operations. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class AccountCreatorListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_create_account(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_create_account(IntPtr thiz, OnCreateAccountDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCreateAccountDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnCreateAccountDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnCreateAccountDelegatePrivate on_create_account_private;
		private OnCreateAccountDelegate on_create_account_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCreateAccountDelegatePrivate))]
#endif
		private static void on_create_account(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_create_account_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnCreateAccountDelegate OnCreateAccount
		{
			get
			{
				return on_create_account_public;
			}
			set
			{
				on_create_account_public = value;
				on_create_account_private = on_create_account;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_create_account_private);
				linphone_account_creator_cbs_set_create_account(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_create_account(nativePtr, on_create_account_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_is_account_exist(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_is_account_exist(IntPtr thiz, OnIsAccountExistDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsAccountExistDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnIsAccountExistDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnIsAccountExistDelegatePrivate on_is_account_exist_private;
		private OnIsAccountExistDelegate on_is_account_exist_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsAccountExistDelegatePrivate))]
#endif
		private static void on_is_account_exist(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_is_account_exist_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnIsAccountExistDelegate OnIsAccountExist
		{
			get
			{
				return on_is_account_exist_public;
			}
			set
			{
				on_is_account_exist_public = value;
				on_is_account_exist_private = on_is_account_exist;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_account_exist_private);
				linphone_account_creator_cbs_set_is_account_exist(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_is_account_exist(nativePtr, on_is_account_exist_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_activate_account(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_activate_account(IntPtr thiz, OnActivateAccountDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnActivateAccountDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnActivateAccountDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnActivateAccountDelegatePrivate on_activate_account_private;
		private OnActivateAccountDelegate on_activate_account_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnActivateAccountDelegatePrivate))]
#endif
		private static void on_activate_account(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_activate_account_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnActivateAccountDelegate OnActivateAccount
		{
			get
			{
				return on_activate_account_public;
			}
			set
			{
				on_activate_account_public = value;
				on_activate_account_private = on_activate_account;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_activate_account_private);
				linphone_account_creator_cbs_set_activate_account(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_activate_account(nativePtr, on_activate_account_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_send_token(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_send_token(IntPtr thiz, OnSendTokenDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSendTokenDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnSendTokenDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnSendTokenDelegatePrivate on_send_token_private;
		private OnSendTokenDelegate on_send_token_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSendTokenDelegatePrivate))]
#endif
		private static void on_send_token(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_send_token_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnSendTokenDelegate OnSendToken
		{
			get
			{
				return on_send_token_public;
			}
			set
			{
				on_send_token_public = value;
				on_send_token_private = on_send_token;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_send_token_private);
				linphone_account_creator_cbs_set_send_token(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_send_token(nativePtr, on_send_token_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_account_creation_request_token(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_account_creation_request_token(IntPtr thiz, OnAccountCreationRequestTokenDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAccountCreationRequestTokenDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnAccountCreationRequestTokenDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnAccountCreationRequestTokenDelegatePrivate on_account_creation_request_token_private;
		private OnAccountCreationRequestTokenDelegate on_account_creation_request_token_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAccountCreationRequestTokenDelegatePrivate))]
#endif
		private static void on_account_creation_request_token(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_account_creation_request_token_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnAccountCreationRequestTokenDelegate OnAccountCreationRequestToken
		{
			get
			{
				return on_account_creation_request_token_public;
			}
			set
			{
				on_account_creation_request_token_public = value;
				on_account_creation_request_token_private = on_account_creation_request_token;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_account_creation_request_token_private);
				linphone_account_creator_cbs_set_account_creation_request_token(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_account_creation_request_token(nativePtr, on_account_creation_request_token_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_account_creation_token_using_request_token(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_account_creation_token_using_request_token(IntPtr thiz, OnAccountCreationTokenUsingRequestTokenDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAccountCreationTokenUsingRequestTokenDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnAccountCreationTokenUsingRequestTokenDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnAccountCreationTokenUsingRequestTokenDelegatePrivate on_account_creation_token_using_request_token_private;
		private OnAccountCreationTokenUsingRequestTokenDelegate on_account_creation_token_using_request_token_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAccountCreationTokenUsingRequestTokenDelegatePrivate))]
#endif
		private static void on_account_creation_token_using_request_token(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_account_creation_token_using_request_token_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnAccountCreationTokenUsingRequestTokenDelegate OnAccountCreationTokenUsingRequestToken
		{
			get
			{
				return on_account_creation_token_using_request_token_public;
			}
			set
			{
				on_account_creation_token_using_request_token_public = value;
				on_account_creation_token_using_request_token_private = on_account_creation_token_using_request_token;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_account_creation_token_using_request_token_private);
				linphone_account_creator_cbs_set_account_creation_token_using_request_token(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_account_creation_token_using_request_token(nativePtr, on_account_creation_token_using_request_token_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_is_account_activated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_is_account_activated(IntPtr thiz, OnIsAccountActivatedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsAccountActivatedDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnIsAccountActivatedDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnIsAccountActivatedDelegatePrivate on_is_account_activated_private;
		private OnIsAccountActivatedDelegate on_is_account_activated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsAccountActivatedDelegatePrivate))]
#endif
		private static void on_is_account_activated(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_is_account_activated_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnIsAccountActivatedDelegate OnIsAccountActivated
		{
			get
			{
				return on_is_account_activated_public;
			}
			set
			{
				on_is_account_activated_public = value;
				on_is_account_activated_private = on_is_account_activated;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_account_activated_private);
				linphone_account_creator_cbs_set_is_account_activated(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_is_account_activated(nativePtr, on_is_account_activated_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_link_account(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_link_account(IntPtr thiz, OnLinkAccountDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLinkAccountDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnLinkAccountDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnLinkAccountDelegatePrivate on_link_account_private;
		private OnLinkAccountDelegate on_link_account_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnLinkAccountDelegatePrivate))]
#endif
		private static void on_link_account(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_link_account_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnLinkAccountDelegate OnLinkAccount
		{
			get
			{
				return on_link_account_public;
			}
			set
			{
				on_link_account_public = value;
				on_link_account_private = on_link_account;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_link_account_private);
				linphone_account_creator_cbs_set_link_account(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_link_account(nativePtr, on_link_account_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_activate_alias(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_activate_alias(IntPtr thiz, OnActivateAliasDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnActivateAliasDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnActivateAliasDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnActivateAliasDelegatePrivate on_activate_alias_private;
		private OnActivateAliasDelegate on_activate_alias_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnActivateAliasDelegatePrivate))]
#endif
		private static void on_activate_alias(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_activate_alias_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnActivateAliasDelegate OnActivateAlias
		{
			get
			{
				return on_activate_alias_public;
			}
			set
			{
				on_activate_alias_public = value;
				on_activate_alias_private = on_activate_alias;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_activate_alias_private);
				linphone_account_creator_cbs_set_activate_alias(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_activate_alias(nativePtr, on_activate_alias_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_is_alias_used(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_is_alias_used(IntPtr thiz, OnIsAliasUsedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsAliasUsedDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnIsAliasUsedDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnIsAliasUsedDelegatePrivate on_is_alias_used_private;
		private OnIsAliasUsedDelegate on_is_alias_used_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsAliasUsedDelegatePrivate))]
#endif
		private static void on_is_alias_used(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_is_alias_used_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnIsAliasUsedDelegate OnIsAliasUsed
		{
			get
			{
				return on_is_alias_used_public;
			}
			set
			{
				on_is_alias_used_public = value;
				on_is_alias_used_private = on_is_alias_used;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_alias_used_private);
				linphone_account_creator_cbs_set_is_alias_used(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_is_alias_used(nativePtr, on_is_alias_used_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_is_account_linked(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_is_account_linked(IntPtr thiz, OnIsAccountLinkedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsAccountLinkedDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnIsAccountLinkedDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnIsAccountLinkedDelegatePrivate on_is_account_linked_private;
		private OnIsAccountLinkedDelegate on_is_account_linked_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsAccountLinkedDelegatePrivate))]
#endif
		private static void on_is_account_linked(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_is_account_linked_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnIsAccountLinkedDelegate OnIsAccountLinked
		{
			get
			{
				return on_is_account_linked_public;
			}
			set
			{
				on_is_account_linked_public = value;
				on_is_account_linked_private = on_is_account_linked;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_account_linked_private);
				linphone_account_creator_cbs_set_is_account_linked(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_is_account_linked(nativePtr, on_is_account_linked_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_recover_account(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_recover_account(IntPtr thiz, OnRecoverAccountDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnRecoverAccountDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnRecoverAccountDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnRecoverAccountDelegatePrivate on_recover_account_private;
		private OnRecoverAccountDelegate on_recover_account_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnRecoverAccountDelegatePrivate))]
#endif
		private static void on_recover_account(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_recover_account_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnRecoverAccountDelegate OnRecoverAccount
		{
			get
			{
				return on_recover_account_public;
			}
			set
			{
				on_recover_account_public = value;
				on_recover_account_private = on_recover_account;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_recover_account_private);
				linphone_account_creator_cbs_set_recover_account(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_recover_account(nativePtr, on_recover_account_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_update_account(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_update_account(IntPtr thiz, OnUpdateAccountDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnUpdateAccountDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnUpdateAccountDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnUpdateAccountDelegatePrivate on_update_account_private;
		private OnUpdateAccountDelegate on_update_account_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnUpdateAccountDelegatePrivate))]
#endif
		private static void on_update_account(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_update_account_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnUpdateAccountDelegate OnUpdateAccount
		{
			get
			{
				return on_update_account_public;
			}
			set
			{
				on_update_account_public = value;
				on_update_account_private = on_update_account;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_update_account_private);
				linphone_account_creator_cbs_set_update_account(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_update_account(nativePtr, on_update_account_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_account_creator_cbs_set_login_linphone_account(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_account_creator_cbs_set_login_linphone_account(IntPtr thiz, OnLoginLinphoneAccountDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLoginLinphoneAccountDelegatePrivate(IntPtr creator, int status, IntPtr response);

		/// <summary>
		/// Callback to notify a response of server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="creator"><see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object    </param>
		/// <param name="status">The status of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> test existence operation that has just finished
		/// </param>
		/// <param name="response">The response has a string    </param>
		public delegate void OnLoginLinphoneAccountDelegate(Linphone.AccountCreator creator, Linphone.AccountCreatorStatus status, string response);
		private OnLoginLinphoneAccountDelegatePrivate on_login_linphone_account_private;
		private OnLoginLinphoneAccountDelegate on_login_linphone_account_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnLoginLinphoneAccountDelegatePrivate))]
#endif
		private static void on_login_linphone_account(IntPtr creator, int status, IntPtr response)
		{
			AccountCreator thiz = fromNativePtr<AccountCreator>(creator);

			IntPtr ptr = linphone_account_creator_get_current_callbacks(thiz.nativePtr);
			AccountCreatorListener current_listener = fromNativePtr<AccountCreatorListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_login_linphone_account_public?.Invoke(thiz, (Linphone.AccountCreatorStatus)status, PtrToStringSafe(response));
			}
		}

		public OnLoginLinphoneAccountDelegate OnLoginLinphoneAccount
		{
			get
			{
				return on_login_linphone_account_public;
			}
			set
			{
				on_login_linphone_account_public = value;
				on_login_linphone_account_private = on_login_linphone_account;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_login_linphone_account_private);
				linphone_account_creator_cbs_set_login_linphone_account(nativePtr, cb);
#else
				linphone_account_creator_cbs_set_login_linphone_account(nativePtr, on_login_linphone_account_private);
#endif
			}
		}
	}

	/// <summary>
	/// Object that represents a callback attached to an alert. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class AlertListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_alert_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_alert_cbs_set_terminated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_alert_cbs_set_terminated(IntPtr thiz, OnTerminatedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnTerminatedDelegatePrivate(IntPtr alert);

		/// <summary>
		/// Callback to know if an alert stops. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="alert">the alert that stops    </param>
		public delegate void OnTerminatedDelegate(Linphone.Alert alert);
		private OnTerminatedDelegatePrivate on_terminated_private;
		private OnTerminatedDelegate on_terminated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnTerminatedDelegatePrivate))]
#endif
		private static void on_terminated(IntPtr alert)
		{
			Alert thiz = fromNativePtr<Alert>(alert);

			IntPtr ptr = linphone_alert_get_current_callbacks(thiz.nativePtr);
			AlertListener current_listener = fromNativePtr<AlertListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_terminated_public?.Invoke(thiz);
			}
		}

		public OnTerminatedDelegate OnTerminated
		{
			get
			{
				return on_terminated_public;
			}
			set
			{
				on_terminated_public = value;
				on_terminated_private = on_terminated;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_terminated_private);
				linphone_alert_cbs_set_terminated(nativePtr, cb);
#else
				linphone_alert_cbs_set_terminated(nativePtr, on_terminated_private);
#endif
			}
		}
	}

	/// <summary>
	/// That class holds all the callbacks which are called by <see cref="Linphone.Call">
	/// Linphone.Call</see> objects. 
	/// <para>
	/// Use <see cref="Linphone.Factory.CreateCallCbs()">
	/// Linphone.Factory.CreateCallCbs()</see> to create an instance. Then, call the
	/// callback setters on the events you need to monitor and pass the object to a
	/// <see cref="Linphone.Call">Linphone.Call</see> instance through <see cref="Linphone.Call.AddListener()">
	/// Linphone.Call.AddListener()</see>. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class CallListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_dtmf_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_dtmf_received(IntPtr thiz, OnDtmfReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnDtmfReceivedDelegatePrivate(IntPtr call, int dtmf);

		/// <summary>
		/// Callback for being notified of received DTMFs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall object that received the dtmf    </param>
		/// <param name="dtmf">The ascii code of the dtmf </param>
		public delegate void OnDtmfReceivedDelegate(Linphone.Call call, int dtmf);
		private OnDtmfReceivedDelegatePrivate on_dtmf_received_private;
		private OnDtmfReceivedDelegate on_dtmf_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnDtmfReceivedDelegatePrivate))]
#endif
		private static void on_dtmf_received(IntPtr call, int dtmf)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_dtmf_received_public?.Invoke(thiz, dtmf);
			}
		}

		public OnDtmfReceivedDelegate OnDtmfReceived
		{
			get
			{
				return on_dtmf_received_public;
			}
			set
			{
				on_dtmf_received_public = value;
				on_dtmf_received_private = on_dtmf_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_dtmf_received_private);
				linphone_call_cbs_set_dtmf_received(nativePtr, cb);
#else
				linphone_call_cbs_set_dtmf_received(nativePtr, on_dtmf_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_goclear_ack_sent(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_goclear_ack_sent(IntPtr thiz, OnGoclearAckSentDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnGoclearAckSentDelegatePrivate(IntPtr call);

		/// <summary>
		/// GoClear ACK sent callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">the <see cref="Linphone.Call">Linphone.Call</see> on which
		/// the GoClear ACK was sent.    </param>
		public delegate void OnGoclearAckSentDelegate(Linphone.Call call);
		private OnGoclearAckSentDelegatePrivate on_goclear_ack_sent_private;
		private OnGoclearAckSentDelegate on_goclear_ack_sent_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnGoclearAckSentDelegatePrivate))]
#endif
		private static void on_goclear_ack_sent(IntPtr call)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_goclear_ack_sent_public?.Invoke(thiz);
			}
		}

		public OnGoclearAckSentDelegate OnGoclearAckSent
		{
			get
			{
				return on_goclear_ack_sent_public;
			}
			set
			{
				on_goclear_ack_sent_public = value;
				on_goclear_ack_sent_private = on_goclear_ack_sent;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_goclear_ack_sent_private);
				linphone_call_cbs_set_goclear_ack_sent(nativePtr, cb);
#else
				linphone_call_cbs_set_goclear_ack_sent(nativePtr, on_goclear_ack_sent_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_encryption_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_encryption_changed(IntPtr thiz, OnEncryptionChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEncryptionChangedDelegatePrivate(IntPtr call, char on, IntPtr authenticationToken);

		/// <summary>
		/// Call encryption changed callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call"><see cref="Linphone.Call">Linphone.Call</see> object whose
		/// encryption is changed.    </param>
		/// <param name="on">Whether encryption is activated. </param>
		/// <param name="authenticationToken">An authentication_token, currently set for
		/// ZRTP kind of encryption only.    </param>
		public delegate void OnEncryptionChangedDelegate(Linphone.Call call, bool on, string authenticationToken);
		private OnEncryptionChangedDelegatePrivate on_encryption_changed_private;
		private OnEncryptionChangedDelegate on_encryption_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEncryptionChangedDelegatePrivate))]
#endif
		private static void on_encryption_changed(IntPtr call, char on, IntPtr authenticationToken)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_encryption_changed_public?.Invoke(thiz, on == 0, PtrToStringSafe(authenticationToken));
			}
		}

		public OnEncryptionChangedDelegate OnEncryptionChanged
		{
			get
			{
				return on_encryption_changed_public;
			}
			set
			{
				on_encryption_changed_public = value;
				on_encryption_changed_private = on_encryption_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_encryption_changed_private);
				linphone_call_cbs_set_encryption_changed(nativePtr, cb);
#else
				linphone_call_cbs_set_encryption_changed(nativePtr, on_encryption_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_send_master_key_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_send_master_key_changed(IntPtr thiz, OnSendMasterKeyChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSendMasterKeyChangedDelegatePrivate(IntPtr call, IntPtr sendMasterKey);

		/// <summary>
		/// Call send master key changed callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call"><see cref="Linphone.Call">Linphone.Call</see> object whose
		/// encryption is changed.    </param>
		/// <param name="sendMasterKey">The send master key of the SRTP session.    </param>
		public delegate void OnSendMasterKeyChangedDelegate(Linphone.Call call, string sendMasterKey);
		private OnSendMasterKeyChangedDelegatePrivate on_send_master_key_changed_private;
		private OnSendMasterKeyChangedDelegate on_send_master_key_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSendMasterKeyChangedDelegatePrivate))]
#endif
		private static void on_send_master_key_changed(IntPtr call, IntPtr sendMasterKey)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_send_master_key_changed_public?.Invoke(thiz, PtrToStringSafe(sendMasterKey));
			}
		}

		public OnSendMasterKeyChangedDelegate OnSendMasterKeyChanged
		{
			get
			{
				return on_send_master_key_changed_public;
			}
			set
			{
				on_send_master_key_changed_public = value;
				on_send_master_key_changed_private = on_send_master_key_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_send_master_key_changed_private);
				linphone_call_cbs_set_send_master_key_changed(nativePtr, cb);
#else
				linphone_call_cbs_set_send_master_key_changed(nativePtr, on_send_master_key_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_receive_master_key_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_receive_master_key_changed(IntPtr thiz, OnReceiveMasterKeyChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnReceiveMasterKeyChangedDelegatePrivate(IntPtr call, IntPtr receiveMasterKey);

		/// <summary>
		/// Call receive master key changed callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call"><see cref="Linphone.Call">Linphone.Call</see> object whose
		/// encryption is changed.    </param>
		/// <param name="receiveMasterKey">The receive master key of the SRTP session.   
		/// </param>
		public delegate void OnReceiveMasterKeyChangedDelegate(Linphone.Call call, string receiveMasterKey);
		private OnReceiveMasterKeyChangedDelegatePrivate on_receive_master_key_changed_private;
		private OnReceiveMasterKeyChangedDelegate on_receive_master_key_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnReceiveMasterKeyChangedDelegatePrivate))]
#endif
		private static void on_receive_master_key_changed(IntPtr call, IntPtr receiveMasterKey)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_receive_master_key_changed_public?.Invoke(thiz, PtrToStringSafe(receiveMasterKey));
			}
		}

		public OnReceiveMasterKeyChangedDelegate OnReceiveMasterKeyChanged
		{
			get
			{
				return on_receive_master_key_changed_public;
			}
			set
			{
				on_receive_master_key_changed_public = value;
				on_receive_master_key_changed_private = on_receive_master_key_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_receive_master_key_changed_private);
				linphone_call_cbs_set_receive_master_key_changed(nativePtr, cb);
#else
				linphone_call_cbs_set_receive_master_key_changed(nativePtr, on_receive_master_key_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_info_message_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_info_message_received(IntPtr thiz, OnInfoMessageReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnInfoMessageReceivedDelegatePrivate(IntPtr call, IntPtr message);

		/// <summary>
		/// Callback for receiving info messages. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call"><see cref="Linphone.Call">Linphone.Call</see> whose info
		/// message belongs to.    </param>
		/// <param name="message"><see cref="Linphone.InfoMessage">
		/// Linphone.InfoMessage</see> object.    </param>
		public delegate void OnInfoMessageReceivedDelegate(Linphone.Call call, Linphone.InfoMessage message);
		private OnInfoMessageReceivedDelegatePrivate on_info_message_received_private;
		private OnInfoMessageReceivedDelegate on_info_message_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnInfoMessageReceivedDelegatePrivate))]
#endif
		private static void on_info_message_received(IntPtr call, IntPtr message)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_info_message_received_public?.Invoke(thiz, fromNativePtr<Linphone.InfoMessage>(message));
			}
		}

		public OnInfoMessageReceivedDelegate OnInfoMessageReceived
		{
			get
			{
				return on_info_message_received_public;
			}
			set
			{
				on_info_message_received_public = value;
				on_info_message_received_private = on_info_message_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_info_message_received_private);
				linphone_call_cbs_set_info_message_received(nativePtr, cb);
#else
				linphone_call_cbs_set_info_message_received(nativePtr, on_info_message_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_state_changed(IntPtr thiz, OnStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnStateChangedDelegatePrivate(IntPtr call, int state, IntPtr message);

		/// <summary>
		/// Call state notification callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call"><see cref="Linphone.Call">Linphone.Call</see> whose state is
		/// changed.    </param>
		/// <param name="state">The new <see cref="Linphone.CallState">
		/// Linphone.CallState</see> of the call </param>
		/// <param name="message">An informational message about the state.    </param>
		public delegate void OnStateChangedDelegate(Linphone.Call call, Linphone.CallState state, string message);
		private OnStateChangedDelegatePrivate on_state_changed_private;
		private OnStateChangedDelegate on_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnStateChangedDelegatePrivate))]
#endif
		private static void on_state_changed(IntPtr call, int state, IntPtr message)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_state_changed_public?.Invoke(thiz, (Linphone.CallState)state, PtrToStringSafe(message));
			}
		}

		public OnStateChangedDelegate OnStateChanged
		{
			get
			{
				return on_state_changed_public;
			}
			set
			{
				on_state_changed_public = value;
				on_state_changed_private = on_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_state_changed_private);
				linphone_call_cbs_set_state_changed(nativePtr, cb);
#else
				linphone_call_cbs_set_state_changed(nativePtr, on_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_stats_updated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_stats_updated(IntPtr thiz, OnStatsUpdatedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnStatsUpdatedDelegatePrivate(IntPtr call, IntPtr stats);

		/// <summary>
		/// Callback for receiving quality statistics for calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call"><see cref="Linphone.Call">Linphone.Call</see> object whose
		/// statistics are notified    </param>
		/// <param name="stats"><see cref="Linphone.CallStats">Linphone.CallStats</see>
		/// object    </param>
		public delegate void OnStatsUpdatedDelegate(Linphone.Call call, Linphone.CallStats stats);
		private OnStatsUpdatedDelegatePrivate on_stats_updated_private;
		private OnStatsUpdatedDelegate on_stats_updated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnStatsUpdatedDelegatePrivate))]
#endif
		private static void on_stats_updated(IntPtr call, IntPtr stats)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_stats_updated_public?.Invoke(thiz, fromNativePtr<Linphone.CallStats>(stats));
			}
		}

		public OnStatsUpdatedDelegate OnStatsUpdated
		{
			get
			{
				return on_stats_updated_public;
			}
			set
			{
				on_stats_updated_public = value;
				on_stats_updated_private = on_stats_updated;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_stats_updated_private);
				linphone_call_cbs_set_stats_updated(nativePtr, cb);
#else
				linphone_call_cbs_set_stats_updated(nativePtr, on_stats_updated_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_transfer_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_transfer_state_changed(IntPtr thiz, OnTransferStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnTransferStateChangedDelegatePrivate(IntPtr call, int state);

		/// <summary>
		/// Callback for notifying progresses of transfers. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall that was transfered    </param>
		/// <param name="state">The LinphoneCallState of the call to transfer target at the
		/// far end. </param>
		public delegate void OnTransferStateChangedDelegate(Linphone.Call call, Linphone.CallState state);
		private OnTransferStateChangedDelegatePrivate on_transfer_state_changed_private;
		private OnTransferStateChangedDelegate on_transfer_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnTransferStateChangedDelegatePrivate))]
#endif
		private static void on_transfer_state_changed(IntPtr call, int state)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_transfer_state_changed_public?.Invoke(thiz, (Linphone.CallState)state);
			}
		}

		public OnTransferStateChangedDelegate OnTransferStateChanged
		{
			get
			{
				return on_transfer_state_changed_public;
			}
			set
			{
				on_transfer_state_changed_public = value;
				on_transfer_state_changed_private = on_transfer_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_transfer_state_changed_private);
				linphone_call_cbs_set_transfer_state_changed(nativePtr, cb);
#else
				linphone_call_cbs_set_transfer_state_changed(nativePtr, on_transfer_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_ack_processing(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_ack_processing(IntPtr thiz, OnAckProcessingDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAckProcessingDelegatePrivate(IntPtr call, IntPtr ack, char isReceived);

		/// <summary>
		/// Callback for notifying the processing SIP ACK messages. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call"><see cref="Linphone.Call">Linphone.Call</see> for which an
		/// ACK is being received or sent    </param>
		/// <param name="ack">the ACK <see cref="Linphone.Headers">Linphone.Headers</see>  
		///  </param>
		/// <param name="isReceived">if true this ACK is an incoming one, otherwise it is
		/// an ACK about to be sent. </param>
		public delegate void OnAckProcessingDelegate(Linphone.Call call, Linphone.Headers ack, bool isReceived);
		private OnAckProcessingDelegatePrivate on_ack_processing_private;
		private OnAckProcessingDelegate on_ack_processing_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAckProcessingDelegatePrivate))]
#endif
		private static void on_ack_processing(IntPtr call, IntPtr ack, char isReceived)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_ack_processing_public?.Invoke(thiz, fromNativePtr<Linphone.Headers>(ack), isReceived == 0);
			}
		}

		public OnAckProcessingDelegate OnAckProcessing
		{
			get
			{
				return on_ack_processing_public;
			}
			set
			{
				on_ack_processing_public = value;
				on_ack_processing_private = on_ack_processing;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ack_processing_private);
				linphone_call_cbs_set_ack_processing(nativePtr, cb);
#else
				linphone_call_cbs_set_ack_processing(nativePtr, on_ack_processing_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_tmmbr_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_tmmbr_received(IntPtr thiz, OnTmmbrReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnTmmbrReceivedDelegatePrivate(IntPtr call, int streamIndex, int tmmbr);

		/// <summary>
		/// Callback for notifying a received TMMBR. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall for which the TMMBR has changed    </param>
		/// <param name="streamIndex">the index of the current stream </param>
		/// <param name="tmmbr">the value of the received TMMBR </param>
		public delegate void OnTmmbrReceivedDelegate(Linphone.Call call, int streamIndex, int tmmbr);
		private OnTmmbrReceivedDelegatePrivate on_tmmbr_received_private;
		private OnTmmbrReceivedDelegate on_tmmbr_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnTmmbrReceivedDelegatePrivate))]
#endif
		private static void on_tmmbr_received(IntPtr call, int streamIndex, int tmmbr)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_tmmbr_received_public?.Invoke(thiz, streamIndex, tmmbr);
			}
		}

		public OnTmmbrReceivedDelegate OnTmmbrReceived
		{
			get
			{
				return on_tmmbr_received_public;
			}
			set
			{
				on_tmmbr_received_public = value;
				on_tmmbr_received_private = on_tmmbr_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_tmmbr_received_private);
				linphone_call_cbs_set_tmmbr_received(nativePtr, cb);
#else
				linphone_call_cbs_set_tmmbr_received(nativePtr, on_tmmbr_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_snapshot_taken(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_snapshot_taken(IntPtr thiz, OnSnapshotTakenDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSnapshotTakenDelegatePrivate(IntPtr call, IntPtr filePath);

		/// <summary>
		/// Callback for notifying a snapshot taken. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall for which the snapshot was taken    </param>
		/// <param name="filePath">the name of the saved file    </param>
		public delegate void OnSnapshotTakenDelegate(Linphone.Call call, string filePath);
		private OnSnapshotTakenDelegatePrivate on_snapshot_taken_private;
		private OnSnapshotTakenDelegate on_snapshot_taken_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSnapshotTakenDelegatePrivate))]
#endif
		private static void on_snapshot_taken(IntPtr call, IntPtr filePath)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_snapshot_taken_public?.Invoke(thiz, PtrToStringSafe(filePath));
			}
		}

		public OnSnapshotTakenDelegate OnSnapshotTaken
		{
			get
			{
				return on_snapshot_taken_public;
			}
			set
			{
				on_snapshot_taken_public = value;
				on_snapshot_taken_private = on_snapshot_taken;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_snapshot_taken_private);
				linphone_call_cbs_set_snapshot_taken(nativePtr, cb);
#else
				linphone_call_cbs_set_snapshot_taken(nativePtr, on_snapshot_taken_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_next_video_frame_decoded(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_next_video_frame_decoded(IntPtr thiz, OnNextVideoFrameDecodedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNextVideoFrameDecodedDelegatePrivate(IntPtr call);

		/// <summary>
		/// Callback to notify a next video frame has been decoded. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall for which the next video frame has been decoded
		///    </param>
		public delegate void OnNextVideoFrameDecodedDelegate(Linphone.Call call);
		private OnNextVideoFrameDecodedDelegatePrivate on_next_video_frame_decoded_private;
		private OnNextVideoFrameDecodedDelegate on_next_video_frame_decoded_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNextVideoFrameDecodedDelegatePrivate))]
#endif
		private static void on_next_video_frame_decoded(IntPtr call)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_next_video_frame_decoded_public?.Invoke(thiz);
			}
		}

		public OnNextVideoFrameDecodedDelegate OnNextVideoFrameDecoded
		{
			get
			{
				return on_next_video_frame_decoded_public;
			}
			set
			{
				on_next_video_frame_decoded_public = value;
				on_next_video_frame_decoded_private = on_next_video_frame_decoded;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_next_video_frame_decoded_private);
				linphone_call_cbs_set_next_video_frame_decoded(nativePtr, cb);
#else
				linphone_call_cbs_set_next_video_frame_decoded(nativePtr, on_next_video_frame_decoded_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_camera_not_working(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_camera_not_working(IntPtr thiz, OnCameraNotWorkingDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCameraNotWorkingDelegatePrivate(IntPtr call, IntPtr cameraName);

		/// <summary>
		/// Callback to notify that the camera is not working and has been changed to
		/// &quot;No Webcam&quot;. 
		/// <para>
		/// A camera is detected as mis-functionning as soon as it outputs no frames at all
		/// during a period of 5 seconds. This check is only performed on desktop
		/// platforms, in the purpose of notifying camera failures, for example if when a
		/// usb cable gets disconnected.
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall for which the next video frame has been decoded
		///    </param>
		/// <param name="cameraName">the name of the non-working camera    </param>
		public delegate void OnCameraNotWorkingDelegate(Linphone.Call call, string cameraName);
		private OnCameraNotWorkingDelegatePrivate on_camera_not_working_private;
		private OnCameraNotWorkingDelegate on_camera_not_working_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCameraNotWorkingDelegatePrivate))]
#endif
		private static void on_camera_not_working(IntPtr call, IntPtr cameraName)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_camera_not_working_public?.Invoke(thiz, PtrToStringSafe(cameraName));
			}
		}

		public OnCameraNotWorkingDelegate OnCameraNotWorking
		{
			get
			{
				return on_camera_not_working_public;
			}
			set
			{
				on_camera_not_working_public = value;
				on_camera_not_working_private = on_camera_not_working;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_camera_not_working_private);
				linphone_call_cbs_set_camera_not_working(nativePtr, cb);
#else
				linphone_call_cbs_set_camera_not_working(nativePtr, on_camera_not_working_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_video_display_error_occurred(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_video_display_error_occurred(IntPtr thiz, OnVideoDisplayErrorOccurredDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnVideoDisplayErrorOccurredDelegatePrivate(IntPtr call, int errorCode);

		/// <summary>
		/// Callback to notify that there are errors from the video rendering. 
		/// <para>
		/// The error code depends of the implementation.
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall    </param>
		/// <param name="errorCode">error code from render. It depends of the renderer.
		/// </param>
		public delegate void OnVideoDisplayErrorOccurredDelegate(Linphone.Call call, int errorCode);
		private OnVideoDisplayErrorOccurredDelegatePrivate on_video_display_error_occurred_private;
		private OnVideoDisplayErrorOccurredDelegate on_video_display_error_occurred_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnVideoDisplayErrorOccurredDelegatePrivate))]
#endif
		private static void on_video_display_error_occurred(IntPtr call, int errorCode)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_video_display_error_occurred_public?.Invoke(thiz, errorCode);
			}
		}

		public OnVideoDisplayErrorOccurredDelegate OnVideoDisplayErrorOccurred
		{
			get
			{
				return on_video_display_error_occurred_public;
			}
			set
			{
				on_video_display_error_occurred_public = value;
				on_video_display_error_occurred_private = on_video_display_error_occurred;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_video_display_error_occurred_private);
				linphone_call_cbs_set_video_display_error_occurred(nativePtr, cb);
#else
				linphone_call_cbs_set_video_display_error_occurred(nativePtr, on_video_display_error_occurred_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_audio_device_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_audio_device_changed(IntPtr thiz, OnAudioDeviceChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAudioDeviceChangedDelegatePrivate(IntPtr call, IntPtr audioDevice);

		/// <summary>
		/// Callback to notify that the audio device has been changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall for which the audio device has changed   
		/// </param>
		/// <param name="audioDevice">the new audio device used for this call    </param>
		public delegate void OnAudioDeviceChangedDelegate(Linphone.Call call, Linphone.AudioDevice audioDevice);
		private OnAudioDeviceChangedDelegatePrivate on_audio_device_changed_private;
		private OnAudioDeviceChangedDelegate on_audio_device_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAudioDeviceChangedDelegatePrivate))]
#endif
		private static void on_audio_device_changed(IntPtr call, IntPtr audioDevice)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_audio_device_changed_public?.Invoke(thiz, fromNativePtr<Linphone.AudioDevice>(audioDevice));
			}
		}

		public OnAudioDeviceChangedDelegate OnAudioDeviceChanged
		{
			get
			{
				return on_audio_device_changed_public;
			}
			set
			{
				on_audio_device_changed_public = value;
				on_audio_device_changed_private = on_audio_device_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_audio_device_changed_private);
				linphone_call_cbs_set_audio_device_changed(nativePtr, cb);
#else
				linphone_call_cbs_set_audio_device_changed(nativePtr, on_audio_device_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_call_cbs_set_remote_recording(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_call_cbs_set_remote_recording(IntPtr thiz, OnRemoteRecordingDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnRemoteRecordingDelegatePrivate(IntPtr call, char recording);

		/// <summary>
		/// Callback to notify that the call is being recorded by the remote. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">LinphoneCall for which the audio is recorded    </param>
		/// <param name="recording">true if the call is being recorded by the remote, false
		/// otherwise </param>
		public delegate void OnRemoteRecordingDelegate(Linphone.Call call, bool recording);
		private OnRemoteRecordingDelegatePrivate on_remote_recording_private;
		private OnRemoteRecordingDelegate on_remote_recording_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnRemoteRecordingDelegatePrivate))]
#endif
		private static void on_remote_recording(IntPtr call, char recording)
		{
			Call thiz = fromNativePtr<Call>(call);

			IntPtr ptr = linphone_call_get_current_callbacks(thiz.nativePtr);
			CallListener current_listener = fromNativePtr<CallListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_remote_recording_public?.Invoke(thiz, recording == 0);
			}
		}

		public OnRemoteRecordingDelegate OnRemoteRecording
		{
			get
			{
				return on_remote_recording_public;
			}
			set
			{
				on_remote_recording_public = value;
				on_remote_recording_private = on_remote_recording;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_remote_recording_private);
				linphone_call_cbs_set_remote_recording(nativePtr, cb);
#else
				linphone_call_cbs_set_remote_recording(nativePtr, on_remote_recording_private);
#endif
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for the handling a <see cref="Linphone.ChatMessage">
	/// Linphone.ChatMessage</see> objects. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ChatMessageListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_message_cbs_set_msg_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_msg_state_changed(IntPtr thiz, OnMsgStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnMsgStateChangedDelegatePrivate(IntPtr message, int state);

		/// <summary>
		/// Call back used to notify message delivery status. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message"><see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> object    </param>
		/// <param name="state"><see cref="Linphone.ChatMessageState">
		/// Linphone.ChatMessageState</see> </param>
		public delegate void OnMsgStateChangedDelegate(Linphone.ChatMessage message, Linphone.ChatMessageState state);
		private OnMsgStateChangedDelegatePrivate on_msg_state_changed_private;
		private OnMsgStateChangedDelegate on_msg_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnMsgStateChangedDelegatePrivate))]
#endif
		private static void on_msg_state_changed(IntPtr message, int state)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);

			IntPtr ptr = linphone_chat_message_get_current_callbacks(thiz.nativePtr);
			ChatMessageListener current_listener = fromNativePtr<ChatMessageListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_msg_state_changed_public?.Invoke(thiz, (Linphone.ChatMessageState)state);
			}
		}

		public OnMsgStateChangedDelegate OnMsgStateChanged
		{
			get
			{
				return on_msg_state_changed_public;
			}
			set
			{
				on_msg_state_changed_public = value;
				on_msg_state_changed_private = on_msg_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_msg_state_changed_private);
				linphone_chat_message_cbs_set_msg_state_changed(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_msg_state_changed(nativePtr, on_msg_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_message_cbs_set_new_message_reaction(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_new_message_reaction(IntPtr thiz, OnNewMessageReactionDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNewMessageReactionDelegatePrivate(IntPtr message, IntPtr reaction);

		/// <summary>
		/// Callback used to notify a reaction has been received or sent for a given
		/// message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">LinphoneChatMessage object    </param>
		/// <param name="reaction">the LinphoneChatMessageReaction reaction that was sent
		/// or received    </param>
		public delegate void OnNewMessageReactionDelegate(Linphone.ChatMessage message, Linphone.ChatMessageReaction reaction);
		private OnNewMessageReactionDelegatePrivate on_new_message_reaction_private;
		private OnNewMessageReactionDelegate on_new_message_reaction_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNewMessageReactionDelegatePrivate))]
#endif
		private static void on_new_message_reaction(IntPtr message, IntPtr reaction)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);

			IntPtr ptr = linphone_chat_message_get_current_callbacks(thiz.nativePtr);
			ChatMessageListener current_listener = fromNativePtr<ChatMessageListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_new_message_reaction_public?.Invoke(thiz, fromNativePtr<Linphone.ChatMessageReaction>(reaction));
			}
		}

		public OnNewMessageReactionDelegate OnNewMessageReaction
		{
			get
			{
				return on_new_message_reaction_public;
			}
			set
			{
				on_new_message_reaction_public = value;
				on_new_message_reaction_private = on_new_message_reaction;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_new_message_reaction_private);
				linphone_chat_message_cbs_set_new_message_reaction(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_new_message_reaction(nativePtr, on_new_message_reaction_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_message_cbs_set_reaction_removed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_reaction_removed(IntPtr thiz, OnReactionRemovedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnReactionRemovedDelegatePrivate(IntPtr message, IntPtr address);

		/// <summary>
		/// Callback used to notify a reaction has been removed from a given message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">LinphoneChatMessage object    </param>
		/// <param name="address">the LinphoneAddress of the person that removed it&apos;s
		/// reaction    </param>
		public delegate void OnReactionRemovedDelegate(Linphone.ChatMessage message, Linphone.Address address);
		private OnReactionRemovedDelegatePrivate on_reaction_removed_private;
		private OnReactionRemovedDelegate on_reaction_removed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnReactionRemovedDelegatePrivate))]
#endif
		private static void on_reaction_removed(IntPtr message, IntPtr address)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);

			IntPtr ptr = linphone_chat_message_get_current_callbacks(thiz.nativePtr);
			ChatMessageListener current_listener = fromNativePtr<ChatMessageListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_reaction_removed_public?.Invoke(thiz, fromNativePtr<Linphone.Address>(address));
			}
		}

		public OnReactionRemovedDelegate OnReactionRemoved
		{
			get
			{
				return on_reaction_removed_public;
			}
			set
			{
				on_reaction_removed_public = value;
				on_reaction_removed_private = on_reaction_removed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_reaction_removed_private);
				linphone_chat_message_cbs_set_reaction_removed(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_reaction_removed(nativePtr, on_reaction_removed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_message_cbs_set_file_transfer_recv(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_file_transfer_recv(IntPtr thiz, OnFileTransferRecvDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFileTransferRecvDelegatePrivate(IntPtr message, IntPtr content, IntPtr buffer);

		/// <summary>
		/// File transfer receive callback prototype. 
		/// <para>
		/// This function is called by the core upon an incoming File transfer is started.
		/// This function may be call several time for the same file in case of large file. 
		/// </para>
		/// </summary>
		/// <param name="message"><see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> message from which the body is received.    </param>
		/// <param name="content"><see cref="Linphone.Content">Linphone.Content</see>
		/// incoming content information    </param>
		/// <param name="buffer"><see cref="Linphone.Buffer">Linphone.Buffer</see> holding
		/// the received data. Empty buffer means end of file.    </param>
		public delegate void OnFileTransferRecvDelegate(Linphone.ChatMessage message, Linphone.Content content, Linphone.Buffer buffer);
		private OnFileTransferRecvDelegatePrivate on_file_transfer_recv_private;
		private OnFileTransferRecvDelegate on_file_transfer_recv_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFileTransferRecvDelegatePrivate))]
#endif
		private static void on_file_transfer_recv(IntPtr message, IntPtr content, IntPtr buffer)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);

			IntPtr ptr = linphone_chat_message_get_current_callbacks(thiz.nativePtr);
			ChatMessageListener current_listener = fromNativePtr<ChatMessageListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_file_transfer_recv_public?.Invoke(thiz, fromNativePtr<Linphone.Content>(content), fromNativePtr<Linphone.Buffer>(buffer));
			}
		}

		public OnFileTransferRecvDelegate OnFileTransferRecv
		{
			get
			{
				return on_file_transfer_recv_public;
			}
			set
			{
				on_file_transfer_recv_public = value;
				on_file_transfer_recv_private = on_file_transfer_recv;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_file_transfer_recv_private);
				linphone_chat_message_cbs_set_file_transfer_recv(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_file_transfer_recv(nativePtr, on_file_transfer_recv_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_message_cbs_set_file_transfer_send(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_file_transfer_send(IntPtr thiz, OnFileTransferSendDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFileTransferSendDelegatePrivate(IntPtr message, IntPtr content, long offset, long size);

		/// <summary>
		/// File transfer send callback prototype. 
		/// <para>
		/// This function is called by the core when an outgoing file transfer is started.
		/// This function is called until size is set to 0. 
		/// </para>
		/// </summary>
		/// <param name="message"><see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> message from which the body is received.    </param>
		/// <param name="content"><see cref="Linphone.Content">Linphone.Content</see>
		/// outgoing content    </param>
		/// <param name="offset">the offset in the file from where to get the data to be
		/// sent </param>
		/// <param name="size">the number of bytes expected by the framework </param>
		/// <returns>A <see cref="Linphone.Buffer">Linphone.Buffer</see> object holding the
		/// data written by the application. An empty buffer means end of file.   
		/// </returns>
		/// <remarks>Warning : The returned value isn&apos;t used, hence the deprecation!
		/// </remarks> 
		/// deprecated : 17/08/2020 Use LinphoneChatMessageCbsFileTransferSendChunkCb
		/// instead. 
		public delegate void OnFileTransferSendDelegate(Linphone.ChatMessage message, Linphone.Content content, long offset, long size);
		private OnFileTransferSendDelegatePrivate on_file_transfer_send_private;
		private OnFileTransferSendDelegate on_file_transfer_send_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFileTransferSendDelegatePrivate))]
#endif
		private static void on_file_transfer_send(IntPtr message, IntPtr content, long offset, long size)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);

			IntPtr ptr = linphone_chat_message_get_current_callbacks(thiz.nativePtr);
			ChatMessageListener current_listener = fromNativePtr<ChatMessageListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_file_transfer_send_public?.Invoke(thiz, fromNativePtr<Linphone.Content>(content), offset, size);
			}
		}

		public OnFileTransferSendDelegate OnFileTransferSend
		{
			get
			{
				return on_file_transfer_send_public;
			}
			set
			{
				on_file_transfer_send_public = value;
				on_file_transfer_send_private = on_file_transfer_send;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_file_transfer_send_private);
				linphone_chat_message_cbs_set_file_transfer_send(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_file_transfer_send(nativePtr, on_file_transfer_send_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_message_cbs_set_file_transfer_send_chunk(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_file_transfer_send_chunk(IntPtr thiz, OnFileTransferSendChunkDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFileTransferSendChunkDelegatePrivate(IntPtr message, IntPtr content, long offset, long size, IntPtr buffer);

		/// <summary>
		/// File transfer send callback prototype. 
		/// <para>
		/// This function is called by the core when an outgoing file transfer is started.
		/// This function is called until size is set to 0. 
		/// </para>
		/// </summary>
		/// <param name="message"><see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> message from which the body is received.    </param>
		/// <param name="content"><see cref="Linphone.Content">Linphone.Content</see>
		/// outgoing content    </param>
		/// <param name="offset">the offset in the file from where to get the data to be
		/// sent </param>
		/// <param name="size">the number of bytes expected by the framework </param>
		/// <param name="buffer">A <see cref="Linphone.Buffer">Linphone.Buffer</see> to be
		/// filled. Leave it empty when end of file has been reached.    </param>
		public delegate void OnFileTransferSendChunkDelegate(Linphone.ChatMessage message, Linphone.Content content, long offset, long size, Linphone.Buffer buffer);
		private OnFileTransferSendChunkDelegatePrivate on_file_transfer_send_chunk_private;
		private OnFileTransferSendChunkDelegate on_file_transfer_send_chunk_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFileTransferSendChunkDelegatePrivate))]
#endif
		private static void on_file_transfer_send_chunk(IntPtr message, IntPtr content, long offset, long size, IntPtr buffer)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);

			IntPtr ptr = linphone_chat_message_get_current_callbacks(thiz.nativePtr);
			ChatMessageListener current_listener = fromNativePtr<ChatMessageListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_file_transfer_send_chunk_public?.Invoke(thiz, fromNativePtr<Linphone.Content>(content), offset, size, fromNativePtr<Linphone.Buffer>(buffer));
			}
		}

		public OnFileTransferSendChunkDelegate OnFileTransferSendChunk
		{
			get
			{
				return on_file_transfer_send_chunk_public;
			}
			set
			{
				on_file_transfer_send_chunk_public = value;
				on_file_transfer_send_chunk_private = on_file_transfer_send_chunk;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_file_transfer_send_chunk_private);
				linphone_chat_message_cbs_set_file_transfer_send_chunk(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_file_transfer_send_chunk(nativePtr, on_file_transfer_send_chunk_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_message_cbs_set_file_transfer_progress_indication(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_file_transfer_progress_indication(IntPtr thiz, OnFileTransferProgressIndicationDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFileTransferProgressIndicationDelegatePrivate(IntPtr message, IntPtr content, long offset, long total);

		/// <summary>
		/// File transfer progress indication callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message"><see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> message from which the body is received.    </param>
		/// <param name="content"><see cref="Linphone.Content">Linphone.Content</see>
		/// incoming content information    </param>
		/// <param name="offset">The number of bytes sent/received since the beginning of
		/// the transfer. </param>
		/// <param name="total">The total number of bytes to be sent/received. </param>
		public delegate void OnFileTransferProgressIndicationDelegate(Linphone.ChatMessage message, Linphone.Content content, long offset, long total);
		private OnFileTransferProgressIndicationDelegatePrivate on_file_transfer_progress_indication_private;
		private OnFileTransferProgressIndicationDelegate on_file_transfer_progress_indication_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFileTransferProgressIndicationDelegatePrivate))]
#endif
		private static void on_file_transfer_progress_indication(IntPtr message, IntPtr content, long offset, long total)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);

			IntPtr ptr = linphone_chat_message_get_current_callbacks(thiz.nativePtr);
			ChatMessageListener current_listener = fromNativePtr<ChatMessageListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_file_transfer_progress_indication_public?.Invoke(thiz, fromNativePtr<Linphone.Content>(content), offset, total);
			}
		}

		public OnFileTransferProgressIndicationDelegate OnFileTransferProgressIndication
		{
			get
			{
				return on_file_transfer_progress_indication_public;
			}
			set
			{
				on_file_transfer_progress_indication_public = value;
				on_file_transfer_progress_indication_private = on_file_transfer_progress_indication;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_file_transfer_progress_indication_private);
				linphone_chat_message_cbs_set_file_transfer_progress_indication(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_file_transfer_progress_indication(nativePtr, on_file_transfer_progress_indication_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_message_cbs_set_participant_imdn_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_participant_imdn_state_changed(IntPtr thiz, OnParticipantImdnStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantImdnStateChangedDelegatePrivate(IntPtr message, IntPtr state);

		/// <summary>
		/// Call back used to notify participant IMDN state. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message"><see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> object    </param>
		/// <param name="state"><see cref="Linphone.ParticipantImdnState">
		/// Linphone.ParticipantImdnState</see>    </param>
		public delegate void OnParticipantImdnStateChangedDelegate(Linphone.ChatMessage message, Linphone.ParticipantImdnState state);
		private OnParticipantImdnStateChangedDelegatePrivate on_participant_imdn_state_changed_private;
		private OnParticipantImdnStateChangedDelegate on_participant_imdn_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantImdnStateChangedDelegatePrivate))]
#endif
		private static void on_participant_imdn_state_changed(IntPtr message, IntPtr state)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);

			IntPtr ptr = linphone_chat_message_get_current_callbacks(thiz.nativePtr);
			ChatMessageListener current_listener = fromNativePtr<ChatMessageListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_imdn_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ParticipantImdnState>(state));
			}
		}

		public OnParticipantImdnStateChangedDelegate OnParticipantImdnStateChanged
		{
			get
			{
				return on_participant_imdn_state_changed_public;
			}
			set
			{
				on_participant_imdn_state_changed_public = value;
				on_participant_imdn_state_changed_private = on_participant_imdn_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_imdn_state_changed_private);
				linphone_chat_message_cbs_set_participant_imdn_state_changed(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_participant_imdn_state_changed(nativePtr, on_participant_imdn_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_message_cbs_set_ephemeral_message_timer_started(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_ephemeral_message_timer_started(IntPtr thiz, OnEphemeralMessageTimerStartedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEphemeralMessageTimerStartedDelegatePrivate(IntPtr message);

		/// <summary>
		/// Callback used to notify an ephemeral message that its lifespan before
		/// disappearing has started to decrease. 
		/// <para>
		/// This callback is called when the ephemeral message is read by the receiver. 
		/// </para>
		/// </summary>
		/// <param name="message">LinphoneChatMessage object    </param>
		public delegate void OnEphemeralMessageTimerStartedDelegate(Linphone.ChatMessage message);
		private OnEphemeralMessageTimerStartedDelegatePrivate on_ephemeral_message_timer_started_private;
		private OnEphemeralMessageTimerStartedDelegate on_ephemeral_message_timer_started_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEphemeralMessageTimerStartedDelegatePrivate))]
#endif
		private static void on_ephemeral_message_timer_started(IntPtr message)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);

			IntPtr ptr = linphone_chat_message_get_current_callbacks(thiz.nativePtr);
			ChatMessageListener current_listener = fromNativePtr<ChatMessageListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_ephemeral_message_timer_started_public?.Invoke(thiz);
			}
		}

		public OnEphemeralMessageTimerStartedDelegate OnEphemeralMessageTimerStarted
		{
			get
			{
				return on_ephemeral_message_timer_started_public;
			}
			set
			{
				on_ephemeral_message_timer_started_public = value;
				on_ephemeral_message_timer_started_private = on_ephemeral_message_timer_started;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ephemeral_message_timer_started_private);
				linphone_chat_message_cbs_set_ephemeral_message_timer_started(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_ephemeral_message_timer_started(nativePtr, on_ephemeral_message_timer_started_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_message_cbs_set_ephemeral_message_deleted(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_message_cbs_set_ephemeral_message_deleted(IntPtr thiz, OnEphemeralMessageDeletedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEphemeralMessageDeletedDelegatePrivate(IntPtr message);

		/// <summary>
		/// Call back used to notify ephemeral message is deleted. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">LinphoneChatMessage object    </param>
		public delegate void OnEphemeralMessageDeletedDelegate(Linphone.ChatMessage message);
		private OnEphemeralMessageDeletedDelegatePrivate on_ephemeral_message_deleted_private;
		private OnEphemeralMessageDeletedDelegate on_ephemeral_message_deleted_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEphemeralMessageDeletedDelegatePrivate))]
#endif
		private static void on_ephemeral_message_deleted(IntPtr message)
		{
			ChatMessage thiz = fromNativePtr<ChatMessage>(message);

			IntPtr ptr = linphone_chat_message_get_current_callbacks(thiz.nativePtr);
			ChatMessageListener current_listener = fromNativePtr<ChatMessageListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_ephemeral_message_deleted_public?.Invoke(thiz);
			}
		}

		public OnEphemeralMessageDeletedDelegate OnEphemeralMessageDeleted
		{
			get
			{
				return on_ephemeral_message_deleted_public;
			}
			set
			{
				on_ephemeral_message_deleted_public = value;
				on_ephemeral_message_deleted_private = on_ephemeral_message_deleted;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ephemeral_message_deleted_private);
				linphone_chat_message_cbs_set_ephemeral_message_deleted(nativePtr, cb);
#else
				linphone_chat_message_cbs_set_ephemeral_message_deleted(nativePtr, on_ephemeral_message_deleted_private);
#endif
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for the handling a <see cref="Linphone.ChatRoom">
	/// Linphone.ChatRoom</see> objects. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ChatRoomListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_is_composing_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_is_composing_received(IntPtr thiz, OnIsComposingReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsComposingReceivedDelegatePrivate(IntPtr chatRoom, IntPtr remoteAddress, char isComposing);

		/// <summary>
		/// Is composing notification callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom involved in the conversation    </param>
		/// <param name="remoteAddress">The LinphoneAddress that has sent the is-composing
		/// notification    </param>
		/// <param name="isComposing">A boolean value telling whether the remote is
		/// composing or not </param>
		public delegate void OnIsComposingReceivedDelegate(Linphone.ChatRoom chatRoom, Linphone.Address remoteAddress, bool isComposing);
		private OnIsComposingReceivedDelegatePrivate on_is_composing_received_private;
		private OnIsComposingReceivedDelegate on_is_composing_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsComposingReceivedDelegatePrivate))]
#endif
		private static void on_is_composing_received(IntPtr chatRoom, IntPtr remoteAddress, char isComposing)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_is_composing_received_public?.Invoke(thiz, fromNativePtr<Linphone.Address>(remoteAddress), isComposing == 0);
			}
		}

		public OnIsComposingReceivedDelegate OnIsComposingReceived
		{
			get
			{
				return on_is_composing_received_public;
			}
			set
			{
				on_is_composing_received_public = value;
				on_is_composing_received_private = on_is_composing_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_composing_received_private);
				linphone_chat_room_cbs_set_is_composing_received(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_is_composing_received(nativePtr, on_is_composing_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_message_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_message_received(IntPtr thiz, OnMessageReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnMessageReceivedDelegatePrivate(IntPtr chatRoom, IntPtr message);

		/// <summary>
		/// Callback used to notify a chat room that a message has been received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object    </param>
		/// <param name="message">The LinphoneChatMessage that has been received    </param>
		public delegate void OnMessageReceivedDelegate(Linphone.ChatRoom chatRoom, Linphone.ChatMessage message);
		private OnMessageReceivedDelegatePrivate on_message_received_private;
		private OnMessageReceivedDelegate on_message_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnMessageReceivedDelegatePrivate))]
#endif
		private static void on_message_received(IntPtr chatRoom, IntPtr message)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_message_received_public?.Invoke(thiz, fromNativePtr<Linphone.ChatMessage>(message));
			}
		}

		public OnMessageReceivedDelegate OnMessageReceived
		{
			get
			{
				return on_message_received_public;
			}
			set
			{
				on_message_received_public = value;
				on_message_received_private = on_message_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_message_received_private);
				linphone_chat_room_cbs_set_message_received(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_message_received(nativePtr, on_message_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_messages_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_messages_received(IntPtr thiz, OnMessagesReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnMessagesReceivedDelegatePrivate(IntPtr chatRoom, IntPtr chatMessages);

		/// <summary>
		/// Callback used to notify a chat room that many chat messages have been received. 
		/// <para>
		/// Only called when aggregation is enabled (aka [sip] chat_messages_aggregation ==
		/// 1 or using linphone_core_set_chat_messages_aggregation_enabled), it replaces
		/// the single message received callback. 
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object    </param>
		/// <param name="chatMessages">The   list of events to be notified    </param>
		public delegate void OnMessagesReceivedDelegate(Linphone.ChatRoom chatRoom, IEnumerable<Linphone.ChatMessage> chatMessages);
		private OnMessagesReceivedDelegatePrivate on_messages_received_private;
		private OnMessagesReceivedDelegate on_messages_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnMessagesReceivedDelegatePrivate))]
#endif
		private static void on_messages_received(IntPtr chatRoom, IntPtr chatMessages)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_messages_received_public?.Invoke(thiz, MarshalBctbxList<Linphone.ChatMessage>(chatMessages));
			}
		}

		public OnMessagesReceivedDelegate OnMessagesReceived
		{
			get
			{
				return on_messages_received_public;
			}
			set
			{
				on_messages_received_public = value;
				on_messages_received_private = on_messages_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_messages_received_private);
				linphone_chat_room_cbs_set_messages_received(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_messages_received(nativePtr, on_messages_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_new_event(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_new_event(IntPtr thiz, OnNewEventDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNewEventDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that an event log has been created. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnNewEventDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnNewEventDelegatePrivate on_new_event_private;
		private OnNewEventDelegate on_new_event_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNewEventDelegatePrivate))]
#endif
		private static void on_new_event(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_new_event_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnNewEventDelegate OnNewEvent
		{
			get
			{
				return on_new_event_public;
			}
			set
			{
				on_new_event_public = value;
				on_new_event_private = on_new_event;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_new_event_private);
				linphone_chat_room_cbs_set_new_event(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_new_event(nativePtr, on_new_event_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_new_events(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_new_events(IntPtr thiz, OnNewEventsDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNewEventsDelegatePrivate(IntPtr chatRoom, IntPtr eventLogs);

		/// <summary>
		/// Callback used to notify a chat room that many event logs have been created. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLogs">The   list of events to be notified    </param>
		public delegate void OnNewEventsDelegate(Linphone.ChatRoom chatRoom, IEnumerable<Linphone.EventLog> eventLogs);
		private OnNewEventsDelegatePrivate on_new_events_private;
		private OnNewEventsDelegate on_new_events_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNewEventsDelegatePrivate))]
#endif
		private static void on_new_events(IntPtr chatRoom, IntPtr eventLogs)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_new_events_public?.Invoke(thiz, MarshalBctbxList<Linphone.EventLog>(eventLogs));
			}
		}

		public OnNewEventsDelegate OnNewEvents
		{
			get
			{
				return on_new_events_public;
			}
			set
			{
				on_new_events_public = value;
				on_new_events_private = on_new_events;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_new_events_private);
				linphone_chat_room_cbs_set_new_events(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_new_events(nativePtr, on_new_events_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_chat_message_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_chat_message_received(IntPtr thiz, OnChatMessageReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatMessageReceivedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that a chat message has been received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnChatMessageReceivedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnChatMessageReceivedDelegatePrivate on_chat_message_received_private;
		private OnChatMessageReceivedDelegate on_chat_message_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatMessageReceivedDelegatePrivate))]
#endif
		private static void on_chat_message_received(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_chat_message_received_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnChatMessageReceivedDelegate OnChatMessageReceived
		{
			get
			{
				return on_chat_message_received_public;
			}
			set
			{
				on_chat_message_received_public = value;
				on_chat_message_received_private = on_chat_message_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_message_received_private);
				linphone_chat_room_cbs_set_chat_message_received(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_chat_message_received(nativePtr, on_chat_message_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_chat_messages_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_chat_messages_received(IntPtr thiz, OnChatMessagesReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatMessagesReceivedDelegatePrivate(IntPtr chatRoom, IntPtr eventLogs);

		/// <summary>
		/// Callback used to notify a chat room that one or many chat messages have been
		/// received. 
		/// <para>
		/// Only called when aggregation is enabled (aka [sip] chat_messages_aggregation ==
		/// 1 or using <see cref="Linphone.Core.ChatMessagesAggregationEnabled">
		/// Linphone.Core.ChatMessagesAggregationEnabled</see>), it replaces the single
		/// chat message received callback. 
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLogs">The   list of events to be notified    </param>
		public delegate void OnChatMessagesReceivedDelegate(Linphone.ChatRoom chatRoom, IEnumerable<Linphone.EventLog> eventLogs);
		private OnChatMessagesReceivedDelegatePrivate on_chat_messages_received_private;
		private OnChatMessagesReceivedDelegate on_chat_messages_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatMessagesReceivedDelegatePrivate))]
#endif
		private static void on_chat_messages_received(IntPtr chatRoom, IntPtr eventLogs)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_chat_messages_received_public?.Invoke(thiz, MarshalBctbxList<Linphone.EventLog>(eventLogs));
			}
		}

		public OnChatMessagesReceivedDelegate OnChatMessagesReceived
		{
			get
			{
				return on_chat_messages_received_public;
			}
			set
			{
				on_chat_messages_received_public = value;
				on_chat_messages_received_private = on_chat_messages_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_messages_received_private);
				linphone_chat_room_cbs_set_chat_messages_received(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_chat_messages_received(nativePtr, on_chat_messages_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_chat_message_sending(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_chat_message_sending(IntPtr thiz, OnChatMessageSendingDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatMessageSendingDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that a chat message is being sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnChatMessageSendingDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnChatMessageSendingDelegatePrivate on_chat_message_sending_private;
		private OnChatMessageSendingDelegate on_chat_message_sending_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatMessageSendingDelegatePrivate))]
#endif
		private static void on_chat_message_sending(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_chat_message_sending_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnChatMessageSendingDelegate OnChatMessageSending
		{
			get
			{
				return on_chat_message_sending_public;
			}
			set
			{
				on_chat_message_sending_public = value;
				on_chat_message_sending_private = on_chat_message_sending;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_message_sending_private);
				linphone_chat_room_cbs_set_chat_message_sending(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_chat_message_sending(nativePtr, on_chat_message_sending_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_chat_message_sent(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_chat_message_sent(IntPtr thiz, OnChatMessageSentDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatMessageSentDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that a chat message has been sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnChatMessageSentDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnChatMessageSentDelegatePrivate on_chat_message_sent_private;
		private OnChatMessageSentDelegate on_chat_message_sent_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatMessageSentDelegatePrivate))]
#endif
		private static void on_chat_message_sent(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_chat_message_sent_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnChatMessageSentDelegate OnChatMessageSent
		{
			get
			{
				return on_chat_message_sent_public;
			}
			set
			{
				on_chat_message_sent_public = value;
				on_chat_message_sent_private = on_chat_message_sent;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_message_sent_private);
				linphone_chat_room_cbs_set_chat_message_sent(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_chat_message_sent(nativePtr, on_chat_message_sent_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_participant_added(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_added(IntPtr thiz, OnParticipantAddedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantAddedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that a participant has been added. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnParticipantAddedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnParticipantAddedDelegatePrivate on_participant_added_private;
		private OnParticipantAddedDelegate on_participant_added_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantAddedDelegatePrivate))]
#endif
		private static void on_participant_added(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_added_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnParticipantAddedDelegate OnParticipantAdded
		{
			get
			{
				return on_participant_added_public;
			}
			set
			{
				on_participant_added_public = value;
				on_participant_added_private = on_participant_added;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_added_private);
				linphone_chat_room_cbs_set_participant_added(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_added(nativePtr, on_participant_added_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_participant_removed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_removed(IntPtr thiz, OnParticipantRemovedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantRemovedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that a participant has been removed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnParticipantRemovedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnParticipantRemovedDelegatePrivate on_participant_removed_private;
		private OnParticipantRemovedDelegate on_participant_removed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantRemovedDelegatePrivate))]
#endif
		private static void on_participant_removed(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_removed_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnParticipantRemovedDelegate OnParticipantRemoved
		{
			get
			{
				return on_participant_removed_public;
			}
			set
			{
				on_participant_removed_public = value;
				on_participant_removed_private = on_participant_removed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_removed_private);
				linphone_chat_room_cbs_set_participant_removed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_removed(nativePtr, on_participant_removed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_participant_admin_status_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_admin_status_changed(IntPtr thiz, OnParticipantAdminStatusChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantAdminStatusChangedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that the admin status of a participant has
		/// been changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnParticipantAdminStatusChangedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnParticipantAdminStatusChangedDelegatePrivate on_participant_admin_status_changed_private;
		private OnParticipantAdminStatusChangedDelegate on_participant_admin_status_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantAdminStatusChangedDelegatePrivate))]
#endif
		private static void on_participant_admin_status_changed(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_admin_status_changed_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnParticipantAdminStatusChangedDelegate OnParticipantAdminStatusChanged
		{
			get
			{
				return on_participant_admin_status_changed_public;
			}
			set
			{
				on_participant_admin_status_changed_public = value;
				on_participant_admin_status_changed_private = on_participant_admin_status_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_admin_status_changed_private);
				linphone_chat_room_cbs_set_participant_admin_status_changed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_admin_status_changed(nativePtr, on_participant_admin_status_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_state_changed(IntPtr thiz, OnStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnStateChangedDelegatePrivate(IntPtr chatRoom, int newState);

		/// <summary>
		/// Callback used to notify a chat room state has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">LinphoneChatRoom object    </param>
		/// <param name="newState">The new LinphoneChatRoomState of the chat room </param>
		public delegate void OnStateChangedDelegate(Linphone.ChatRoom chatRoom, Linphone.ChatRoomState newState);
		private OnStateChangedDelegatePrivate on_state_changed_private;
		private OnStateChangedDelegate on_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnStateChangedDelegatePrivate))]
#endif
		private static void on_state_changed(IntPtr chatRoom, int newState)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_state_changed_public?.Invoke(thiz, (Linphone.ChatRoomState)newState);
			}
		}

		public OnStateChangedDelegate OnStateChanged
		{
			get
			{
				return on_state_changed_public;
			}
			set
			{
				on_state_changed_public = value;
				on_state_changed_private = on_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_state_changed_private);
				linphone_chat_room_cbs_set_state_changed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_state_changed(nativePtr, on_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_security_event(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_security_event(IntPtr thiz, OnSecurityEventDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSecurityEventDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a security event in the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnSecurityEventDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnSecurityEventDelegatePrivate on_security_event_private;
		private OnSecurityEventDelegate on_security_event_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSecurityEventDelegatePrivate))]
#endif
		private static void on_security_event(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_security_event_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnSecurityEventDelegate OnSecurityEvent
		{
			get
			{
				return on_security_event_public;
			}
			set
			{
				on_security_event_public = value;
				on_security_event_private = on_security_event;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_security_event_private);
				linphone_chat_room_cbs_set_security_event(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_security_event(nativePtr, on_security_event_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_subject_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_subject_changed(IntPtr thiz, OnSubjectChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSubjectChangedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify that the subject of a chat room has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnSubjectChangedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnSubjectChangedDelegatePrivate on_subject_changed_private;
		private OnSubjectChangedDelegate on_subject_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSubjectChangedDelegatePrivate))]
#endif
		private static void on_subject_changed(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_subject_changed_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnSubjectChangedDelegate OnSubjectChanged
		{
			get
			{
				return on_subject_changed_public;
			}
			set
			{
				on_subject_changed_public = value;
				on_subject_changed_private = on_subject_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_subject_changed_private);
				linphone_chat_room_cbs_set_subject_changed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_subject_changed(nativePtr, on_subject_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_undecryptable_message_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_undecryptable_message_received(IntPtr thiz, OnUndecryptableMessageReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnUndecryptableMessageReceivedDelegatePrivate(IntPtr chatRoom, IntPtr message);

		/// <summary>
		/// Callback used to notify a chat room that a message has been received but we
		/// were unable to decrypt it. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// involved in this conversation    </param>
		/// <param name="message">The <see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> that has been received    </param>
		public delegate void OnUndecryptableMessageReceivedDelegate(Linphone.ChatRoom chatRoom, Linphone.ChatMessage message);
		private OnUndecryptableMessageReceivedDelegatePrivate on_undecryptable_message_received_private;
		private OnUndecryptableMessageReceivedDelegate on_undecryptable_message_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnUndecryptableMessageReceivedDelegatePrivate))]
#endif
		private static void on_undecryptable_message_received(IntPtr chatRoom, IntPtr message)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_undecryptable_message_received_public?.Invoke(thiz, fromNativePtr<Linphone.ChatMessage>(message));
			}
		}

		public OnUndecryptableMessageReceivedDelegate OnUndecryptableMessageReceived
		{
			get
			{
				return on_undecryptable_message_received_public;
			}
			set
			{
				on_undecryptable_message_received_public = value;
				on_undecryptable_message_received_private = on_undecryptable_message_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_undecryptable_message_received_private);
				linphone_chat_room_cbs_set_undecryptable_message_received(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_undecryptable_message_received(nativePtr, on_undecryptable_message_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_participant_device_added(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_device_added(IntPtr thiz, OnParticipantDeviceAddedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceAddedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that a participant has been added. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnParticipantDeviceAddedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnParticipantDeviceAddedDelegatePrivate on_participant_device_added_private;
		private OnParticipantDeviceAddedDelegate on_participant_device_added_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceAddedDelegatePrivate))]
#endif
		private static void on_participant_device_added(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_device_added_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnParticipantDeviceAddedDelegate OnParticipantDeviceAdded
		{
			get
			{
				return on_participant_device_added_public;
			}
			set
			{
				on_participant_device_added_public = value;
				on_participant_device_added_private = on_participant_device_added;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_added_private);
				linphone_chat_room_cbs_set_participant_device_added(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_device_added(nativePtr, on_participant_device_added_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_participant_device_removed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_device_removed(IntPtr thiz, OnParticipantDeviceRemovedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceRemovedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that a participant has been removed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnParticipantDeviceRemovedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnParticipantDeviceRemovedDelegatePrivate on_participant_device_removed_private;
		private OnParticipantDeviceRemovedDelegate on_participant_device_removed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceRemovedDelegatePrivate))]
#endif
		private static void on_participant_device_removed(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_device_removed_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnParticipantDeviceRemovedDelegate OnParticipantDeviceRemoved
		{
			get
			{
				return on_participant_device_removed_public;
			}
			set
			{
				on_participant_device_removed_public = value;
				on_participant_device_removed_private = on_participant_device_removed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_removed_private);
				linphone_chat_room_cbs_set_participant_device_removed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_device_removed(nativePtr, on_participant_device_removed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_participant_device_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_device_state_changed(IntPtr thiz, OnParticipantDeviceStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceStateChangedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog, int state);

		/// <summary>
		/// Callback used to notify a conference that a participant device has changed
		/// state. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		/// <param name="state">new participant device state </param>
		public delegate void OnParticipantDeviceStateChangedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog, Linphone.ParticipantDeviceState state);
		private OnParticipantDeviceStateChangedDelegatePrivate on_participant_device_state_changed_private;
		private OnParticipantDeviceStateChangedDelegate on_participant_device_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceStateChangedDelegatePrivate))]
#endif
		private static void on_participant_device_state_changed(IntPtr chatRoom, IntPtr eventLog, int state)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_device_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog), (Linphone.ParticipantDeviceState)state);
			}
		}

		public OnParticipantDeviceStateChangedDelegate OnParticipantDeviceStateChanged
		{
			get
			{
				return on_participant_device_state_changed_public;
			}
			set
			{
				on_participant_device_state_changed_public = value;
				on_participant_device_state_changed_private = on_participant_device_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_state_changed_private);
				linphone_chat_room_cbs_set_participant_device_state_changed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_device_state_changed(nativePtr, on_participant_device_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_participant_device_media_availability_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_device_media_availability_changed(IntPtr thiz, OnParticipantDeviceMediaAvailabilityChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceMediaAvailabilityChangedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a conference that the media availability of a
		/// participant device has been changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnParticipantDeviceMediaAvailabilityChangedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnParticipantDeviceMediaAvailabilityChangedDelegatePrivate on_participant_device_media_availability_changed_private;
		private OnParticipantDeviceMediaAvailabilityChangedDelegate on_participant_device_media_availability_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceMediaAvailabilityChangedDelegatePrivate))]
#endif
		private static void on_participant_device_media_availability_changed(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_device_media_availability_changed_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnParticipantDeviceMediaAvailabilityChangedDelegate OnParticipantDeviceMediaAvailabilityChanged
		{
			get
			{
				return on_participant_device_media_availability_changed_public;
			}
			set
			{
				on_participant_device_media_availability_changed_public = value;
				on_participant_device_media_availability_changed_private = on_participant_device_media_availability_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_media_availability_changed_private);
				linphone_chat_room_cbs_set_participant_device_media_availability_changed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_device_media_availability_changed(nativePtr, on_participant_device_media_availability_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_conference_joined(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_conference_joined(IntPtr thiz, OnConferenceJoinedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnConferenceJoinedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room has been joined. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnConferenceJoinedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnConferenceJoinedDelegatePrivate on_conference_joined_private;
		private OnConferenceJoinedDelegate on_conference_joined_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnConferenceJoinedDelegatePrivate))]
#endif
		private static void on_conference_joined(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_conference_joined_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnConferenceJoinedDelegate OnConferenceJoined
		{
			get
			{
				return on_conference_joined_public;
			}
			set
			{
				on_conference_joined_public = value;
				on_conference_joined_private = on_conference_joined;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_conference_joined_private);
				linphone_chat_room_cbs_set_conference_joined(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_conference_joined(nativePtr, on_conference_joined_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_conference_left(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_conference_left(IntPtr thiz, OnConferenceLeftDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnConferenceLeftDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room has been left. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnConferenceLeftDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnConferenceLeftDelegatePrivate on_conference_left_private;
		private OnConferenceLeftDelegate on_conference_left_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnConferenceLeftDelegatePrivate))]
#endif
		private static void on_conference_left(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_conference_left_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnConferenceLeftDelegate OnConferenceLeft
		{
			get
			{
				return on_conference_left_public;
			}
			set
			{
				on_conference_left_public = value;
				on_conference_left_private = on_conference_left;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_conference_left_private);
				linphone_chat_room_cbs_set_conference_left(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_conference_left(nativePtr, on_conference_left_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_ephemeral_event(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_ephemeral_event(IntPtr thiz, OnEphemeralEventDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEphemeralEventDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that an ephemeral related event has been
		/// generated. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnEphemeralEventDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnEphemeralEventDelegatePrivate on_ephemeral_event_private;
		private OnEphemeralEventDelegate on_ephemeral_event_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEphemeralEventDelegatePrivate))]
#endif
		private static void on_ephemeral_event(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_ephemeral_event_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnEphemeralEventDelegate OnEphemeralEvent
		{
			get
			{
				return on_ephemeral_event_public;
			}
			set
			{
				on_ephemeral_event_public = value;
				on_ephemeral_event_private = on_ephemeral_event;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ephemeral_event_private);
				linphone_chat_room_cbs_set_ephemeral_event(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_ephemeral_event(nativePtr, on_ephemeral_event_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_ephemeral_message_timer_started(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_ephemeral_message_timer_started(IntPtr thiz, OnEphemeralMessageTimerStartedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEphemeralMessageTimerStartedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that the lifespan of an ephemeral message
		/// before disappearing has started to decrease. 
		/// <para>
		/// This callback is called when the ephemeral message is read by the receiver. 
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnEphemeralMessageTimerStartedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnEphemeralMessageTimerStartedDelegatePrivate on_ephemeral_message_timer_started_private;
		private OnEphemeralMessageTimerStartedDelegate on_ephemeral_message_timer_started_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEphemeralMessageTimerStartedDelegatePrivate))]
#endif
		private static void on_ephemeral_message_timer_started(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_ephemeral_message_timer_started_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnEphemeralMessageTimerStartedDelegate OnEphemeralMessageTimerStarted
		{
			get
			{
				return on_ephemeral_message_timer_started_public;
			}
			set
			{
				on_ephemeral_message_timer_started_public = value;
				on_ephemeral_message_timer_started_private = on_ephemeral_message_timer_started;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ephemeral_message_timer_started_private);
				linphone_chat_room_cbs_set_ephemeral_message_timer_started(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_ephemeral_message_timer_started(nativePtr, on_ephemeral_message_timer_started_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_ephemeral_message_deleted(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_ephemeral_message_deleted(IntPtr thiz, OnEphemeralMessageDeletedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEphemeralMessageDeletedDelegatePrivate(IntPtr chatRoom, IntPtr eventLog);

		/// <summary>
		/// Callback used to notify a chat room that an ephemeral message has been deleted. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="eventLog"><see cref="Linphone.EventLog">Linphone.EventLog</see>
		/// The event to be notified    </param>
		public delegate void OnEphemeralMessageDeletedDelegate(Linphone.ChatRoom chatRoom, Linphone.EventLog eventLog);
		private OnEphemeralMessageDeletedDelegatePrivate on_ephemeral_message_deleted_private;
		private OnEphemeralMessageDeletedDelegate on_ephemeral_message_deleted_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEphemeralMessageDeletedDelegatePrivate))]
#endif
		private static void on_ephemeral_message_deleted(IntPtr chatRoom, IntPtr eventLog)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_ephemeral_message_deleted_public?.Invoke(thiz, fromNativePtr<Linphone.EventLog>(eventLog));
			}
		}

		public OnEphemeralMessageDeletedDelegate OnEphemeralMessageDeleted
		{
			get
			{
				return on_ephemeral_message_deleted_public;
			}
			set
			{
				on_ephemeral_message_deleted_public = value;
				on_ephemeral_message_deleted_private = on_ephemeral_message_deleted;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ephemeral_message_deleted_private);
				linphone_chat_room_cbs_set_ephemeral_message_deleted(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_ephemeral_message_deleted(nativePtr, on_ephemeral_message_deleted_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_conference_address_generation(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_conference_address_generation(IntPtr thiz, OnConferenceAddressGenerationDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnConferenceAddressGenerationDelegatePrivate(IntPtr chatRoom);

		/// <summary>
		/// Callback used when a group chat room is created server-side to generate the
		/// address of the chat room. 
		/// <para>
		/// The function <see cref="Linphone.ChatRoom.ConferenceAddress">
		/// Linphone.ChatRoom.ConferenceAddress</see> needs to be called by this callback. 
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		public delegate void OnConferenceAddressGenerationDelegate(Linphone.ChatRoom chatRoom);
		private OnConferenceAddressGenerationDelegatePrivate on_conference_address_generation_private;
		private OnConferenceAddressGenerationDelegate on_conference_address_generation_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnConferenceAddressGenerationDelegatePrivate))]
#endif
		private static void on_conference_address_generation(IntPtr chatRoom)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_conference_address_generation_public?.Invoke(thiz);
			}
		}

		public OnConferenceAddressGenerationDelegate OnConferenceAddressGeneration
		{
			get
			{
				return on_conference_address_generation_public;
			}
			set
			{
				on_conference_address_generation_public = value;
				on_conference_address_generation_private = on_conference_address_generation;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_conference_address_generation_private);
				linphone_chat_room_cbs_set_conference_address_generation(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_conference_address_generation(nativePtr, on_conference_address_generation_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_participant_registration_subscription_requested(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_registration_subscription_requested(IntPtr thiz, OnParticipantRegistrationSubscriptionRequestedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantRegistrationSubscriptionRequestedDelegatePrivate(IntPtr chatRoom, IntPtr participantAddress);

		/// <summary>
		/// Callback used when a group chat room server is subscribing to registration
		/// state of a participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="participantAddress"><see cref="Linphone.Address">
		/// Linphone.Address</see> object    </param>
		public delegate void OnParticipantRegistrationSubscriptionRequestedDelegate(Linphone.ChatRoom chatRoom, Linphone.Address participantAddress);
		private OnParticipantRegistrationSubscriptionRequestedDelegatePrivate on_participant_registration_subscription_requested_private;
		private OnParticipantRegistrationSubscriptionRequestedDelegate on_participant_registration_subscription_requested_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantRegistrationSubscriptionRequestedDelegatePrivate))]
#endif
		private static void on_participant_registration_subscription_requested(IntPtr chatRoom, IntPtr participantAddress)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_registration_subscription_requested_public?.Invoke(thiz, fromNativePtr<Linphone.Address>(participantAddress));
			}
		}

		public OnParticipantRegistrationSubscriptionRequestedDelegate OnParticipantRegistrationSubscriptionRequested
		{
			get
			{
				return on_participant_registration_subscription_requested_public;
			}
			set
			{
				on_participant_registration_subscription_requested_public = value;
				on_participant_registration_subscription_requested_private = on_participant_registration_subscription_requested;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_registration_subscription_requested_private);
				linphone_chat_room_cbs_set_participant_registration_subscription_requested(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_registration_subscription_requested(nativePtr, on_participant_registration_subscription_requested_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_participant_registration_unsubscription_requested(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_participant_registration_unsubscription_requested(IntPtr thiz, OnParticipantRegistrationUnsubscriptionRequestedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantRegistrationUnsubscriptionRequestedDelegatePrivate(IntPtr chatRoom, IntPtr participantAddress);

		/// <summary>
		/// Callback used when a group chat room server is unsubscribing to registration
		/// state of a participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="participantAddress"><see cref="Linphone.Address">
		/// Linphone.Address</see> object    </param>
		public delegate void OnParticipantRegistrationUnsubscriptionRequestedDelegate(Linphone.ChatRoom chatRoom, Linphone.Address participantAddress);
		private OnParticipantRegistrationUnsubscriptionRequestedDelegatePrivate on_participant_registration_unsubscription_requested_private;
		private OnParticipantRegistrationUnsubscriptionRequestedDelegate on_participant_registration_unsubscription_requested_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantRegistrationUnsubscriptionRequestedDelegatePrivate))]
#endif
		private static void on_participant_registration_unsubscription_requested(IntPtr chatRoom, IntPtr participantAddress)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_registration_unsubscription_requested_public?.Invoke(thiz, fromNativePtr<Linphone.Address>(participantAddress));
			}
		}

		public OnParticipantRegistrationUnsubscriptionRequestedDelegate OnParticipantRegistrationUnsubscriptionRequested
		{
			get
			{
				return on_participant_registration_unsubscription_requested_public;
			}
			set
			{
				on_participant_registration_unsubscription_requested_public = value;
				on_participant_registration_unsubscription_requested_private = on_participant_registration_unsubscription_requested;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_registration_unsubscription_requested_private);
				linphone_chat_room_cbs_set_participant_registration_unsubscription_requested(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_participant_registration_unsubscription_requested(nativePtr, on_participant_registration_unsubscription_requested_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_chat_message_should_be_stored(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_chat_message_should_be_stored(IntPtr thiz, OnChatMessageShouldBeStoredDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatMessageShouldBeStoredDelegatePrivate(IntPtr chatRoom, IntPtr message);

		/// <summary>
		/// Callback used to tell the core whether or not to store the incoming message in
		/// db or not using <see cref="Linphone.ChatMessage.ToBeStored">
		/// Linphone.ChatMessage.ToBeStored</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="message">The <see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> that is being received    </param>
		public delegate void OnChatMessageShouldBeStoredDelegate(Linphone.ChatRoom chatRoom, Linphone.ChatMessage message);
		private OnChatMessageShouldBeStoredDelegatePrivate on_chat_message_should_be_stored_private;
		private OnChatMessageShouldBeStoredDelegate on_chat_message_should_be_stored_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatMessageShouldBeStoredDelegatePrivate))]
#endif
		private static void on_chat_message_should_be_stored(IntPtr chatRoom, IntPtr message)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_chat_message_should_be_stored_public?.Invoke(thiz, fromNativePtr<Linphone.ChatMessage>(message));
			}
		}

		public OnChatMessageShouldBeStoredDelegate OnChatMessageShouldBeStored
		{
			get
			{
				return on_chat_message_should_be_stored_public;
			}
			set
			{
				on_chat_message_should_be_stored_public = value;
				on_chat_message_should_be_stored_private = on_chat_message_should_be_stored;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_message_should_be_stored_private);
				linphone_chat_room_cbs_set_chat_message_should_be_stored(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_chat_message_should_be_stored(nativePtr, on_chat_message_should_be_stored_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_chat_message_participant_imdn_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_chat_message_participant_imdn_state_changed(IntPtr thiz, OnChatMessageParticipantImdnStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatMessageParticipantImdnStateChangedDelegatePrivate(IntPtr chatRoom, IntPtr message, IntPtr state);

		/// <summary>
		/// Callback used to notify a participant state has changed in a message of this
		/// chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		/// <param name="message">The <see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> for which a participant has it&apos;s state changed 
		///   </param>
		/// <param name="state">The <see cref="Linphone.ParticipantImdnState">
		/// Linphone.ParticipantImdnState</see>    </param>
		public delegate void OnChatMessageParticipantImdnStateChangedDelegate(Linphone.ChatRoom chatRoom, Linphone.ChatMessage message, Linphone.ParticipantImdnState state);
		private OnChatMessageParticipantImdnStateChangedDelegatePrivate on_chat_message_participant_imdn_state_changed_private;
		private OnChatMessageParticipantImdnStateChangedDelegate on_chat_message_participant_imdn_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatMessageParticipantImdnStateChangedDelegatePrivate))]
#endif
		private static void on_chat_message_participant_imdn_state_changed(IntPtr chatRoom, IntPtr message, IntPtr state)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_chat_message_participant_imdn_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ChatMessage>(message), fromNativePtr<Linphone.ParticipantImdnState>(state));
			}
		}

		public OnChatMessageParticipantImdnStateChangedDelegate OnChatMessageParticipantImdnStateChanged
		{
			get
			{
				return on_chat_message_participant_imdn_state_changed_public;
			}
			set
			{
				on_chat_message_participant_imdn_state_changed_public = value;
				on_chat_message_participant_imdn_state_changed_private = on_chat_message_participant_imdn_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_message_participant_imdn_state_changed_private);
				linphone_chat_room_cbs_set_chat_message_participant_imdn_state_changed(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_chat_message_participant_imdn_state_changed(nativePtr, on_chat_message_participant_imdn_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_chat_room_cbs_set_chat_room_read(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_chat_room_cbs_set_chat_room_read(IntPtr thiz, OnChatRoomReadDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatRoomReadDelegatePrivate(IntPtr chatRoom);

		/// <summary>
		/// Callback used to notify a chat room was &quot;marked as read&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">The LinphoneChatRoom object that was marked as read   
		/// </param>
		public delegate void OnChatRoomReadDelegate(Linphone.ChatRoom chatRoom);
		private OnChatRoomReadDelegatePrivate on_chat_room_read_private;
		private OnChatRoomReadDelegate on_chat_room_read_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatRoomReadDelegatePrivate))]
#endif
		private static void on_chat_room_read(IntPtr chatRoom)
		{
			ChatRoom thiz = fromNativePtr<ChatRoom>(chatRoom);

			IntPtr ptr = linphone_chat_room_get_current_callbacks(thiz.nativePtr);
			ChatRoomListener current_listener = fromNativePtr<ChatRoomListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_chat_room_read_public?.Invoke(thiz);
			}
		}

		public OnChatRoomReadDelegate OnChatRoomRead
		{
			get
			{
				return on_chat_room_read_public;
			}
			set
			{
				on_chat_room_read_public = value;
				on_chat_room_read_private = on_chat_room_read;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_room_read_private);
				linphone_chat_room_cbs_set_chat_room_read(nativePtr, cb);
#else
				linphone_chat_room_cbs_set_chat_room_read(nativePtr, on_chat_room_read_private);
#endif
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for the handling a <see cref="Linphone.Conference">
	/// Linphone.Conference</see> objects. 
	/// <para>
	/// Use <see cref="Linphone.Factory.CreateConferenceCbs()">
	/// Linphone.Factory.CreateConferenceCbs()</see> to create an instance. Then pass
	/// the object to a <see cref="Linphone.Conference">Linphone.Conference</see>
	/// instance through <see cref="Linphone.Conference.AddListener()">
	/// Linphone.Conference.AddListener()</see>. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ConferenceListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_participant_added(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_added(IntPtr thiz, OnParticipantAddedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantAddedDelegatePrivate(IntPtr conference, IntPtr participant);

		/// <summary>
		/// Callback used to notify a conference that a participant has been added. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object    </param>
		/// <param name="participant">LinphoneParticipant that has been added to the
		/// conference    </param>
		public delegate void OnParticipantAddedDelegate(Linphone.Conference conference, Linphone.Participant participant);
		private OnParticipantAddedDelegatePrivate on_participant_added_private;
		private OnParticipantAddedDelegate on_participant_added_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantAddedDelegatePrivate))]
#endif
		private static void on_participant_added(IntPtr conference, IntPtr participant)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_added_public?.Invoke(thiz, fromNativePtr<Linphone.Participant>(participant));
			}
		}

		public OnParticipantAddedDelegate OnParticipantAdded
		{
			get
			{
				return on_participant_added_public;
			}
			set
			{
				on_participant_added_public = value;
				on_participant_added_private = on_participant_added;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_added_private);
				linphone_conference_cbs_set_participant_added(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_added(nativePtr, on_participant_added_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_participant_removed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_removed(IntPtr thiz, OnParticipantRemovedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantRemovedDelegatePrivate(IntPtr conference, IntPtr participant);

		/// <summary>
		/// Callback used to notify a conference that a participant has been removed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object    </param>
		/// <param name="participant">LinphoneParticipant that has been removed to the
		/// conference    </param>
		public delegate void OnParticipantRemovedDelegate(Linphone.Conference conference, Linphone.Participant participant);
		private OnParticipantRemovedDelegatePrivate on_participant_removed_private;
		private OnParticipantRemovedDelegate on_participant_removed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantRemovedDelegatePrivate))]
#endif
		private static void on_participant_removed(IntPtr conference, IntPtr participant)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_removed_public?.Invoke(thiz, fromNativePtr<Linphone.Participant>(participant));
			}
		}

		public OnParticipantRemovedDelegate OnParticipantRemoved
		{
			get
			{
				return on_participant_removed_public;
			}
			set
			{
				on_participant_removed_public = value;
				on_participant_removed_private = on_participant_removed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_removed_private);
				linphone_conference_cbs_set_participant_removed(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_removed(nativePtr, on_participant_removed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_participant_device_added(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_device_added(IntPtr thiz, OnParticipantDeviceAddedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceAddedDelegatePrivate(IntPtr conference, IntPtr participantDevice);

		/// <summary>
		/// Callback used to notify a conference that a participant has been added. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object    </param>
		/// <param name="participantDevice">LinphoneParticipantDevice that has been added
		/// to the conference    </param>
		public delegate void OnParticipantDeviceAddedDelegate(Linphone.Conference conference, Linphone.ParticipantDevice participantDevice);
		private OnParticipantDeviceAddedDelegatePrivate on_participant_device_added_private;
		private OnParticipantDeviceAddedDelegate on_participant_device_added_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceAddedDelegatePrivate))]
#endif
		private static void on_participant_device_added(IntPtr conference, IntPtr participantDevice)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_device_added_public?.Invoke(thiz, fromNativePtr<Linphone.ParticipantDevice>(participantDevice));
			}
		}

		public OnParticipantDeviceAddedDelegate OnParticipantDeviceAdded
		{
			get
			{
				return on_participant_device_added_public;
			}
			set
			{
				on_participant_device_added_public = value;
				on_participant_device_added_private = on_participant_device_added;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_added_private);
				linphone_conference_cbs_set_participant_device_added(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_device_added(nativePtr, on_participant_device_added_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_participant_device_removed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_device_removed(IntPtr thiz, OnParticipantDeviceRemovedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceRemovedDelegatePrivate(IntPtr conference, IntPtr participantDevice);

		/// <summary>
		/// Callback used to notify a conference that a participant has been removed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object    </param>
		/// <param name="participantDevice">LinphoneParticipantDevice that has been removed
		/// to the conference    </param>
		public delegate void OnParticipantDeviceRemovedDelegate(Linphone.Conference conference, Linphone.ParticipantDevice participantDevice);
		private OnParticipantDeviceRemovedDelegatePrivate on_participant_device_removed_private;
		private OnParticipantDeviceRemovedDelegate on_participant_device_removed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceRemovedDelegatePrivate))]
#endif
		private static void on_participant_device_removed(IntPtr conference, IntPtr participantDevice)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_device_removed_public?.Invoke(thiz, fromNativePtr<Linphone.ParticipantDevice>(participantDevice));
			}
		}

		public OnParticipantDeviceRemovedDelegate OnParticipantDeviceRemoved
		{
			get
			{
				return on_participant_device_removed_public;
			}
			set
			{
				on_participant_device_removed_public = value;
				on_participant_device_removed_private = on_participant_device_removed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_removed_private);
				linphone_conference_cbs_set_participant_device_removed(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_device_removed(nativePtr, on_participant_device_removed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_participant_role_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_role_changed(IntPtr thiz, OnParticipantRoleChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantRoleChangedDelegatePrivate(IntPtr conference, IntPtr participant);

		/// <summary>
		/// Callback used to notify a conference that the role of a participant has been
		/// changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference"><see cref="Linphone.Conference">
		/// Linphone.Conference</see> object    </param>
		/// <param name="participant"><see cref="Linphone.Participant">
		/// Linphone.Participant</see> whose role has changed    </param>
		public delegate void OnParticipantRoleChangedDelegate(Linphone.Conference conference, Linphone.Participant participant);
		private OnParticipantRoleChangedDelegatePrivate on_participant_role_changed_private;
		private OnParticipantRoleChangedDelegate on_participant_role_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantRoleChangedDelegatePrivate))]
#endif
		private static void on_participant_role_changed(IntPtr conference, IntPtr participant)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_role_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Participant>(participant));
			}
		}

		public OnParticipantRoleChangedDelegate OnParticipantRoleChanged
		{
			get
			{
				return on_participant_role_changed_public;
			}
			set
			{
				on_participant_role_changed_public = value;
				on_participant_role_changed_private = on_participant_role_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_role_changed_private);
				linphone_conference_cbs_set_participant_role_changed(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_role_changed(nativePtr, on_participant_role_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_participant_admin_status_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_admin_status_changed(IntPtr thiz, OnParticipantAdminStatusChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantAdminStatusChangedDelegatePrivate(IntPtr conference, IntPtr participant);

		/// <summary>
		/// Callback used to notify a conference that the admin status of a participant has
		/// been changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object    </param>
		/// <param name="participant">LinphoneParticipant whose admin status has changed   
		/// </param>
		public delegate void OnParticipantAdminStatusChangedDelegate(Linphone.Conference conference, Linphone.Participant participant);
		private OnParticipantAdminStatusChangedDelegatePrivate on_participant_admin_status_changed_private;
		private OnParticipantAdminStatusChangedDelegate on_participant_admin_status_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantAdminStatusChangedDelegatePrivate))]
#endif
		private static void on_participant_admin_status_changed(IntPtr conference, IntPtr participant)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_admin_status_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Participant>(participant));
			}
		}

		public OnParticipantAdminStatusChangedDelegate OnParticipantAdminStatusChanged
		{
			get
			{
				return on_participant_admin_status_changed_public;
			}
			set
			{
				on_participant_admin_status_changed_public = value;
				on_participant_admin_status_changed_private = on_participant_admin_status_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_admin_status_changed_private);
				linphone_conference_cbs_set_participant_admin_status_changed(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_admin_status_changed(nativePtr, on_participant_admin_status_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_participant_device_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_device_state_changed(IntPtr thiz, OnParticipantDeviceStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceStateChangedDelegatePrivate(IntPtr conference, IntPtr device, int state);

		/// <summary>
		/// Callback used to notify a conference that a participant device has changed
		/// state. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object    </param>
		/// <param name="device">LinphoneParticipantDevice who change state    </param>
		/// <param name="state">new participant device state </param>
		public delegate void OnParticipantDeviceStateChangedDelegate(Linphone.Conference conference, Linphone.ParticipantDevice device, Linphone.ParticipantDeviceState state);
		private OnParticipantDeviceStateChangedDelegatePrivate on_participant_device_state_changed_private;
		private OnParticipantDeviceStateChangedDelegate on_participant_device_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceStateChangedDelegatePrivate))]
#endif
		private static void on_participant_device_state_changed(IntPtr conference, IntPtr device, int state)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_device_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ParticipantDevice>(device), (Linphone.ParticipantDeviceState)state);
			}
		}

		public OnParticipantDeviceStateChangedDelegate OnParticipantDeviceStateChanged
		{
			get
			{
				return on_participant_device_state_changed_public;
			}
			set
			{
				on_participant_device_state_changed_public = value;
				on_participant_device_state_changed_private = on_participant_device_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_state_changed_private);
				linphone_conference_cbs_set_participant_device_state_changed(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_device_state_changed(nativePtr, on_participant_device_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_participant_device_media_availability_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_device_media_availability_changed(IntPtr thiz, OnParticipantDeviceMediaAvailabilityChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceMediaAvailabilityChangedDelegatePrivate(IntPtr conference, IntPtr device);

		/// <summary>
		/// Callback used to notify a conference that the media availability of a
		/// participant device has been changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object    </param>
		/// <param name="device">LinphoneParticipantDevice whose media availability changed
		/// has changed    </param>
		public delegate void OnParticipantDeviceMediaAvailabilityChangedDelegate(Linphone.Conference conference, Linphone.ParticipantDevice device);
		private OnParticipantDeviceMediaAvailabilityChangedDelegatePrivate on_participant_device_media_availability_changed_private;
		private OnParticipantDeviceMediaAvailabilityChangedDelegate on_participant_device_media_availability_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceMediaAvailabilityChangedDelegatePrivate))]
#endif
		private static void on_participant_device_media_availability_changed(IntPtr conference, IntPtr device)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_device_media_availability_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ParticipantDevice>(device));
			}
		}

		public OnParticipantDeviceMediaAvailabilityChangedDelegate OnParticipantDeviceMediaAvailabilityChanged
		{
			get
			{
				return on_participant_device_media_availability_changed_public;
			}
			set
			{
				on_participant_device_media_availability_changed_public = value;
				on_participant_device_media_availability_changed_private = on_participant_device_media_availability_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_media_availability_changed_private);
				linphone_conference_cbs_set_participant_device_media_availability_changed(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_device_media_availability_changed(nativePtr, on_participant_device_media_availability_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_participant_device_media_capability_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_device_media_capability_changed(IntPtr thiz, OnParticipantDeviceMediaCapabilityChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceMediaCapabilityChangedDelegatePrivate(IntPtr conference, IntPtr device);

		/// <summary>
		/// Callback used to notify a conference that the media capability of a participant
		/// device has been changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference"><see cref="Linphone.Conference">
		/// Linphone.Conference</see> object    </param>
		/// <param name="device"><see cref="Linphone.ParticipantDevice">
		/// Linphone.ParticipantDevice</see> whose media capability changed has changed   
		/// </param>
		public delegate void OnParticipantDeviceMediaCapabilityChangedDelegate(Linphone.Conference conference, Linphone.ParticipantDevice device);
		private OnParticipantDeviceMediaCapabilityChangedDelegatePrivate on_participant_device_media_capability_changed_private;
		private OnParticipantDeviceMediaCapabilityChangedDelegate on_participant_device_media_capability_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceMediaCapabilityChangedDelegatePrivate))]
#endif
		private static void on_participant_device_media_capability_changed(IntPtr conference, IntPtr device)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_device_media_capability_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ParticipantDevice>(device));
			}
		}

		public OnParticipantDeviceMediaCapabilityChangedDelegate OnParticipantDeviceMediaCapabilityChanged
		{
			get
			{
				return on_participant_device_media_capability_changed_public;
			}
			set
			{
				on_participant_device_media_capability_changed_public = value;
				on_participant_device_media_capability_changed_private = on_participant_device_media_capability_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_media_capability_changed_private);
				linphone_conference_cbs_set_participant_device_media_capability_changed(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_device_media_capability_changed(nativePtr, on_participant_device_media_capability_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_state_changed(IntPtr thiz, OnStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnStateChangedDelegatePrivate(IntPtr conference, int newState);

		/// <summary>
		/// Callback used to notify a conference state has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object    </param>
		/// <param name="newState">The new state of the conference </param>
		public delegate void OnStateChangedDelegate(Linphone.Conference conference, Linphone.ConferenceState newState);
		private OnStateChangedDelegatePrivate on_state_changed_private;
		private OnStateChangedDelegate on_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnStateChangedDelegatePrivate))]
#endif
		private static void on_state_changed(IntPtr conference, int newState)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_state_changed_public?.Invoke(thiz, (Linphone.ConferenceState)newState);
			}
		}

		public OnStateChangedDelegate OnStateChanged
		{
			get
			{
				return on_state_changed_public;
			}
			set
			{
				on_state_changed_public = value;
				on_state_changed_private = on_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_state_changed_private);
				linphone_conference_cbs_set_state_changed(nativePtr, cb);
#else
				linphone_conference_cbs_set_state_changed(nativePtr, on_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_available_media_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_available_media_changed(IntPtr thiz, OnAvailableMediaChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAvailableMediaChangedDelegatePrivate(IntPtr conference);

		/// <summary>
		/// Callback used to notify that the available media of a conference has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference"><see cref="Linphone.Conference">
		/// Linphone.Conference</see> object    </param>
		public delegate void OnAvailableMediaChangedDelegate(Linphone.Conference conference);
		private OnAvailableMediaChangedDelegatePrivate on_available_media_changed_private;
		private OnAvailableMediaChangedDelegate on_available_media_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAvailableMediaChangedDelegatePrivate))]
#endif
		private static void on_available_media_changed(IntPtr conference)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_available_media_changed_public?.Invoke(thiz);
			}
		}

		public OnAvailableMediaChangedDelegate OnAvailableMediaChanged
		{
			get
			{
				return on_available_media_changed_public;
			}
			set
			{
				on_available_media_changed_public = value;
				on_available_media_changed_private = on_available_media_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_available_media_changed_private);
				linphone_conference_cbs_set_available_media_changed(nativePtr, cb);
#else
				linphone_conference_cbs_set_available_media_changed(nativePtr, on_available_media_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_subject_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_subject_changed(IntPtr thiz, OnSubjectChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSubjectChangedDelegatePrivate(IntPtr conference, IntPtr subject);

		/// <summary>
		/// Callback used to notify that the subject of a conference has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object    </param>
		/// <param name="subject">subject of the conference    </param>
		public delegate void OnSubjectChangedDelegate(Linphone.Conference conference, string subject);
		private OnSubjectChangedDelegatePrivate on_subject_changed_private;
		private OnSubjectChangedDelegate on_subject_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSubjectChangedDelegatePrivate))]
#endif
		private static void on_subject_changed(IntPtr conference, IntPtr subject)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_subject_changed_public?.Invoke(thiz, PtrToStringSafe(subject));
			}
		}

		public OnSubjectChangedDelegate OnSubjectChanged
		{
			get
			{
				return on_subject_changed_public;
			}
			set
			{
				on_subject_changed_public = value;
				on_subject_changed_private = on_subject_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_subject_changed_private);
				linphone_conference_cbs_set_subject_changed(nativePtr, cb);
#else
				linphone_conference_cbs_set_subject_changed(nativePtr, on_subject_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_participant_device_is_speaking_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_device_is_speaking_changed(IntPtr thiz, OnParticipantDeviceIsSpeakingChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceIsSpeakingChangedDelegatePrivate(IntPtr conference, IntPtr participantDevice, char isSpeaking);

		/// <summary>
		/// Callback used to notify that a participant device is speaking or isn&apos;t
		/// speaking anymore. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference"><see cref="Linphone.Conference">
		/// Linphone.Conference</see> object    </param>
		/// <param name="participantDevice">the participant device    </param>
		/// <param name="isSpeaking">true if is speaking, false otherwise </param>
		public delegate void OnParticipantDeviceIsSpeakingChangedDelegate(Linphone.Conference conference, Linphone.ParticipantDevice participantDevice, bool isSpeaking);
		private OnParticipantDeviceIsSpeakingChangedDelegatePrivate on_participant_device_is_speaking_changed_private;
		private OnParticipantDeviceIsSpeakingChangedDelegate on_participant_device_is_speaking_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceIsSpeakingChangedDelegatePrivate))]
#endif
		private static void on_participant_device_is_speaking_changed(IntPtr conference, IntPtr participantDevice, char isSpeaking)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_device_is_speaking_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ParticipantDevice>(participantDevice), isSpeaking == 0);
			}
		}

		public OnParticipantDeviceIsSpeakingChangedDelegate OnParticipantDeviceIsSpeakingChanged
		{
			get
			{
				return on_participant_device_is_speaking_changed_public;
			}
			set
			{
				on_participant_device_is_speaking_changed_public = value;
				on_participant_device_is_speaking_changed_private = on_participant_device_is_speaking_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_is_speaking_changed_private);
				linphone_conference_cbs_set_participant_device_is_speaking_changed(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_device_is_speaking_changed(nativePtr, on_participant_device_is_speaking_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_participant_device_is_muted(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_participant_device_is_muted(IntPtr thiz, OnParticipantDeviceIsMutedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnParticipantDeviceIsMutedDelegatePrivate(IntPtr conference, IntPtr participantDevice, char isMuted);

		/// <summary>
		/// Callback used to notify that a participant device is muted or is no longer
		/// muted. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference"><see cref="Linphone.Conference">
		/// Linphone.Conference</see> object    </param>
		/// <param name="participantDevice">the participant device    </param>
		/// <param name="isMuted">true if is muted, false otherwise </param>
		public delegate void OnParticipantDeviceIsMutedDelegate(Linphone.Conference conference, Linphone.ParticipantDevice participantDevice, bool isMuted);
		private OnParticipantDeviceIsMutedDelegatePrivate on_participant_device_is_muted_private;
		private OnParticipantDeviceIsMutedDelegate on_participant_device_is_muted_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnParticipantDeviceIsMutedDelegatePrivate))]
#endif
		private static void on_participant_device_is_muted(IntPtr conference, IntPtr participantDevice, char isMuted)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_participant_device_is_muted_public?.Invoke(thiz, fromNativePtr<Linphone.ParticipantDevice>(participantDevice), isMuted == 0);
			}
		}

		public OnParticipantDeviceIsMutedDelegate OnParticipantDeviceIsMuted
		{
			get
			{
				return on_participant_device_is_muted_public;
			}
			set
			{
				on_participant_device_is_muted_public = value;
				on_participant_device_is_muted_private = on_participant_device_is_muted;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_participant_device_is_muted_private);
				linphone_conference_cbs_set_participant_device_is_muted(nativePtr, cb);
#else
				linphone_conference_cbs_set_participant_device_is_muted(nativePtr, on_participant_device_is_muted_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_audio_device_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_audio_device_changed(IntPtr thiz, OnAudioDeviceChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAudioDeviceChangedDelegatePrivate(IntPtr conference, IntPtr audioDevice);

		/// <summary>
		/// Callback used to notify that the audio device of a conference has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference">LinphoneConference object    </param>
		/// <param name="audioDevice">audio device of the conference    </param>
		public delegate void OnAudioDeviceChangedDelegate(Linphone.Conference conference, Linphone.AudioDevice audioDevice);
		private OnAudioDeviceChangedDelegatePrivate on_audio_device_changed_private;
		private OnAudioDeviceChangedDelegate on_audio_device_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAudioDeviceChangedDelegatePrivate))]
#endif
		private static void on_audio_device_changed(IntPtr conference, IntPtr audioDevice)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_audio_device_changed_public?.Invoke(thiz, fromNativePtr<Linphone.AudioDevice>(audioDevice));
			}
		}

		public OnAudioDeviceChangedDelegate OnAudioDeviceChanged
		{
			get
			{
				return on_audio_device_changed_public;
			}
			set
			{
				on_audio_device_changed_public = value;
				on_audio_device_changed_private = on_audio_device_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_audio_device_changed_private);
				linphone_conference_cbs_set_audio_device_changed(nativePtr, cb);
#else
				linphone_conference_cbs_set_audio_device_changed(nativePtr, on_audio_device_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_cbs_set_active_speaker_participant_device(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_cbs_set_active_speaker_participant_device(IntPtr thiz, OnActiveSpeakerParticipantDeviceDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnActiveSpeakerParticipantDeviceDelegatePrivate(IntPtr conference, IntPtr participantDevice);

		/// <summary>
		/// Callback used to notify which participant device video is being displayed as
		/// &quot;actively speaking&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference"><see cref="Linphone.Conference">
		/// Linphone.Conference</see> object    </param>
		/// <param name="participantDevice">the participant device currently displayed as
		/// active speaker    </param>
		public delegate void OnActiveSpeakerParticipantDeviceDelegate(Linphone.Conference conference, Linphone.ParticipantDevice participantDevice);
		private OnActiveSpeakerParticipantDeviceDelegatePrivate on_active_speaker_participant_device_private;
		private OnActiveSpeakerParticipantDeviceDelegate on_active_speaker_participant_device_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnActiveSpeakerParticipantDeviceDelegatePrivate))]
#endif
		private static void on_active_speaker_participant_device(IntPtr conference, IntPtr participantDevice)
		{
			Conference thiz = fromNativePtr<Conference>(conference);

			IntPtr ptr = linphone_conference_get_current_callbacks(thiz.nativePtr);
			ConferenceListener current_listener = fromNativePtr<ConferenceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_active_speaker_participant_device_public?.Invoke(thiz, fromNativePtr<Linphone.ParticipantDevice>(participantDevice));
			}
		}

		public OnActiveSpeakerParticipantDeviceDelegate OnActiveSpeakerParticipantDevice
		{
			get
			{
				return on_active_speaker_participant_device_public;
			}
			set
			{
				on_active_speaker_participant_device_public = value;
				on_active_speaker_participant_device_private = on_active_speaker_participant_device;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_active_speaker_participant_device_private);
				linphone_conference_cbs_set_active_speaker_participant_device(nativePtr, cb);
#else
				linphone_conference_cbs_set_active_speaker_participant_device(nativePtr, on_active_speaker_participant_device_private);
#endif
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks of <see cref="Linphone.ConferenceScheduler">
	/// Linphone.ConferenceScheduler</see> object. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ConferenceSchedulerListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_scheduler_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_scheduler_cbs_set_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_scheduler_cbs_set_state_changed(IntPtr thiz, OnStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnStateChangedDelegatePrivate(IntPtr conferenceScheduler, int state);

		/// <summary>
		/// Callback for notifying when a registration state has changed for the conference
		/// scheduler. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conferenceScheduler">LinphoneConferenceScheduler object whose
		/// state has changed.    </param>
		/// <param name="state">The current LinphoneConferenceSchedulerState. </param>
		public delegate void OnStateChangedDelegate(Linphone.ConferenceScheduler conferenceScheduler, Linphone.ConferenceSchedulerState state);
		private OnStateChangedDelegatePrivate on_state_changed_private;
		private OnStateChangedDelegate on_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnStateChangedDelegatePrivate))]
#endif
		private static void on_state_changed(IntPtr conferenceScheduler, int state)
		{
			ConferenceScheduler thiz = fromNativePtr<ConferenceScheduler>(conferenceScheduler);

			IntPtr ptr = linphone_conference_scheduler_get_current_callbacks(thiz.nativePtr);
			ConferenceSchedulerListener current_listener = fromNativePtr<ConferenceSchedulerListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_state_changed_public?.Invoke(thiz, (Linphone.ConferenceSchedulerState)state);
			}
		}

		public OnStateChangedDelegate OnStateChanged
		{
			get
			{
				return on_state_changed_public;
			}
			set
			{
				on_state_changed_public = value;
				on_state_changed_private = on_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_state_changed_private);
				linphone_conference_scheduler_cbs_set_state_changed(nativePtr, cb);
#else
				linphone_conference_scheduler_cbs_set_state_changed(nativePtr, on_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_conference_scheduler_cbs_set_invitations_sent(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_conference_scheduler_cbs_set_invitations_sent(IntPtr thiz, OnInvitationsSentDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnInvitationsSentDelegatePrivate(IntPtr conferenceScheduler, IntPtr failedInvitations);

		/// <summary>
		/// Callback for notifying when conference invitations have been sent. 
		/// <para>
		/// In case of error for some participants, their addresses will be given as
		/// parameter. 
		/// </para>
		/// </summary>
		/// <param name="conferenceScheduler"><see cref="Linphone.ConferenceScheduler">
		/// Linphone.ConferenceScheduler</see> object whose state has changed.    </param>
		/// <param name="failedInvitations">a list of addresses for which invitation
		/// couldn&apos;t be sent.      </param>
		public delegate void OnInvitationsSentDelegate(Linphone.ConferenceScheduler conferenceScheduler, IEnumerable<Linphone.Address> failedInvitations);
		private OnInvitationsSentDelegatePrivate on_invitations_sent_private;
		private OnInvitationsSentDelegate on_invitations_sent_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnInvitationsSentDelegatePrivate))]
#endif
		private static void on_invitations_sent(IntPtr conferenceScheduler, IntPtr failedInvitations)
		{
			ConferenceScheduler thiz = fromNativePtr<ConferenceScheduler>(conferenceScheduler);

			IntPtr ptr = linphone_conference_scheduler_get_current_callbacks(thiz.nativePtr);
			ConferenceSchedulerListener current_listener = fromNativePtr<ConferenceSchedulerListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_invitations_sent_public?.Invoke(thiz, MarshalBctbxList<Linphone.Address>(failedInvitations));
			}
		}

		public OnInvitationsSentDelegate OnInvitationsSent
		{
			get
			{
				return on_invitations_sent_public;
			}
			set
			{
				on_invitations_sent_public = value;
				on_invitations_sent_private = on_invitations_sent;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_invitations_sent_private);
				linphone_conference_scheduler_cbs_set_invitations_sent(nativePtr, cb);
#else
				linphone_conference_scheduler_cbs_set_invitations_sent(nativePtr, on_invitations_sent_private);
#endif
			}
		}
	}

	/// <summary>
	/// That class holds all the callbacks which are called by <see cref="Linphone.Core">
	/// Linphone.Core</see>. 
	/// <para>
	/// Once created, add your <see cref="Linphone.CoreListener">
	/// Linphone.CoreListener</see> using <see cref="Linphone.Core.AddListener()">
	/// Linphone.Core.AddListener()</see>. Keep a reference on it as long as you need
	/// it. You can use <see cref="Linphone.Core.RemoveListener()">
	/// Linphone.Core.RemoveListener()</see> to remove it but that isn&apos;t mandatory.
	/// The same applies to all listeners in our API. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class CoreListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_new_alert_triggered(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_new_alert_triggered(IntPtr thiz, OnNewAlertTriggeredDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNewAlertTriggeredDelegatePrivate(IntPtr core, IntPtr alert);

		/// <summary>
		/// Callback for notifying about an alert (e.g on Qos) 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="alert"><see cref="Linphone.Alert">Linphone.Alert</see> to notify  
		///  </param>
		public delegate void OnNewAlertTriggeredDelegate(Linphone.Core core, Linphone.Alert alert);
		private OnNewAlertTriggeredDelegatePrivate on_new_alert_triggered_private;
		private OnNewAlertTriggeredDelegate on_new_alert_triggered_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNewAlertTriggeredDelegatePrivate))]
#endif
		private static void on_new_alert_triggered(IntPtr core, IntPtr alert)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_new_alert_triggered_public?.Invoke(thiz, fromNativePtr<Linphone.Alert>(alert));
			}
		}

		public OnNewAlertTriggeredDelegate OnNewAlertTriggered
		{
			get
			{
				return on_new_alert_triggered_public;
			}
			set
			{
				on_new_alert_triggered_public = value;
				on_new_alert_triggered_private = on_new_alert_triggered;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_new_alert_triggered_private);
				linphone_core_cbs_set_new_alert_triggered(nativePtr, cb);
#else
				linphone_core_cbs_set_new_alert_triggered(nativePtr, on_new_alert_triggered_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_global_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_global_state_changed(IntPtr thiz, OnGlobalStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnGlobalStateChangedDelegatePrivate(IntPtr core, int state, IntPtr message);

		/// <summary>
		/// Global state notification callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>.   
		/// </param>
		/// <param name="state">the <see cref="Linphone.GlobalState">
		/// Linphone.GlobalState</see> </param>
		/// <param name="message">informational message.    </param>
		public delegate void OnGlobalStateChangedDelegate(Linphone.Core core, Linphone.GlobalState state, string message);
		private OnGlobalStateChangedDelegatePrivate on_global_state_changed_private;
		private OnGlobalStateChangedDelegate on_global_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnGlobalStateChangedDelegatePrivate))]
#endif
		private static void on_global_state_changed(IntPtr core, int state, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_global_state_changed_public?.Invoke(thiz, (Linphone.GlobalState)state, PtrToStringSafe(message));
			}
		}

		public OnGlobalStateChangedDelegate OnGlobalStateChanged
		{
			get
			{
				return on_global_state_changed_public;
			}
			set
			{
				on_global_state_changed_public = value;
				on_global_state_changed_private = on_global_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_global_state_changed_private);
				linphone_core_cbs_set_global_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_global_state_changed(nativePtr, on_global_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_registration_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_registration_state_changed(IntPtr thiz, OnRegistrationStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnRegistrationStateChangedDelegatePrivate(IntPtr core, IntPtr proxyConfig, int state, IntPtr message);

		/// <summary>
		/// Registration state notification callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="proxyConfig">the <see cref="Linphone.ProxyConfig">
		/// Linphone.ProxyConfig</see> which state has changed    </param>
		/// <param name="state">the current <see cref="Linphone.RegistrationState">
		/// Linphone.RegistrationState</see> </param>
		/// <param name="message">a non null informational message about the state   
		/// </param>
		/// deprecated : 06/04/2020 Use LinphoneCoreCbsAccountRegistrationStateChangedCb
		/// instead
		public delegate void OnRegistrationStateChangedDelegate(Linphone.Core core, Linphone.ProxyConfig proxyConfig, Linphone.RegistrationState state, string message);
		private OnRegistrationStateChangedDelegatePrivate on_registration_state_changed_private;
		private OnRegistrationStateChangedDelegate on_registration_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnRegistrationStateChangedDelegatePrivate))]
#endif
		private static void on_registration_state_changed(IntPtr core, IntPtr proxyConfig, int state, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_registration_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ProxyConfig>(proxyConfig), (Linphone.RegistrationState)state, PtrToStringSafe(message));
			}
		}

		public OnRegistrationStateChangedDelegate OnRegistrationStateChanged
		{
			get
			{
				return on_registration_state_changed_public;
			}
			set
			{
				on_registration_state_changed_public = value;
				on_registration_state_changed_private = on_registration_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_registration_state_changed_private);
				linphone_core_cbs_set_registration_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_registration_state_changed(nativePtr, on_registration_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_conference_info_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_conference_info_received(IntPtr thiz, OnConferenceInfoReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnConferenceInfoReceivedDelegatePrivate(IntPtr core, IntPtr conferenceInfo);

		/// <summary>
		/// Callback prototype for notifying the application about a received conference
		/// info. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="conferenceInfo">the <see cref="Linphone.ConferenceInfo">
		/// Linphone.ConferenceInfo</see> received    </param>
		public delegate void OnConferenceInfoReceivedDelegate(Linphone.Core core, Linphone.ConferenceInfo conferenceInfo);
		private OnConferenceInfoReceivedDelegatePrivate on_conference_info_received_private;
		private OnConferenceInfoReceivedDelegate on_conference_info_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnConferenceInfoReceivedDelegatePrivate))]
#endif
		private static void on_conference_info_received(IntPtr core, IntPtr conferenceInfo)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_conference_info_received_public?.Invoke(thiz, fromNativePtr<Linphone.ConferenceInfo>(conferenceInfo));
			}
		}

		public OnConferenceInfoReceivedDelegate OnConferenceInfoReceived
		{
			get
			{
				return on_conference_info_received_public;
			}
			set
			{
				on_conference_info_received_public = value;
				on_conference_info_received_private = on_conference_info_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_conference_info_received_private);
				linphone_core_cbs_set_conference_info_received(nativePtr, cb);
#else
				linphone_core_cbs_set_conference_info_received(nativePtr, on_conference_info_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_push_notification_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_push_notification_received(IntPtr thiz, OnPushNotificationReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnPushNotificationReceivedDelegatePrivate(IntPtr core, IntPtr payload);

		/// <summary>
		/// Callback prototype for notifying the application a push notification was
		/// received. 
		/// <para>
		/// On iOS it only works with pushkit (VoIP) pushes. 
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="payload">the body of the push notification, if any    </param>
		public delegate void OnPushNotificationReceivedDelegate(Linphone.Core core, string payload);
		private OnPushNotificationReceivedDelegatePrivate on_push_notification_received_private;
		private OnPushNotificationReceivedDelegate on_push_notification_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnPushNotificationReceivedDelegatePrivate))]
#endif
		private static void on_push_notification_received(IntPtr core, IntPtr payload)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_push_notification_received_public?.Invoke(thiz, PtrToStringSafe(payload));
			}
		}

		public OnPushNotificationReceivedDelegate OnPushNotificationReceived
		{
			get
			{
				return on_push_notification_received_public;
			}
			set
			{
				on_push_notification_received_public = value;
				on_push_notification_received_private = on_push_notification_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_push_notification_received_private);
				linphone_core_cbs_set_push_notification_received(nativePtr, cb);
#else
				linphone_core_cbs_set_push_notification_received(nativePtr, on_push_notification_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_preview_display_error_occurred(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_preview_display_error_occurred(IntPtr thiz, OnPreviewDisplayErrorOccurredDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnPreviewDisplayErrorOccurredDelegatePrivate(IntPtr core, int errorCode);

		/// <summary>
		/// Callback to notify that there are errors from the video rendering. 
		/// <para>
		/// Check LinphoneCallCbsVideoDisplayErrorOccurredCb for more details.
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="errorCode">The error code. It depends of the display filter
		/// (available for OpenGL) </param>
		public delegate void OnPreviewDisplayErrorOccurredDelegate(Linphone.Core core, int errorCode);
		private OnPreviewDisplayErrorOccurredDelegatePrivate on_preview_display_error_occurred_private;
		private OnPreviewDisplayErrorOccurredDelegate on_preview_display_error_occurred_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnPreviewDisplayErrorOccurredDelegatePrivate))]
#endif
		private static void on_preview_display_error_occurred(IntPtr core, int errorCode)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_preview_display_error_occurred_public?.Invoke(thiz, errorCode);
			}
		}

		public OnPreviewDisplayErrorOccurredDelegate OnPreviewDisplayErrorOccurred
		{
			get
			{
				return on_preview_display_error_occurred_public;
			}
			set
			{
				on_preview_display_error_occurred_public = value;
				on_preview_display_error_occurred_private = on_preview_display_error_occurred;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_preview_display_error_occurred_private);
				linphone_core_cbs_set_preview_display_error_occurred(nativePtr, cb);
#else
				linphone_core_cbs_set_preview_display_error_occurred(nativePtr, on_preview_display_error_occurred_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_call_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_state_changed(IntPtr thiz, OnCallStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallStateChangedDelegatePrivate(IntPtr core, IntPtr call, int state, IntPtr message);

		/// <summary>
		/// Call state notification callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="call">the <see cref="Linphone.Call">Linphone.Call</see> object
		/// whose state is changed.    </param>
		/// <param name="state">the new <see cref="Linphone.CallState">
		/// Linphone.CallState</see> of the call </param>
		/// <param name="message">a non null informational message about the state.   
		/// </param>
		public delegate void OnCallStateChangedDelegate(Linphone.Core core, Linphone.Call call, Linphone.CallState state, string message);
		private OnCallStateChangedDelegatePrivate on_call_state_changed_private;
		private OnCallStateChangedDelegate on_call_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallStateChangedDelegatePrivate))]
#endif
		private static void on_call_state_changed(IntPtr core, IntPtr call, int state, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_call_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call), (Linphone.CallState)state, PtrToStringSafe(message));
			}
		}

		public OnCallStateChangedDelegate OnCallStateChanged
		{
			get
			{
				return on_call_state_changed_public;
			}
			set
			{
				on_call_state_changed_public = value;
				on_call_state_changed_private = on_call_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_state_changed_private);
				linphone_core_cbs_set_call_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_call_state_changed(nativePtr, on_call_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_notify_presence_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_notify_presence_received(IntPtr thiz, OnNotifyPresenceReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNotifyPresenceReceivedDelegatePrivate(IntPtr core, IntPtr linphoneFriend);

		/// <summary>
		/// Report status change for a friend previously added to the <see cref="Linphone.Core">
		/// Linphone.Core</see> with linphone_core_add_friend(). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="linphoneFriend">Updated <see cref="Linphone.Friend">
		/// Linphone.Friend</see>    </param>
		public delegate void OnNotifyPresenceReceivedDelegate(Linphone.Core core, Linphone.Friend linphoneFriend);
		private OnNotifyPresenceReceivedDelegatePrivate on_notify_presence_received_private;
		private OnNotifyPresenceReceivedDelegate on_notify_presence_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNotifyPresenceReceivedDelegatePrivate))]
#endif
		private static void on_notify_presence_received(IntPtr core, IntPtr linphoneFriend)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_notify_presence_received_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(linphoneFriend));
			}
		}

		public OnNotifyPresenceReceivedDelegate OnNotifyPresenceReceived
		{
			get
			{
				return on_notify_presence_received_public;
			}
			set
			{
				on_notify_presence_received_public = value;
				on_notify_presence_received_private = on_notify_presence_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_notify_presence_received_private);
				linphone_core_cbs_set_notify_presence_received(nativePtr, cb);
#else
				linphone_core_cbs_set_notify_presence_received(nativePtr, on_notify_presence_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_notify_presence_received_for_uri_or_tel(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_notify_presence_received_for_uri_or_tel(IntPtr thiz, OnNotifyPresenceReceivedForUriOrTelDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNotifyPresenceReceivedForUriOrTelDelegatePrivate(IntPtr core, IntPtr linphoneFriend, IntPtr uriOrTel, IntPtr presenceModel);

		/// <summary>
		/// Reports presence model change for a specific URI or phone number of a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="linphoneFriend"><see cref="Linphone.Friend">Linphone.Friend</see>
		/// object    </param>
		/// <param name="uriOrTel">The URI or phone number for which the presence model has
		/// changed    </param>
		/// <param name="presenceModel">The new <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see>    </param>
		public delegate void OnNotifyPresenceReceivedForUriOrTelDelegate(Linphone.Core core, Linphone.Friend linphoneFriend, string uriOrTel, Linphone.PresenceModel presenceModel);
		private OnNotifyPresenceReceivedForUriOrTelDelegatePrivate on_notify_presence_received_for_uri_or_tel_private;
		private OnNotifyPresenceReceivedForUriOrTelDelegate on_notify_presence_received_for_uri_or_tel_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNotifyPresenceReceivedForUriOrTelDelegatePrivate))]
#endif
		private static void on_notify_presence_received_for_uri_or_tel(IntPtr core, IntPtr linphoneFriend, IntPtr uriOrTel, IntPtr presenceModel)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_notify_presence_received_for_uri_or_tel_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(linphoneFriend), PtrToStringSafe(uriOrTel), fromNativePtr<Linphone.PresenceModel>(presenceModel));
			}
		}

		public OnNotifyPresenceReceivedForUriOrTelDelegate OnNotifyPresenceReceivedForUriOrTel
		{
			get
			{
				return on_notify_presence_received_for_uri_or_tel_public;
			}
			set
			{
				on_notify_presence_received_for_uri_or_tel_public = value;
				on_notify_presence_received_for_uri_or_tel_private = on_notify_presence_received_for_uri_or_tel;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_notify_presence_received_for_uri_or_tel_private);
				linphone_core_cbs_set_notify_presence_received_for_uri_or_tel(nativePtr, cb);
#else
				linphone_core_cbs_set_notify_presence_received_for_uri_or_tel(nativePtr, on_notify_presence_received_for_uri_or_tel_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_new_subscription_requested(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_new_subscription_requested(IntPtr thiz, OnNewSubscriptionRequestedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNewSubscriptionRequestedDelegatePrivate(IntPtr core, IntPtr linphoneFriend, IntPtr url);

		/// <summary>
		/// Reports that a new subscription request has been received and wait for a
		/// decision. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Note : A subscription request is notified by this function only if the
		/// <see cref="Linphone.SubscribePolicy">Linphone.SubscribePolicy</see> for the
		/// given <see cref="Linphone.Friend">Linphone.Friend</see> has been set to <see cref="Linphone.SubscribePolicy.SPWait">
		/// Linphone.SubscribePolicy.SPWait</see>. See <see cref="Linphone.Friend.IncSubscribePolicy">
		/// Linphone.Friend.IncSubscribePolicy</see>. </remarks>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="linphoneFriend">The <see cref="Linphone.Friend">
		/// Linphone.Friend</see> aimed by the subscription.    </param>
		/// <param name="url">URI of the subscriber    </param>
		public delegate void OnNewSubscriptionRequestedDelegate(Linphone.Core core, Linphone.Friend linphoneFriend, string url);
		private OnNewSubscriptionRequestedDelegatePrivate on_new_subscription_requested_private;
		private OnNewSubscriptionRequestedDelegate on_new_subscription_requested_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNewSubscriptionRequestedDelegatePrivate))]
#endif
		private static void on_new_subscription_requested(IntPtr core, IntPtr linphoneFriend, IntPtr url)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_new_subscription_requested_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(linphoneFriend), PtrToStringSafe(url));
			}
		}

		public OnNewSubscriptionRequestedDelegate OnNewSubscriptionRequested
		{
			get
			{
				return on_new_subscription_requested_public;
			}
			set
			{
				on_new_subscription_requested_public = value;
				on_new_subscription_requested_private = on_new_subscription_requested;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_new_subscription_requested_private);
				linphone_core_cbs_set_new_subscription_requested(nativePtr, cb);
#else
				linphone_core_cbs_set_new_subscription_requested(nativePtr, on_new_subscription_requested_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_authentication_requested(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_authentication_requested(IntPtr thiz, OnAuthenticationRequestedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAuthenticationRequestedDelegatePrivate(IntPtr core, IntPtr authInfo, int method);

		/// <summary>
		/// Callback for requesting authentication information to application or user. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="authInfo">a <see cref="Linphone.AuthInfo">Linphone.AuthInfo</see>
		/// pre-filled with username, realm and domain values as much as possible   
		/// </param>
		/// <param name="method">the type of authentication requested as <see cref="Linphone.AuthMethod">
		/// Linphone.AuthMethod</see> enum    Application shall reply to this callback
		/// using <see cref="Linphone.Core.AddAuthInfo()">
		/// Linphone.Core.AddAuthInfo()</see>. </param>
		public delegate void OnAuthenticationRequestedDelegate(Linphone.Core core, Linphone.AuthInfo authInfo, Linphone.AuthMethod method);
		private OnAuthenticationRequestedDelegatePrivate on_authentication_requested_private;
		private OnAuthenticationRequestedDelegate on_authentication_requested_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAuthenticationRequestedDelegatePrivate))]
#endif
		private static void on_authentication_requested(IntPtr core, IntPtr authInfo, int method)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_authentication_requested_public?.Invoke(thiz, fromNativePtr<Linphone.AuthInfo>(authInfo), (Linphone.AuthMethod)method);
			}
		}

		public OnAuthenticationRequestedDelegate OnAuthenticationRequested
		{
			get
			{
				return on_authentication_requested_public;
			}
			set
			{
				on_authentication_requested_public = value;
				on_authentication_requested_private = on_authentication_requested;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_authentication_requested_private);
				linphone_core_cbs_set_authentication_requested(nativePtr, cb);
#else
				linphone_core_cbs_set_authentication_requested(nativePtr, on_authentication_requested_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_call_log_updated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_log_updated(IntPtr thiz, OnCallLogUpdatedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallLogUpdatedDelegatePrivate(IntPtr core, IntPtr callLog);

		/// <summary>
		/// Callback to notify a new call-log entry has been added. 
		/// <para>
		/// This is done typically when a call terminates. 
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="callLog">the new <see cref="Linphone.CallLog">
		/// Linphone.CallLog</see> entry added.    </param>
		public delegate void OnCallLogUpdatedDelegate(Linphone.Core core, Linphone.CallLog callLog);
		private OnCallLogUpdatedDelegatePrivate on_call_log_updated_private;
		private OnCallLogUpdatedDelegate on_call_log_updated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallLogUpdatedDelegatePrivate))]
#endif
		private static void on_call_log_updated(IntPtr core, IntPtr callLog)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_call_log_updated_public?.Invoke(thiz, fromNativePtr<Linphone.CallLog>(callLog));
			}
		}

		public OnCallLogUpdatedDelegate OnCallLogUpdated
		{
			get
			{
				return on_call_log_updated_public;
			}
			set
			{
				on_call_log_updated_public = value;
				on_call_log_updated_private = on_call_log_updated;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_log_updated_private);
				linphone_core_cbs_set_call_log_updated(nativePtr, cb);
#else
				linphone_core_cbs_set_call_log_updated(nativePtr, on_call_log_updated_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_call_id_updated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_id_updated(IntPtr thiz, OnCallIdUpdatedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallIdUpdatedDelegatePrivate(IntPtr core, IntPtr previousCallId, IntPtr currentCallId);

		/// <summary>
		/// Callback to notify the callid of a call has been updated. 
		/// <para>
		/// This is done typically when a call retry. 
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="previousCallId">the previous callid.    </param>
		/// <param name="currentCallId">the new callid.    </param>
		public delegate void OnCallIdUpdatedDelegate(Linphone.Core core, string previousCallId, string currentCallId);
		private OnCallIdUpdatedDelegatePrivate on_call_id_updated_private;
		private OnCallIdUpdatedDelegate on_call_id_updated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallIdUpdatedDelegatePrivate))]
#endif
		private static void on_call_id_updated(IntPtr core, IntPtr previousCallId, IntPtr currentCallId)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_call_id_updated_public?.Invoke(thiz, PtrToStringSafe(previousCallId), PtrToStringSafe(currentCallId));
			}
		}

		public OnCallIdUpdatedDelegate OnCallIdUpdated
		{
			get
			{
				return on_call_id_updated_public;
			}
			set
			{
				on_call_id_updated_public = value;
				on_call_id_updated_private = on_call_id_updated;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_id_updated_private);
				linphone_core_cbs_set_call_id_updated(nativePtr, cb);
#else
				linphone_core_cbs_set_call_id_updated(nativePtr, on_call_id_updated_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_message_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_message_received(IntPtr thiz, OnMessageReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnMessageReceivedDelegatePrivate(IntPtr core, IntPtr chatRoom, IntPtr message);

		/// <summary>
		/// Chat message callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// involved in this conversation. Can be created by the framework in case the
		/// From-URI is not present in any chat room.    </param>
		/// <param name="message"><see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> incoming message    </param>
		public delegate void OnMessageReceivedDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom, Linphone.ChatMessage message);
		private OnMessageReceivedDelegatePrivate on_message_received_private;
		private OnMessageReceivedDelegate on_message_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnMessageReceivedDelegatePrivate))]
#endif
		private static void on_message_received(IntPtr core, IntPtr chatRoom, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_message_received_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom), fromNativePtr<Linphone.ChatMessage>(message));
			}
		}

		public OnMessageReceivedDelegate OnMessageReceived
		{
			get
			{
				return on_message_received_public;
			}
			set
			{
				on_message_received_public = value;
				on_message_received_private = on_message_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_message_received_private);
				linphone_core_cbs_set_message_received(nativePtr, cb);
#else
				linphone_core_cbs_set_message_received(nativePtr, on_message_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_new_message_reaction(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_new_message_reaction(IntPtr thiz, OnNewMessageReactionDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNewMessageReactionDelegatePrivate(IntPtr core, IntPtr chatRoom, IntPtr message, IntPtr reaction);

		/// <summary>
		/// Chat message new reaction callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// involved in this conversation. Can be created by the framework in case the
		/// From-URI is not present in any chat room.    </param>
		/// <param name="message">the <see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> to which the reaction applies to    </param>
		/// <param name="reaction">the <see cref="Linphone.ChatMessageReaction">
		/// Linphone.ChatMessageReaction</see> that has been sent or received    </param>
		public delegate void OnNewMessageReactionDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom, Linphone.ChatMessage message, Linphone.ChatMessageReaction reaction);
		private OnNewMessageReactionDelegatePrivate on_new_message_reaction_private;
		private OnNewMessageReactionDelegate on_new_message_reaction_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNewMessageReactionDelegatePrivate))]
#endif
		private static void on_new_message_reaction(IntPtr core, IntPtr chatRoom, IntPtr message, IntPtr reaction)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_new_message_reaction_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom), fromNativePtr<Linphone.ChatMessage>(message), fromNativePtr<Linphone.ChatMessageReaction>(reaction));
			}
		}

		public OnNewMessageReactionDelegate OnNewMessageReaction
		{
			get
			{
				return on_new_message_reaction_public;
			}
			set
			{
				on_new_message_reaction_public = value;
				on_new_message_reaction_private = on_new_message_reaction;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_new_message_reaction_private);
				linphone_core_cbs_set_new_message_reaction(nativePtr, cb);
#else
				linphone_core_cbs_set_new_message_reaction(nativePtr, on_new_message_reaction_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_reaction_removed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_reaction_removed(IntPtr thiz, OnReactionRemovedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnReactionRemovedDelegatePrivate(IntPtr core, IntPtr chatRoom, IntPtr message, IntPtr address);

		/// <summary>
		/// Chat message removed reaction callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// involved in this conversation. Can be created by the framework in case the
		/// From-URI is not present in any chat room.    </param>
		/// <param name="message">the <see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> to which a reaction has been removed from    </param>
		/// <param name="address">the <see cref="Linphone.Address">Linphone.Address</see>
		/// of the person that removed it&apos;s reaction    </param>
		public delegate void OnReactionRemovedDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom, Linphone.ChatMessage message, Linphone.Address address);
		private OnReactionRemovedDelegatePrivate on_reaction_removed_private;
		private OnReactionRemovedDelegate on_reaction_removed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnReactionRemovedDelegatePrivate))]
#endif
		private static void on_reaction_removed(IntPtr core, IntPtr chatRoom, IntPtr message, IntPtr address)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_reaction_removed_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom), fromNativePtr<Linphone.ChatMessage>(message), fromNativePtr<Linphone.Address>(address));
			}
		}

		public OnReactionRemovedDelegate OnReactionRemoved
		{
			get
			{
				return on_reaction_removed_public;
			}
			set
			{
				on_reaction_removed_public = value;
				on_reaction_removed_private = on_reaction_removed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_reaction_removed_private);
				linphone_core_cbs_set_reaction_removed(nativePtr, cb);
#else
				linphone_core_cbs_set_reaction_removed(nativePtr, on_reaction_removed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_messages_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_messages_received(IntPtr thiz, OnMessagesReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnMessagesReceivedDelegatePrivate(IntPtr core, IntPtr chatRoom, IntPtr messages);

		/// <summary>
		/// Chat messages callback prototype. 
		/// <para>
		/// Only called when aggregation is enabled (aka [sip] chat_messages_aggregation ==
		/// 1 or using <see cref="Linphone.Core.ChatMessagesAggregationEnabled">
		/// Linphone.Core.ChatMessagesAggregationEnabled</see>), it replaces the single
		/// message received callback. 
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// involved in this conversation. Can be created by the framework in case the
		/// From-URI is not present in any chat room.    </param>
		/// <param name="messages">The   of incoming messages    </param>
		public delegate void OnMessagesReceivedDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom, IEnumerable<Linphone.ChatMessage> messages);
		private OnMessagesReceivedDelegatePrivate on_messages_received_private;
		private OnMessagesReceivedDelegate on_messages_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnMessagesReceivedDelegatePrivate))]
#endif
		private static void on_messages_received(IntPtr core, IntPtr chatRoom, IntPtr messages)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_messages_received_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom), MarshalBctbxList<Linphone.ChatMessage>(messages));
			}
		}

		public OnMessagesReceivedDelegate OnMessagesReceived
		{
			get
			{
				return on_messages_received_public;
			}
			set
			{
				on_messages_received_public = value;
				on_messages_received_private = on_messages_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_messages_received_private);
				linphone_core_cbs_set_messages_received(nativePtr, cb);
#else
				linphone_core_cbs_set_messages_received(nativePtr, on_messages_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_message_sent(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_message_sent(IntPtr thiz, OnMessageSentDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnMessageSentDelegatePrivate(IntPtr core, IntPtr chatRoom, IntPtr message);

		/// <summary>
		/// Called after the <see cref="Linphone.ChatMessage.Send()">
		/// Linphone.ChatMessage.Send()</see> was called. 
		/// <para>
		/// The message will be in state InProgress. In case of resend this callback
		/// won&apos;t be called. 
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// involved in this conversation. Can be be created by the framework in case the
		/// From-URI is not present in any chat room.    </param>
		/// <param name="message"><see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> outgoing message    </param>
		public delegate void OnMessageSentDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom, Linphone.ChatMessage message);
		private OnMessageSentDelegatePrivate on_message_sent_private;
		private OnMessageSentDelegate on_message_sent_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnMessageSentDelegatePrivate))]
#endif
		private static void on_message_sent(IntPtr core, IntPtr chatRoom, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_message_sent_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom), fromNativePtr<Linphone.ChatMessage>(message));
			}
		}

		public OnMessageSentDelegate OnMessageSent
		{
			get
			{
				return on_message_sent_public;
			}
			set
			{
				on_message_sent_public = value;
				on_message_sent_private = on_message_sent;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_message_sent_private);
				linphone_core_cbs_set_message_sent(nativePtr, cb);
#else
				linphone_core_cbs_set_message_sent(nativePtr, on_message_sent_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_chat_room_session_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_chat_room_session_state_changed(IntPtr thiz, OnChatRoomSessionStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatRoomSessionStateChangedDelegatePrivate(IntPtr core, IntPtr chatRoom, int state, IntPtr message);

		/// <summary>
		/// Chat room session state changed callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// that has been marked as read.    </param>
		/// <param name="state">the new <see cref="Linphone.CallState">
		/// Linphone.CallState</see> of the call </param>
		/// <param name="message">a non null informational message about the state.   
		/// </param>
		public delegate void OnChatRoomSessionStateChangedDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom, Linphone.CallState state, string message);
		private OnChatRoomSessionStateChangedDelegatePrivate on_chat_room_session_state_changed_private;
		private OnChatRoomSessionStateChangedDelegate on_chat_room_session_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatRoomSessionStateChangedDelegatePrivate))]
#endif
		private static void on_chat_room_session_state_changed(IntPtr core, IntPtr chatRoom, int state, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_chat_room_session_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom), (Linphone.CallState)state, PtrToStringSafe(message));
			}
		}

		public OnChatRoomSessionStateChangedDelegate OnChatRoomSessionStateChanged
		{
			get
			{
				return on_chat_room_session_state_changed_public;
			}
			set
			{
				on_chat_room_session_state_changed_public = value;
				on_chat_room_session_state_changed_private = on_chat_room_session_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_room_session_state_changed_private);
				linphone_core_cbs_set_chat_room_session_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_chat_room_session_state_changed(nativePtr, on_chat_room_session_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_chat_room_read(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_chat_room_read(IntPtr thiz, OnChatRoomReadDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatRoomReadDelegatePrivate(IntPtr core, IntPtr chatRoom);

		/// <summary>
		/// Chat room marked as read callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// that has been marked as read.    </param>
		public delegate void OnChatRoomReadDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom);
		private OnChatRoomReadDelegatePrivate on_chat_room_read_private;
		private OnChatRoomReadDelegate on_chat_room_read_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatRoomReadDelegatePrivate))]
#endif
		private static void on_chat_room_read(IntPtr core, IntPtr chatRoom)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_chat_room_read_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom));
			}
		}

		public OnChatRoomReadDelegate OnChatRoomRead
		{
			get
			{
				return on_chat_room_read_public;
			}
			set
			{
				on_chat_room_read_public = value;
				on_chat_room_read_private = on_chat_room_read;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_room_read_private);
				linphone_core_cbs_set_chat_room_read(nativePtr, cb);
#else
				linphone_core_cbs_set_chat_room_read(nativePtr, on_chat_room_read_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_message_received_unable_decrypt(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_message_received_unable_decrypt(IntPtr thiz, OnMessageReceivedUnableDecryptDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnMessageReceivedUnableDecryptDelegatePrivate(IntPtr core, IntPtr chatRoom, IntPtr message);

		/// <summary>
		/// Chat message not decrypted callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// involved in this conversation. Can be be created by the framework in case the
		/// from-URI is not present in any chat room.    </param>
		/// <param name="message"><see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> incoming message    </param>
		public delegate void OnMessageReceivedUnableDecryptDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom, Linphone.ChatMessage message);
		private OnMessageReceivedUnableDecryptDelegatePrivate on_message_received_unable_decrypt_private;
		private OnMessageReceivedUnableDecryptDelegate on_message_received_unable_decrypt_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnMessageReceivedUnableDecryptDelegatePrivate))]
#endif
		private static void on_message_received_unable_decrypt(IntPtr core, IntPtr chatRoom, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_message_received_unable_decrypt_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom), fromNativePtr<Linphone.ChatMessage>(message));
			}
		}

		public OnMessageReceivedUnableDecryptDelegate OnMessageReceivedUnableDecrypt
		{
			get
			{
				return on_message_received_unable_decrypt_public;
			}
			set
			{
				on_message_received_unable_decrypt_public = value;
				on_message_received_unable_decrypt_private = on_message_received_unable_decrypt;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_message_received_unable_decrypt_private);
				linphone_core_cbs_set_message_received_unable_decrypt(nativePtr, cb);
#else
				linphone_core_cbs_set_message_received_unable_decrypt(nativePtr, on_message_received_unable_decrypt_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_is_composing_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_is_composing_received(IntPtr thiz, OnIsComposingReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsComposingReceivedDelegatePrivate(IntPtr core, IntPtr chatRoom);

		/// <summary>
		/// Is composing notification callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="chatRoom"><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// involved in the conversation.    </param>
		public delegate void OnIsComposingReceivedDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom);
		private OnIsComposingReceivedDelegatePrivate on_is_composing_received_private;
		private OnIsComposingReceivedDelegate on_is_composing_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsComposingReceivedDelegatePrivate))]
#endif
		private static void on_is_composing_received(IntPtr core, IntPtr chatRoom)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_is_composing_received_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom));
			}
		}

		public OnIsComposingReceivedDelegate OnIsComposingReceived
		{
			get
			{
				return on_is_composing_received_public;
			}
			set
			{
				on_is_composing_received_public = value;
				on_is_composing_received_private = on_is_composing_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_composing_received_private);
				linphone_core_cbs_set_is_composing_received(nativePtr, cb);
#else
				linphone_core_cbs_set_is_composing_received(nativePtr, on_is_composing_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_dtmf_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_dtmf_received(IntPtr thiz, OnDtmfReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnDtmfReceivedDelegatePrivate(IntPtr core, IntPtr call, int dtmf);

		/// <summary>
		/// Callback for being notified of DTMFs received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="call">the <see cref="Linphone.Call">Linphone.Call</see> that
		/// received the dtmf    </param>
		/// <param name="dtmf">the ascii code of the dtmf </param>
		public delegate void OnDtmfReceivedDelegate(Linphone.Core core, Linphone.Call call, int dtmf);
		private OnDtmfReceivedDelegatePrivate on_dtmf_received_private;
		private OnDtmfReceivedDelegate on_dtmf_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnDtmfReceivedDelegatePrivate))]
#endif
		private static void on_dtmf_received(IntPtr core, IntPtr call, int dtmf)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_dtmf_received_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call), dtmf);
			}
		}

		public OnDtmfReceivedDelegate OnDtmfReceived
		{
			get
			{
				return on_dtmf_received_public;
			}
			set
			{
				on_dtmf_received_public = value;
				on_dtmf_received_private = on_dtmf_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_dtmf_received_private);
				linphone_core_cbs_set_dtmf_received(nativePtr, cb);
#else
				linphone_core_cbs_set_dtmf_received(nativePtr, on_dtmf_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_refer_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_refer_received(IntPtr thiz, OnReferReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnReferReceivedDelegatePrivate(IntPtr core, IntPtr referTo);

		/// <summary>
		/// Callback prototype for when a refer is received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="referTo">the address of the refer    </param>
		public delegate void OnReferReceivedDelegate(Linphone.Core core, string referTo);
		private OnReferReceivedDelegatePrivate on_refer_received_private;
		private OnReferReceivedDelegate on_refer_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnReferReceivedDelegatePrivate))]
#endif
		private static void on_refer_received(IntPtr core, IntPtr referTo)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_refer_received_public?.Invoke(thiz, PtrToStringSafe(referTo));
			}
		}

		public OnReferReceivedDelegate OnReferReceived
		{
			get
			{
				return on_refer_received_public;
			}
			set
			{
				on_refer_received_public = value;
				on_refer_received_private = on_refer_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_refer_received_private);
				linphone_core_cbs_set_refer_received(nativePtr, cb);
#else
				linphone_core_cbs_set_refer_received(nativePtr, on_refer_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_call_goclear_ack_sent(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_goclear_ack_sent(IntPtr thiz, OnCallGoclearAckSentDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallGoclearAckSentDelegatePrivate(IntPtr core, IntPtr call);

		/// <summary>
		/// GoClear ACK sent on call callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="call">the <see cref="Linphone.Call">Linphone.Call</see> on which
		/// the GoClear ACK was sent.    </param>
		public delegate void OnCallGoclearAckSentDelegate(Linphone.Core core, Linphone.Call call);
		private OnCallGoclearAckSentDelegatePrivate on_call_goclear_ack_sent_private;
		private OnCallGoclearAckSentDelegate on_call_goclear_ack_sent_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallGoclearAckSentDelegatePrivate))]
#endif
		private static void on_call_goclear_ack_sent(IntPtr core, IntPtr call)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_call_goclear_ack_sent_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call));
			}
		}

		public OnCallGoclearAckSentDelegate OnCallGoclearAckSent
		{
			get
			{
				return on_call_goclear_ack_sent_public;
			}
			set
			{
				on_call_goclear_ack_sent_public = value;
				on_call_goclear_ack_sent_private = on_call_goclear_ack_sent;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_goclear_ack_sent_private);
				linphone_core_cbs_set_call_goclear_ack_sent(nativePtr, cb);
#else
				linphone_core_cbs_set_call_goclear_ack_sent(nativePtr, on_call_goclear_ack_sent_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_call_encryption_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_encryption_changed(IntPtr thiz, OnCallEncryptionChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallEncryptionChangedDelegatePrivate(IntPtr core, IntPtr call, char mediaEncryptionEnabled, IntPtr authenticationToken);

		/// <summary>
		/// Call encryption changed callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="call">the <see cref="Linphone.Call">Linphone.Call</see> on which
		/// encryption is changed.    </param>
		/// <param name="mediaEncryptionEnabled">whether encryption is activated. </param>
		/// <param name="authenticationToken">an authentication token, currently set for
		/// ZRTP kind of encryption only.    </param>
		public delegate void OnCallEncryptionChangedDelegate(Linphone.Core core, Linphone.Call call, bool mediaEncryptionEnabled, string authenticationToken);
		private OnCallEncryptionChangedDelegatePrivate on_call_encryption_changed_private;
		private OnCallEncryptionChangedDelegate on_call_encryption_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallEncryptionChangedDelegatePrivate))]
#endif
		private static void on_call_encryption_changed(IntPtr core, IntPtr call, char mediaEncryptionEnabled, IntPtr authenticationToken)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_call_encryption_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call), mediaEncryptionEnabled == 0, PtrToStringSafe(authenticationToken));
			}
		}

		public OnCallEncryptionChangedDelegate OnCallEncryptionChanged
		{
			get
			{
				return on_call_encryption_changed_public;
			}
			set
			{
				on_call_encryption_changed_public = value;
				on_call_encryption_changed_private = on_call_encryption_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_encryption_changed_private);
				linphone_core_cbs_set_call_encryption_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_call_encryption_changed(nativePtr, on_call_encryption_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_call_send_master_key_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_send_master_key_changed(IntPtr thiz, OnCallSendMasterKeyChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallSendMasterKeyChangedDelegatePrivate(IntPtr core, IntPtr call, IntPtr masterKey);

		/// <summary>
		/// Call send master key changed callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="call">the <see cref="Linphone.Call">Linphone.Call</see> on which
		/// the GoClear ACK was sent.    </param>
		/// <param name="masterKey">new master key.    </param>
		public delegate void OnCallSendMasterKeyChangedDelegate(Linphone.Core core, Linphone.Call call, string masterKey);
		private OnCallSendMasterKeyChangedDelegatePrivate on_call_send_master_key_changed_private;
		private OnCallSendMasterKeyChangedDelegate on_call_send_master_key_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallSendMasterKeyChangedDelegatePrivate))]
#endif
		private static void on_call_send_master_key_changed(IntPtr core, IntPtr call, IntPtr masterKey)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_call_send_master_key_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call), PtrToStringSafe(masterKey));
			}
		}

		public OnCallSendMasterKeyChangedDelegate OnCallSendMasterKeyChanged
		{
			get
			{
				return on_call_send_master_key_changed_public;
			}
			set
			{
				on_call_send_master_key_changed_public = value;
				on_call_send_master_key_changed_private = on_call_send_master_key_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_send_master_key_changed_private);
				linphone_core_cbs_set_call_send_master_key_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_call_send_master_key_changed(nativePtr, on_call_send_master_key_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_call_receive_master_key_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_receive_master_key_changed(IntPtr thiz, OnCallReceiveMasterKeyChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallReceiveMasterKeyChangedDelegatePrivate(IntPtr core, IntPtr call, IntPtr masterKey);

		/// <summary>
		/// Call receive master key changed callback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="call">the <see cref="Linphone.Call">Linphone.Call</see> on which
		/// the GoClear ACK was sent.    </param>
		/// <param name="masterKey">new master key.    </param>
		public delegate void OnCallReceiveMasterKeyChangedDelegate(Linphone.Core core, Linphone.Call call, string masterKey);
		private OnCallReceiveMasterKeyChangedDelegatePrivate on_call_receive_master_key_changed_private;
		private OnCallReceiveMasterKeyChangedDelegate on_call_receive_master_key_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallReceiveMasterKeyChangedDelegatePrivate))]
#endif
		private static void on_call_receive_master_key_changed(IntPtr core, IntPtr call, IntPtr masterKey)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_call_receive_master_key_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call), PtrToStringSafe(masterKey));
			}
		}

		public OnCallReceiveMasterKeyChangedDelegate OnCallReceiveMasterKeyChanged
		{
			get
			{
				return on_call_receive_master_key_changed_public;
			}
			set
			{
				on_call_receive_master_key_changed_public = value;
				on_call_receive_master_key_changed_private = on_call_receive_master_key_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_receive_master_key_changed_private);
				linphone_core_cbs_set_call_receive_master_key_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_call_receive_master_key_changed(nativePtr, on_call_receive_master_key_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_transfer_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_transfer_state_changed(IntPtr thiz, OnTransferStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnTransferStateChangedDelegatePrivate(IntPtr core, IntPtr transfered, int callState);

		/// <summary>
		/// Callback for notifying progresses of transfers. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="transfered">the <see cref="Linphone.Call">Linphone.Call</see> that
		/// was transfered    </param>
		/// <param name="callState">the <see cref="Linphone.CallState">
		/// Linphone.CallState</see> of the call to transfer target at the far end. </param>
		public delegate void OnTransferStateChangedDelegate(Linphone.Core core, Linphone.Call transfered, Linphone.CallState callState);
		private OnTransferStateChangedDelegatePrivate on_transfer_state_changed_private;
		private OnTransferStateChangedDelegate on_transfer_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnTransferStateChangedDelegatePrivate))]
#endif
		private static void on_transfer_state_changed(IntPtr core, IntPtr transfered, int callState)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_transfer_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(transfered), (Linphone.CallState)callState);
			}
		}

		public OnTransferStateChangedDelegate OnTransferStateChanged
		{
			get
			{
				return on_transfer_state_changed_public;
			}
			set
			{
				on_transfer_state_changed_public = value;
				on_transfer_state_changed_private = on_transfer_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_transfer_state_changed_private);
				linphone_core_cbs_set_transfer_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_transfer_state_changed(nativePtr, on_transfer_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_buddy_info_updated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_buddy_info_updated(IntPtr thiz, OnBuddyInfoUpdatedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnBuddyInfoUpdatedDelegatePrivate(IntPtr core, IntPtr linphoneFriend);

		/// <summary>
		/// Callback prototype when using the buddy plugin. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="linphoneFriend">the <see cref="Linphone.Friend">
		/// Linphone.Friend</see> that has been updated    </param>
		public delegate void OnBuddyInfoUpdatedDelegate(Linphone.Core core, Linphone.Friend linphoneFriend);
		private OnBuddyInfoUpdatedDelegatePrivate on_buddy_info_updated_private;
		private OnBuddyInfoUpdatedDelegate on_buddy_info_updated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnBuddyInfoUpdatedDelegatePrivate))]
#endif
		private static void on_buddy_info_updated(IntPtr core, IntPtr linphoneFriend)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_buddy_info_updated_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(linphoneFriend));
			}
		}

		public OnBuddyInfoUpdatedDelegate OnBuddyInfoUpdated
		{
			get
			{
				return on_buddy_info_updated_public;
			}
			set
			{
				on_buddy_info_updated_public = value;
				on_buddy_info_updated_private = on_buddy_info_updated;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_buddy_info_updated_private);
				linphone_core_cbs_set_buddy_info_updated(nativePtr, cb);
#else
				linphone_core_cbs_set_buddy_info_updated(nativePtr, on_buddy_info_updated_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_call_stats_updated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_stats_updated(IntPtr thiz, OnCallStatsUpdatedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallStatsUpdatedDelegatePrivate(IntPtr core, IntPtr call, IntPtr callStats);

		/// <summary>
		/// Callback for receiving quality statistics for calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="call">the <see cref="Linphone.Call">Linphone.Call</see>    </param>
		/// <param name="callStats">the <see cref="Linphone.CallStats">
		/// Linphone.CallStats</see> statistics.    </param>
		public delegate void OnCallStatsUpdatedDelegate(Linphone.Core core, Linphone.Call call, Linphone.CallStats callStats);
		private OnCallStatsUpdatedDelegatePrivate on_call_stats_updated_private;
		private OnCallStatsUpdatedDelegate on_call_stats_updated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallStatsUpdatedDelegatePrivate))]
#endif
		private static void on_call_stats_updated(IntPtr core, IntPtr call, IntPtr callStats)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_call_stats_updated_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call), fromNativePtr<Linphone.CallStats>(callStats));
			}
		}

		public OnCallStatsUpdatedDelegate OnCallStatsUpdated
		{
			get
			{
				return on_call_stats_updated_public;
			}
			set
			{
				on_call_stats_updated_public = value;
				on_call_stats_updated_private = on_call_stats_updated;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_stats_updated_private);
				linphone_core_cbs_set_call_stats_updated(nativePtr, cb);
#else
				linphone_core_cbs_set_call_stats_updated(nativePtr, on_call_stats_updated_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_info_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_info_received(IntPtr thiz, OnInfoReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnInfoReceivedDelegatePrivate(IntPtr core, IntPtr call, IntPtr message);

		/// <summary>
		/// Callback prototype for receiving info messages. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="call">the call whose info message belongs to.    </param>
		/// <param name="message">the info message.    </param>
		public delegate void OnInfoReceivedDelegate(Linphone.Core core, Linphone.Call call, Linphone.InfoMessage message);
		private OnInfoReceivedDelegatePrivate on_info_received_private;
		private OnInfoReceivedDelegate on_info_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnInfoReceivedDelegatePrivate))]
#endif
		private static void on_info_received(IntPtr core, IntPtr call, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_info_received_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call), fromNativePtr<Linphone.InfoMessage>(message));
			}
		}

		public OnInfoReceivedDelegate OnInfoReceived
		{
			get
			{
				return on_info_received_public;
			}
			set
			{
				on_info_received_public = value;
				on_info_received_private = on_info_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_info_received_private);
				linphone_core_cbs_set_info_received(nativePtr, cb);
#else
				linphone_core_cbs_set_info_received(nativePtr, on_info_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_subscription_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_subscription_state_changed(IntPtr thiz, OnSubscriptionStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSubscriptionStateChangedDelegatePrivate(IntPtr core, IntPtr linphoneEvent, int state);

		/// <summary>
		/// Callback prototype for notifying the application about changes of subscription
		/// states, including arrival of new subscriptions. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="linphoneEvent">the <see cref="Linphone.Event">Linphone.Event</see>
		///    </param>
		/// <param name="state">the new <see cref="Linphone.SubscriptionState">
		/// Linphone.SubscriptionState</see> </param>
		public delegate void OnSubscriptionStateChangedDelegate(Linphone.Core core, Linphone.Event linphoneEvent, Linphone.SubscriptionState state);
		private OnSubscriptionStateChangedDelegatePrivate on_subscription_state_changed_private;
		private OnSubscriptionStateChangedDelegate on_subscription_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSubscriptionStateChangedDelegatePrivate))]
#endif
		private static void on_subscription_state_changed(IntPtr core, IntPtr linphoneEvent, int state)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_subscription_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Event>(linphoneEvent), (Linphone.SubscriptionState)state);
			}
		}

		public OnSubscriptionStateChangedDelegate OnSubscriptionStateChanged
		{
			get
			{
				return on_subscription_state_changed_public;
			}
			set
			{
				on_subscription_state_changed_public = value;
				on_subscription_state_changed_private = on_subscription_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_subscription_state_changed_private);
				linphone_core_cbs_set_subscription_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_subscription_state_changed(nativePtr, on_subscription_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_notify_sent(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_notify_sent(IntPtr thiz, OnNotifySentDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNotifySentDelegatePrivate(IntPtr core, IntPtr linphoneEvent, IntPtr body);

		/// <summary>
		/// Callback prototype for notifying the application about notification that is
		/// being sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="linphoneEvent">the <see cref="Linphone.Event">Linphone.Event</see>
		/// received    </param>
		/// <param name="body">the <see cref="Linphone.Content">Linphone.Content</see> of
		/// the event    </param>
		public delegate void OnNotifySentDelegate(Linphone.Core core, Linphone.Event linphoneEvent, Linphone.Content body);
		private OnNotifySentDelegatePrivate on_notify_sent_private;
		private OnNotifySentDelegate on_notify_sent_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNotifySentDelegatePrivate))]
#endif
		private static void on_notify_sent(IntPtr core, IntPtr linphoneEvent, IntPtr body)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_notify_sent_public?.Invoke(thiz, fromNativePtr<Linphone.Event>(linphoneEvent), fromNativePtr<Linphone.Content>(body));
			}
		}

		public OnNotifySentDelegate OnNotifySent
		{
			get
			{
				return on_notify_sent_public;
			}
			set
			{
				on_notify_sent_public = value;
				on_notify_sent_private = on_notify_sent;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_notify_sent_private);
				linphone_core_cbs_set_notify_sent(nativePtr, cb);
#else
				linphone_core_cbs_set_notify_sent(nativePtr, on_notify_sent_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_notify_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_notify_received(IntPtr thiz, OnNotifyReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNotifyReceivedDelegatePrivate(IntPtr core, IntPtr linphoneEvent, IntPtr notifiedEvent, IntPtr body);

		/// <summary>
		/// Callback prototype for notifying the application about notification received
		/// from the network. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="linphoneEvent">the <see cref="Linphone.Event">Linphone.Event</see>
		/// received    </param>
		/// <param name="notifiedEvent">The event as string    </param>
		/// <param name="body">the <see cref="Linphone.Content">Linphone.Content</see> of
		/// the event    </param>
		public delegate void OnNotifyReceivedDelegate(Linphone.Core core, Linphone.Event linphoneEvent, string notifiedEvent, Linphone.Content body);
		private OnNotifyReceivedDelegatePrivate on_notify_received_private;
		private OnNotifyReceivedDelegate on_notify_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNotifyReceivedDelegatePrivate))]
#endif
		private static void on_notify_received(IntPtr core, IntPtr linphoneEvent, IntPtr notifiedEvent, IntPtr body)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_notify_received_public?.Invoke(thiz, fromNativePtr<Linphone.Event>(linphoneEvent), PtrToStringSafe(notifiedEvent), fromNativePtr<Linphone.Content>(body));
			}
		}

		public OnNotifyReceivedDelegate OnNotifyReceived
		{
			get
			{
				return on_notify_received_public;
			}
			set
			{
				on_notify_received_public = value;
				on_notify_received_private = on_notify_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_notify_received_private);
				linphone_core_cbs_set_notify_received(nativePtr, cb);
#else
				linphone_core_cbs_set_notify_received(nativePtr, on_notify_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_subscribe_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_subscribe_received(IntPtr thiz, OnSubscribeReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSubscribeReceivedDelegatePrivate(IntPtr core, IntPtr linphoneEvent, IntPtr subscribeEvent, IntPtr body);

		/// <summary>
		/// Callback prototype for notifying the application about subscription received
		/// from the network. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="linphoneEvent">the <see cref="Linphone.Event">Linphone.Event</see>
		/// received    </param>
		/// <param name="subscribeEvent">The event as string    </param>
		/// <param name="body">the <see cref="Linphone.Content">Linphone.Content</see> of
		/// the event    </param>
		public delegate void OnSubscribeReceivedDelegate(Linphone.Core core, Linphone.Event linphoneEvent, string subscribeEvent, Linphone.Content body);
		private OnSubscribeReceivedDelegatePrivate on_subscribe_received_private;
		private OnSubscribeReceivedDelegate on_subscribe_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSubscribeReceivedDelegatePrivate))]
#endif
		private static void on_subscribe_received(IntPtr core, IntPtr linphoneEvent, IntPtr subscribeEvent, IntPtr body)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_subscribe_received_public?.Invoke(thiz, fromNativePtr<Linphone.Event>(linphoneEvent), PtrToStringSafe(subscribeEvent), fromNativePtr<Linphone.Content>(body));
			}
		}

		public OnSubscribeReceivedDelegate OnSubscribeReceived
		{
			get
			{
				return on_subscribe_received_public;
			}
			set
			{
				on_subscribe_received_public = value;
				on_subscribe_received_private = on_subscribe_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_subscribe_received_private);
				linphone_core_cbs_set_subscribe_received(nativePtr, cb);
#else
				linphone_core_cbs_set_subscribe_received(nativePtr, on_subscribe_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_publish_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_publish_state_changed(IntPtr thiz, OnPublishStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnPublishStateChangedDelegatePrivate(IntPtr core, IntPtr linphoneEvent, int state);

		/// <summary>
		/// Callback prototype for notifying the application about changes of publish
		/// states. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="linphoneEvent">the <see cref="Linphone.Event">Linphone.Event</see>
		///    </param>
		/// <param name="state">the new <see cref="Linphone.PublishState">
		/// Linphone.PublishState</see> </param>
		public delegate void OnPublishStateChangedDelegate(Linphone.Core core, Linphone.Event linphoneEvent, Linphone.PublishState state);
		private OnPublishStateChangedDelegatePrivate on_publish_state_changed_private;
		private OnPublishStateChangedDelegate on_publish_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnPublishStateChangedDelegatePrivate))]
#endif
		private static void on_publish_state_changed(IntPtr core, IntPtr linphoneEvent, int state)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_publish_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Event>(linphoneEvent), (Linphone.PublishState)state);
			}
		}

		public OnPublishStateChangedDelegate OnPublishStateChanged
		{
			get
			{
				return on_publish_state_changed_public;
			}
			set
			{
				on_publish_state_changed_public = value;
				on_publish_state_changed_private = on_publish_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_publish_state_changed_private);
				linphone_core_cbs_set_publish_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_publish_state_changed(nativePtr, on_publish_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_publish_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_publish_received(IntPtr thiz, OnPublishReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnPublishReceivedDelegatePrivate(IntPtr core, IntPtr linphoneEvent, IntPtr publishEvent, IntPtr body);

		/// <summary>
		/// Callback prototype for notifying the application about publish received from
		/// the network. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="linphoneEvent">the <see cref="Linphone.Event">Linphone.Event</see>
		/// received    </param>
		/// <param name="publishEvent">The event as string    </param>
		/// <param name="body">the <see cref="Linphone.Content">Linphone.Content</see> of
		/// the event    </param>
		public delegate void OnPublishReceivedDelegate(Linphone.Core core, Linphone.Event linphoneEvent, string publishEvent, Linphone.Content body);
		private OnPublishReceivedDelegatePrivate on_publish_received_private;
		private OnPublishReceivedDelegate on_publish_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnPublishReceivedDelegatePrivate))]
#endif
		private static void on_publish_received(IntPtr core, IntPtr linphoneEvent, IntPtr publishEvent, IntPtr body)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_publish_received_public?.Invoke(thiz, fromNativePtr<Linphone.Event>(linphoneEvent), PtrToStringSafe(publishEvent), fromNativePtr<Linphone.Content>(body));
			}
		}

		public OnPublishReceivedDelegate OnPublishReceived
		{
			get
			{
				return on_publish_received_public;
			}
			set
			{
				on_publish_received_public = value;
				on_publish_received_private = on_publish_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_publish_received_private);
				linphone_core_cbs_set_publish_received(nativePtr, cb);
#else
				linphone_core_cbs_set_publish_received(nativePtr, on_publish_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_configuring_status(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_configuring_status(IntPtr thiz, OnConfiguringStatusDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnConfiguringStatusDelegatePrivate(IntPtr core, int status, IntPtr message);

		/// <summary>
		/// Callback prototype for configuring status changes notification. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="status">the current <see cref="Linphone.ConfiguringState">
		/// Linphone.ConfiguringState</see> </param>
		/// <param name="message">informational message.    </param>
		public delegate void OnConfiguringStatusDelegate(Linphone.Core core, Linphone.ConfiguringState status, string message);
		private OnConfiguringStatusDelegatePrivate on_configuring_status_private;
		private OnConfiguringStatusDelegate on_configuring_status_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnConfiguringStatusDelegatePrivate))]
#endif
		private static void on_configuring_status(IntPtr core, int status, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_configuring_status_public?.Invoke(thiz, (Linphone.ConfiguringState)status, PtrToStringSafe(message));
			}
		}

		public OnConfiguringStatusDelegate OnConfiguringStatus
		{
			get
			{
				return on_configuring_status_public;
			}
			set
			{
				on_configuring_status_public = value;
				on_configuring_status_private = on_configuring_status;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_configuring_status_private);
				linphone_core_cbs_set_configuring_status(nativePtr, cb);
#else
				linphone_core_cbs_set_configuring_status(nativePtr, on_configuring_status_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_network_reachable(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_network_reachable(IntPtr thiz, OnNetworkReachableDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNetworkReachableDelegatePrivate(IntPtr core, char reachable);

		/// <summary>
		/// Callback prototype for reporting network change either automatically detected
		/// or notified by <see cref="Linphone.Core.NetworkReachable">
		/// Linphone.Core.NetworkReachable</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the <see cref="Linphone.Core">Linphone.Core</see>    </param>
		/// <param name="reachable">true if network is reachable. </param>
		public delegate void OnNetworkReachableDelegate(Linphone.Core core, bool reachable);
		private OnNetworkReachableDelegatePrivate on_network_reachable_private;
		private OnNetworkReachableDelegate on_network_reachable_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNetworkReachableDelegatePrivate))]
#endif
		private static void on_network_reachable(IntPtr core, char reachable)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_network_reachable_public?.Invoke(thiz, reachable == 0);
			}
		}

		public OnNetworkReachableDelegate OnNetworkReachable
		{
			get
			{
				return on_network_reachable_public;
			}
			set
			{
				on_network_reachable_public = value;
				on_network_reachable_private = on_network_reachable;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_network_reachable_private);
				linphone_core_cbs_set_network_reachable(nativePtr, cb);
#else
				linphone_core_cbs_set_network_reachable(nativePtr, on_network_reachable_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_log_collection_upload_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_log_collection_upload_state_changed(IntPtr thiz, OnLogCollectionUploadStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLogCollectionUploadStateChangedDelegatePrivate(IntPtr core, int state, IntPtr info);

		/// <summary>
		/// Callback prototype for reporting log collection upload state change. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="state">The state of the log collection upload </param>
		/// <param name="info">Additional information: error message in case of error
		/// state, URL of uploaded file in case of success.    </param>
		public delegate void OnLogCollectionUploadStateChangedDelegate(Linphone.Core core, Linphone.CoreLogCollectionUploadState state, string info);
		private OnLogCollectionUploadStateChangedDelegatePrivate on_log_collection_upload_state_changed_private;
		private OnLogCollectionUploadStateChangedDelegate on_log_collection_upload_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnLogCollectionUploadStateChangedDelegatePrivate))]
#endif
		private static void on_log_collection_upload_state_changed(IntPtr core, int state, IntPtr info)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_log_collection_upload_state_changed_public?.Invoke(thiz, (Linphone.CoreLogCollectionUploadState)state, PtrToStringSafe(info));
			}
		}

		public OnLogCollectionUploadStateChangedDelegate OnLogCollectionUploadStateChanged
		{
			get
			{
				return on_log_collection_upload_state_changed_public;
			}
			set
			{
				on_log_collection_upload_state_changed_public = value;
				on_log_collection_upload_state_changed_private = on_log_collection_upload_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_log_collection_upload_state_changed_private);
				linphone_core_cbs_set_log_collection_upload_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_log_collection_upload_state_changed(nativePtr, on_log_collection_upload_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_log_collection_upload_progress_indication(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_log_collection_upload_progress_indication(IntPtr thiz, OnLogCollectionUploadProgressIndicationDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLogCollectionUploadProgressIndicationDelegatePrivate(IntPtr core, long offset, long total);

		/// <summary>
		/// Callback prototype for reporting log collection upload progress indication. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="offset">the number of bytes sent since the start of the upload
		/// </param>
		/// <param name="total">the total number of bytes to upload </param>
		public delegate void OnLogCollectionUploadProgressIndicationDelegate(Linphone.Core core, long offset, long total);
		private OnLogCollectionUploadProgressIndicationDelegatePrivate on_log_collection_upload_progress_indication_private;
		private OnLogCollectionUploadProgressIndicationDelegate on_log_collection_upload_progress_indication_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnLogCollectionUploadProgressIndicationDelegatePrivate))]
#endif
		private static void on_log_collection_upload_progress_indication(IntPtr core, long offset, long total)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_log_collection_upload_progress_indication_public?.Invoke(thiz, offset, total);
			}
		}

		public OnLogCollectionUploadProgressIndicationDelegate OnLogCollectionUploadProgressIndication
		{
			get
			{
				return on_log_collection_upload_progress_indication_public;
			}
			set
			{
				on_log_collection_upload_progress_indication_public = value;
				on_log_collection_upload_progress_indication_private = on_log_collection_upload_progress_indication;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_log_collection_upload_progress_indication_private);
				linphone_core_cbs_set_log_collection_upload_progress_indication(nativePtr, cb);
#else
				linphone_core_cbs_set_log_collection_upload_progress_indication(nativePtr, on_log_collection_upload_progress_indication_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_friend_list_created(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_friend_list_created(IntPtr thiz, OnFriendListCreatedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFriendListCreatedDelegatePrivate(IntPtr core, IntPtr friendList);

		/// <summary>
		/// Callback prototype for reporting when a friend list has been added to the core
		/// friend lists. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="friendList"><see cref="Linphone.FriendList">
		/// Linphone.FriendList</see> object    </param>
		public delegate void OnFriendListCreatedDelegate(Linphone.Core core, Linphone.FriendList friendList);
		private OnFriendListCreatedDelegatePrivate on_friend_list_created_private;
		private OnFriendListCreatedDelegate on_friend_list_created_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFriendListCreatedDelegatePrivate))]
#endif
		private static void on_friend_list_created(IntPtr core, IntPtr friendList)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_friend_list_created_public?.Invoke(thiz, fromNativePtr<Linphone.FriendList>(friendList));
			}
		}

		public OnFriendListCreatedDelegate OnFriendListCreated
		{
			get
			{
				return on_friend_list_created_public;
			}
			set
			{
				on_friend_list_created_public = value;
				on_friend_list_created_private = on_friend_list_created;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_friend_list_created_private);
				linphone_core_cbs_set_friend_list_created(nativePtr, cb);
#else
				linphone_core_cbs_set_friend_list_created(nativePtr, on_friend_list_created_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_friend_list_removed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_friend_list_removed(IntPtr thiz, OnFriendListRemovedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFriendListRemovedDelegatePrivate(IntPtr core, IntPtr friendList);

		/// <summary>
		/// Callback prototype for reporting when a friend list has been removed from the
		/// core friend lists. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="friendList"><see cref="Linphone.FriendList">
		/// Linphone.FriendList</see> object    </param>
		public delegate void OnFriendListRemovedDelegate(Linphone.Core core, Linphone.FriendList friendList);
		private OnFriendListRemovedDelegatePrivate on_friend_list_removed_private;
		private OnFriendListRemovedDelegate on_friend_list_removed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFriendListRemovedDelegatePrivate))]
#endif
		private static void on_friend_list_removed(IntPtr core, IntPtr friendList)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_friend_list_removed_public?.Invoke(thiz, fromNativePtr<Linphone.FriendList>(friendList));
			}
		}

		public OnFriendListRemovedDelegate OnFriendListRemoved
		{
			get
			{
				return on_friend_list_removed_public;
			}
			set
			{
				on_friend_list_removed_public = value;
				on_friend_list_removed_private = on_friend_list_removed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_friend_list_removed_private);
				linphone_core_cbs_set_friend_list_removed(nativePtr, cb);
#else
				linphone_core_cbs_set_friend_list_removed(nativePtr, on_friend_list_removed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_call_created(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_call_created(IntPtr thiz, OnCallCreatedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnCallCreatedDelegatePrivate(IntPtr core, IntPtr call);

		/// <summary>
		/// Callback notifying that a new <see cref="Linphone.Call">Linphone.Call</see>
		/// (either incoming or outgoing) has been created. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object that
		/// has created the call    </param>
		/// <param name="call">The newly created <see cref="Linphone.Call">
		/// Linphone.Call</see> object    </param>
		public delegate void OnCallCreatedDelegate(Linphone.Core core, Linphone.Call call);
		private OnCallCreatedDelegatePrivate on_call_created_private;
		private OnCallCreatedDelegate on_call_created_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnCallCreatedDelegatePrivate))]
#endif
		private static void on_call_created(IntPtr core, IntPtr call)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_call_created_public?.Invoke(thiz, fromNativePtr<Linphone.Call>(call));
			}
		}

		public OnCallCreatedDelegate OnCallCreated
		{
			get
			{
				return on_call_created_public;
			}
			set
			{
				on_call_created_public = value;
				on_call_created_private = on_call_created;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_call_created_private);
				linphone_core_cbs_set_call_created(nativePtr, cb);
#else
				linphone_core_cbs_set_call_created(nativePtr, on_call_created_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_version_update_check_result_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_version_update_check_result_received(IntPtr thiz, OnVersionUpdateCheckResultReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnVersionUpdateCheckResultReceivedDelegatePrivate(IntPtr core, int result, IntPtr version, IntPtr url);

		/// <summary>
		/// Callback prototype for reporting the result of a version update check. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="result">The result of the version update check    </param>
		/// <param name="version">The version to update to    </param>
		/// <param name="url">The url where to download the new version if the result is
		/// #LinphoneVersionUpdateCheckNewVersionAvailable    </param>
		public delegate void OnVersionUpdateCheckResultReceivedDelegate(Linphone.Core core, Linphone.VersionUpdateCheckResult result, string version, string url);
		private OnVersionUpdateCheckResultReceivedDelegatePrivate on_version_update_check_result_received_private;
		private OnVersionUpdateCheckResultReceivedDelegate on_version_update_check_result_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnVersionUpdateCheckResultReceivedDelegatePrivate))]
#endif
		private static void on_version_update_check_result_received(IntPtr core, int result, IntPtr version, IntPtr url)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_version_update_check_result_received_public?.Invoke(thiz, (Linphone.VersionUpdateCheckResult)result, PtrToStringSafe(version), PtrToStringSafe(url));
			}
		}

		public OnVersionUpdateCheckResultReceivedDelegate OnVersionUpdateCheckResultReceived
		{
			get
			{
				return on_version_update_check_result_received_public;
			}
			set
			{
				on_version_update_check_result_received_public = value;
				on_version_update_check_result_received_private = on_version_update_check_result_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_version_update_check_result_received_private);
				linphone_core_cbs_set_version_update_check_result_received(nativePtr, cb);
#else
				linphone_core_cbs_set_version_update_check_result_received(nativePtr, on_version_update_check_result_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_conference_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_conference_state_changed(IntPtr thiz, OnConferenceStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnConferenceStateChangedDelegatePrivate(IntPtr core, IntPtr conference, int state);

		/// <summary>
		/// Callback prototype telling that a <see cref="Linphone.Conference">
		/// Linphone.Conference</see> state has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="conference">The <see cref="Linphone.Conference">
		/// Linphone.Conference</see> object for which the state has changed    </param>
		/// <param name="state">the current <see cref="Linphone.ChatRoomState">
		/// Linphone.ChatRoomState</see> </param>
		public delegate void OnConferenceStateChangedDelegate(Linphone.Core core, Linphone.Conference conference, Linphone.ConferenceState state);
		private OnConferenceStateChangedDelegatePrivate on_conference_state_changed_private;
		private OnConferenceStateChangedDelegate on_conference_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnConferenceStateChangedDelegatePrivate))]
#endif
		private static void on_conference_state_changed(IntPtr core, IntPtr conference, int state)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_conference_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Conference>(conference), (Linphone.ConferenceState)state);
			}
		}

		public OnConferenceStateChangedDelegate OnConferenceStateChanged
		{
			get
			{
				return on_conference_state_changed_public;
			}
			set
			{
				on_conference_state_changed_public = value;
				on_conference_state_changed_private = on_conference_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_conference_state_changed_private);
				linphone_core_cbs_set_conference_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_conference_state_changed(nativePtr, on_conference_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_chat_room_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_chat_room_state_changed(IntPtr thiz, OnChatRoomStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatRoomStateChangedDelegatePrivate(IntPtr core, IntPtr chatRoom, int state);

		/// <summary>
		/// Callback prototype telling that a <see cref="Linphone.ChatRoom">
		/// Linphone.ChatRoom</see> state has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="chatRoom">The <see cref="Linphone.ChatRoom">
		/// Linphone.ChatRoom</see> object for which the state has changed    </param>
		/// <param name="state">the current <see cref="Linphone.ChatRoomState">
		/// Linphone.ChatRoomState</see> </param>
		public delegate void OnChatRoomStateChangedDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom, Linphone.ChatRoomState state);
		private OnChatRoomStateChangedDelegatePrivate on_chat_room_state_changed_private;
		private OnChatRoomStateChangedDelegate on_chat_room_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatRoomStateChangedDelegatePrivate))]
#endif
		private static void on_chat_room_state_changed(IntPtr core, IntPtr chatRoom, int state)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_chat_room_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom), (Linphone.ChatRoomState)state);
			}
		}

		public OnChatRoomStateChangedDelegate OnChatRoomStateChanged
		{
			get
			{
				return on_chat_room_state_changed_public;
			}
			set
			{
				on_chat_room_state_changed_public = value;
				on_chat_room_state_changed_private = on_chat_room_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_room_state_changed_private);
				linphone_core_cbs_set_chat_room_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_chat_room_state_changed(nativePtr, on_chat_room_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_chat_room_subject_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_chat_room_subject_changed(IntPtr thiz, OnChatRoomSubjectChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatRoomSubjectChangedDelegatePrivate(IntPtr core, IntPtr chatRoom);

		/// <summary>
		/// Callback prototype telling that a <see cref="Linphone.ChatRoom">
		/// Linphone.ChatRoom</see> subject has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="chatRoom">The <see cref="Linphone.ChatRoom">
		/// Linphone.ChatRoom</see> object for which the subject has changed    </param>
		public delegate void OnChatRoomSubjectChangedDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom);
		private OnChatRoomSubjectChangedDelegatePrivate on_chat_room_subject_changed_private;
		private OnChatRoomSubjectChangedDelegate on_chat_room_subject_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatRoomSubjectChangedDelegatePrivate))]
#endif
		private static void on_chat_room_subject_changed(IntPtr core, IntPtr chatRoom)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_chat_room_subject_changed_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom));
			}
		}

		public OnChatRoomSubjectChangedDelegate OnChatRoomSubjectChanged
		{
			get
			{
				return on_chat_room_subject_changed_public;
			}
			set
			{
				on_chat_room_subject_changed_public = value;
				on_chat_room_subject_changed_private = on_chat_room_subject_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_room_subject_changed_private);
				linphone_core_cbs_set_chat_room_subject_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_chat_room_subject_changed(nativePtr, on_chat_room_subject_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_chat_room_ephemeral_message_deleted(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_chat_room_ephemeral_message_deleted(IntPtr thiz, OnChatRoomEphemeralMessageDeletedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnChatRoomEphemeralMessageDeletedDelegatePrivate(IntPtr core, IntPtr chatRoom);

		/// <summary>
		/// Callback prototype telling that a <see cref="Linphone.ChatRoom">
		/// Linphone.ChatRoom</see> ephemeral message has expired. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="chatRoom">The <see cref="Linphone.ChatRoom">
		/// Linphone.ChatRoom</see> object for which a message has expired.    </param>
		public delegate void OnChatRoomEphemeralMessageDeletedDelegate(Linphone.Core core, Linphone.ChatRoom chatRoom);
		private OnChatRoomEphemeralMessageDeletedDelegatePrivate on_chat_room_ephemeral_message_deleted_private;
		private OnChatRoomEphemeralMessageDeletedDelegate on_chat_room_ephemeral_message_deleted_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnChatRoomEphemeralMessageDeletedDelegatePrivate))]
#endif
		private static void on_chat_room_ephemeral_message_deleted(IntPtr core, IntPtr chatRoom)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_chat_room_ephemeral_message_deleted_public?.Invoke(thiz, fromNativePtr<Linphone.ChatRoom>(chatRoom));
			}
		}

		public OnChatRoomEphemeralMessageDeletedDelegate OnChatRoomEphemeralMessageDeleted
		{
			get
			{
				return on_chat_room_ephemeral_message_deleted_public;
			}
			set
			{
				on_chat_room_ephemeral_message_deleted_public = value;
				on_chat_room_ephemeral_message_deleted_private = on_chat_room_ephemeral_message_deleted;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_chat_room_ephemeral_message_deleted_private);
				linphone_core_cbs_set_chat_room_ephemeral_message_deleted(nativePtr, cb);
#else
				linphone_core_cbs_set_chat_room_ephemeral_message_deleted(nativePtr, on_chat_room_ephemeral_message_deleted_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_imee_user_registration(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_imee_user_registration(IntPtr thiz, OnImeeUserRegistrationDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnImeeUserRegistrationDelegatePrivate(IntPtr core, char status, IntPtr userId, IntPtr info);

		/// <summary>
		/// Callback prototype telling that an Instant Message Encryption Engine user
		/// registered on the server with or without success. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="status">the return status of the registration action. </param>
		/// <param name="userId">the userId published on the encryption engine server   
		/// </param>
		/// <param name="info">information about failure    </param>
		public delegate void OnImeeUserRegistrationDelegate(Linphone.Core core, bool status, string userId, string info);
		private OnImeeUserRegistrationDelegatePrivate on_imee_user_registration_private;
		private OnImeeUserRegistrationDelegate on_imee_user_registration_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnImeeUserRegistrationDelegatePrivate))]
#endif
		private static void on_imee_user_registration(IntPtr core, char status, IntPtr userId, IntPtr info)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_imee_user_registration_public?.Invoke(thiz, status == 0, PtrToStringSafe(userId), PtrToStringSafe(info));
			}
		}

		public OnImeeUserRegistrationDelegate OnImeeUserRegistration
		{
			get
			{
				return on_imee_user_registration_public;
			}
			set
			{
				on_imee_user_registration_public = value;
				on_imee_user_registration_private = on_imee_user_registration;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_imee_user_registration_private);
				linphone_core_cbs_set_imee_user_registration(nativePtr, cb);
#else
				linphone_core_cbs_set_imee_user_registration(nativePtr, on_imee_user_registration_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_qrcode_found(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_qrcode_found(IntPtr thiz, OnQrcodeFoundDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnQrcodeFoundDelegatePrivate(IntPtr core, IntPtr result);

		/// <summary>
		/// Callback prototype telling the result of decoded qrcode. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="result">The result of the decoded qrcode    </param>
		public delegate void OnQrcodeFoundDelegate(Linphone.Core core, string result);
		private OnQrcodeFoundDelegatePrivate on_qrcode_found_private;
		private OnQrcodeFoundDelegate on_qrcode_found_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnQrcodeFoundDelegatePrivate))]
#endif
		private static void on_qrcode_found(IntPtr core, IntPtr result)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_qrcode_found_public?.Invoke(thiz, PtrToStringSafe(result));
			}
		}

		public OnQrcodeFoundDelegate OnQrcodeFound
		{
			get
			{
				return on_qrcode_found_public;
			}
			set
			{
				on_qrcode_found_public = value;
				on_qrcode_found_private = on_qrcode_found;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_qrcode_found_private);
				linphone_core_cbs_set_qrcode_found(nativePtr, cb);
#else
				linphone_core_cbs_set_qrcode_found(nativePtr, on_qrcode_found_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_first_call_started(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_first_call_started(IntPtr thiz, OnFirstCallStartedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnFirstCallStartedDelegatePrivate(IntPtr core);

		/// <summary>
		/// Callback prototype telling a call has started (incoming or outgoing) while
		/// there was no other call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		public delegate void OnFirstCallStartedDelegate(Linphone.Core core);
		private OnFirstCallStartedDelegatePrivate on_first_call_started_private;
		private OnFirstCallStartedDelegate on_first_call_started_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnFirstCallStartedDelegatePrivate))]
#endif
		private static void on_first_call_started(IntPtr core)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_first_call_started_public?.Invoke(thiz);
			}
		}

		public OnFirstCallStartedDelegate OnFirstCallStarted
		{
			get
			{
				return on_first_call_started_public;
			}
			set
			{
				on_first_call_started_public = value;
				on_first_call_started_private = on_first_call_started;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_first_call_started_private);
				linphone_core_cbs_set_first_call_started(nativePtr, cb);
#else
				linphone_core_cbs_set_first_call_started(nativePtr, on_first_call_started_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_last_call_ended(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_last_call_ended(IntPtr thiz, OnLastCallEndedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLastCallEndedDelegatePrivate(IntPtr core);

		/// <summary>
		/// Callback prototype telling the last call has ended (<see cref="Linphone.Core.CallsNb">
		/// Linphone.Core.CallsNb</see> returns 0) 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		public delegate void OnLastCallEndedDelegate(Linphone.Core core);
		private OnLastCallEndedDelegatePrivate on_last_call_ended_private;
		private OnLastCallEndedDelegate on_last_call_ended_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnLastCallEndedDelegatePrivate))]
#endif
		private static void on_last_call_ended(IntPtr core)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_last_call_ended_public?.Invoke(thiz);
			}
		}

		public OnLastCallEndedDelegate OnLastCallEnded
		{
			get
			{
				return on_last_call_ended_public;
			}
			set
			{
				on_last_call_ended_public = value;
				on_last_call_ended_private = on_last_call_ended;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_last_call_ended_private);
				linphone_core_cbs_set_last_call_ended(nativePtr, cb);
#else
				linphone_core_cbs_set_last_call_ended(nativePtr, on_last_call_ended_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_audio_device_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_audio_device_changed(IntPtr thiz, OnAudioDeviceChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAudioDeviceChangedDelegatePrivate(IntPtr core, IntPtr audioDevice);

		/// <summary>
		/// Callback prototype telling that the audio device for at least one call has
		/// changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="audioDevice">the newly used <see cref="Linphone.AudioDevice">
		/// Linphone.AudioDevice</see> object    </param>
		public delegate void OnAudioDeviceChangedDelegate(Linphone.Core core, Linphone.AudioDevice audioDevice);
		private OnAudioDeviceChangedDelegatePrivate on_audio_device_changed_private;
		private OnAudioDeviceChangedDelegate on_audio_device_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAudioDeviceChangedDelegatePrivate))]
#endif
		private static void on_audio_device_changed(IntPtr core, IntPtr audioDevice)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_audio_device_changed_public?.Invoke(thiz, fromNativePtr<Linphone.AudioDevice>(audioDevice));
			}
		}

		public OnAudioDeviceChangedDelegate OnAudioDeviceChanged
		{
			get
			{
				return on_audio_device_changed_public;
			}
			set
			{
				on_audio_device_changed_public = value;
				on_audio_device_changed_private = on_audio_device_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_audio_device_changed_private);
				linphone_core_cbs_set_audio_device_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_audio_device_changed(nativePtr, on_audio_device_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_audio_devices_list_updated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_audio_devices_list_updated(IntPtr thiz, OnAudioDevicesListUpdatedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAudioDevicesListUpdatedDelegatePrivate(IntPtr core);

		/// <summary>
		/// Callback prototype telling the audio devices list has been updated. 
		/// <para>
		/// Either a new device is available or a previously available device isn&apos;t
		/// anymore. You can call <see cref="Linphone.Core.AudioDevices">
		/// Linphone.Core.AudioDevices</see> to get the new list. 
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		public delegate void OnAudioDevicesListUpdatedDelegate(Linphone.Core core);
		private OnAudioDevicesListUpdatedDelegatePrivate on_audio_devices_list_updated_private;
		private OnAudioDevicesListUpdatedDelegate on_audio_devices_list_updated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAudioDevicesListUpdatedDelegatePrivate))]
#endif
		private static void on_audio_devices_list_updated(IntPtr core)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_audio_devices_list_updated_public?.Invoke(thiz);
			}
		}

		public OnAudioDevicesListUpdatedDelegate OnAudioDevicesListUpdated
		{
			get
			{
				return on_audio_devices_list_updated_public;
			}
			set
			{
				on_audio_devices_list_updated_public = value;
				on_audio_devices_list_updated_private = on_audio_devices_list_updated;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_audio_devices_list_updated_private);
				linphone_core_cbs_set_audio_devices_list_updated(nativePtr, cb);
#else
				linphone_core_cbs_set_audio_devices_list_updated(nativePtr, on_audio_devices_list_updated_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_ec_calibration_result(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_ec_calibration_result(IntPtr thiz, OnEcCalibrationResultDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEcCalibrationResultDelegatePrivate(IntPtr core, int status, int delayMs);

		/// <summary>
		/// Function prototype used by linphone_core_cbs_set_ec_calibration_result. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">The <see cref="Linphone.Core">Linphone.Core</see>.   
		/// </param>
		/// <param name="status">The <see cref="Linphone.EcCalibratorStatus">
		/// Linphone.EcCalibratorStatus</see> of the calibrator. </param>
		/// <param name="delayMs">The measured delay if available. </param>
		public delegate void OnEcCalibrationResultDelegate(Linphone.Core core, Linphone.EcCalibratorStatus status, int delayMs);
		private OnEcCalibrationResultDelegatePrivate on_ec_calibration_result_private;
		private OnEcCalibrationResultDelegate on_ec_calibration_result_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEcCalibrationResultDelegatePrivate))]
#endif
		private static void on_ec_calibration_result(IntPtr core, int status, int delayMs)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_ec_calibration_result_public?.Invoke(thiz, (Linphone.EcCalibratorStatus)status, delayMs);
			}
		}

		public OnEcCalibrationResultDelegate OnEcCalibrationResult
		{
			get
			{
				return on_ec_calibration_result_public;
			}
			set
			{
				on_ec_calibration_result_public = value;
				on_ec_calibration_result_private = on_ec_calibration_result;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ec_calibration_result_private);
				linphone_core_cbs_set_ec_calibration_result(nativePtr, cb);
#else
				linphone_core_cbs_set_ec_calibration_result(nativePtr, on_ec_calibration_result_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_ec_calibration_audio_init(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_ec_calibration_audio_init(IntPtr thiz, OnEcCalibrationAudioInitDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEcCalibrationAudioInitDelegatePrivate(IntPtr core);

		/// <summary>
		/// Function prototype used by linphone_core_cbs_set_ec_calibration_audio_init. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">The <see cref="Linphone.Core">Linphone.Core</see>.   
		/// </param>
		public delegate void OnEcCalibrationAudioInitDelegate(Linphone.Core core);
		private OnEcCalibrationAudioInitDelegatePrivate on_ec_calibration_audio_init_private;
		private OnEcCalibrationAudioInitDelegate on_ec_calibration_audio_init_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEcCalibrationAudioInitDelegatePrivate))]
#endif
		private static void on_ec_calibration_audio_init(IntPtr core)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_ec_calibration_audio_init_public?.Invoke(thiz);
			}
		}

		public OnEcCalibrationAudioInitDelegate OnEcCalibrationAudioInit
		{
			get
			{
				return on_ec_calibration_audio_init_public;
			}
			set
			{
				on_ec_calibration_audio_init_public = value;
				on_ec_calibration_audio_init_private = on_ec_calibration_audio_init;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ec_calibration_audio_init_private);
				linphone_core_cbs_set_ec_calibration_audio_init(nativePtr, cb);
#else
				linphone_core_cbs_set_ec_calibration_audio_init(nativePtr, on_ec_calibration_audio_init_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_ec_calibration_audio_uninit(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_ec_calibration_audio_uninit(IntPtr thiz, OnEcCalibrationAudioUninitDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEcCalibrationAudioUninitDelegatePrivate(IntPtr core);

		/// <summary>
		/// Function prototype used by linphone_core_cbs_set_ec_calibration_audio_uninit. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">The <see cref="Linphone.Core">Linphone.Core</see>.   
		/// </param>
		public delegate void OnEcCalibrationAudioUninitDelegate(Linphone.Core core);
		private OnEcCalibrationAudioUninitDelegatePrivate on_ec_calibration_audio_uninit_private;
		private OnEcCalibrationAudioUninitDelegate on_ec_calibration_audio_uninit_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEcCalibrationAudioUninitDelegatePrivate))]
#endif
		private static void on_ec_calibration_audio_uninit(IntPtr core)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_ec_calibration_audio_uninit_public?.Invoke(thiz);
			}
		}

		public OnEcCalibrationAudioUninitDelegate OnEcCalibrationAudioUninit
		{
			get
			{
				return on_ec_calibration_audio_uninit_public;
			}
			set
			{
				on_ec_calibration_audio_uninit_public = value;
				on_ec_calibration_audio_uninit_private = on_ec_calibration_audio_uninit;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ec_calibration_audio_uninit_private);
				linphone_core_cbs_set_ec_calibration_audio_uninit(nativePtr, cb);
#else
				linphone_core_cbs_set_ec_calibration_audio_uninit(nativePtr, on_ec_calibration_audio_uninit_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_account_registration_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_account_registration_state_changed(IntPtr thiz, OnAccountRegistrationStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAccountRegistrationStateChangedDelegatePrivate(IntPtr core, IntPtr account, int state, IntPtr message);

		/// <summary>
		/// Callback notifying that a <see cref="Linphone.Account">Linphone.Account</see>
		/// has its registration state changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">The <see cref="Linphone.Core">Linphone.Core</see> object.   
		/// </param>
		/// <param name="account">The <see cref="Linphone.Account">Linphone.Account</see>
		/// object which has its registration changed.    </param>
		/// <param name="state">The new <see cref="Linphone.RegistrationState">
		/// Linphone.RegistrationState</see> for this account. </param>
		/// <param name="message">a non null informational message about the state   
		/// </param>
		public delegate void OnAccountRegistrationStateChangedDelegate(Linphone.Core core, Linphone.Account account, Linphone.RegistrationState state, string message);
		private OnAccountRegistrationStateChangedDelegatePrivate on_account_registration_state_changed_private;
		private OnAccountRegistrationStateChangedDelegate on_account_registration_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAccountRegistrationStateChangedDelegatePrivate))]
#endif
		private static void on_account_registration_state_changed(IntPtr core, IntPtr account, int state, IntPtr message)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_account_registration_state_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Account>(account), (Linphone.RegistrationState)state, PtrToStringSafe(message));
			}
		}

		public OnAccountRegistrationStateChangedDelegate OnAccountRegistrationStateChanged
		{
			get
			{
				return on_account_registration_state_changed_public;
			}
			set
			{
				on_account_registration_state_changed_public = value;
				on_account_registration_state_changed_private = on_account_registration_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_account_registration_state_changed_private);
				linphone_core_cbs_set_account_registration_state_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_account_registration_state_changed(nativePtr, on_account_registration_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_default_account_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_default_account_changed(IntPtr thiz, OnDefaultAccountChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnDefaultAccountChangedDelegatePrivate(IntPtr core, IntPtr account);

		/// <summary>
		/// Default account changed callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="account"><see cref="Linphone.Account">Linphone.Account</see>
		/// object that has been set as the default account, probably by calling <see cref="Linphone.Core.DefaultAccount">
		/// Linphone.Core.DefaultAccount</see>, or null if the default account was removed.
		///    </param>
		public delegate void OnDefaultAccountChangedDelegate(Linphone.Core core, Linphone.Account account);
		private OnDefaultAccountChangedDelegatePrivate on_default_account_changed_private;
		private OnDefaultAccountChangedDelegate on_default_account_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnDefaultAccountChangedDelegatePrivate))]
#endif
		private static void on_default_account_changed(IntPtr core, IntPtr account)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_default_account_changed_public?.Invoke(thiz, fromNativePtr<Linphone.Account>(account));
			}
		}

		public OnDefaultAccountChangedDelegate OnDefaultAccountChanged
		{
			get
			{
				return on_default_account_changed_public;
			}
			set
			{
				on_default_account_changed_public = value;
				on_default_account_changed_private = on_default_account_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_default_account_changed_private);
				linphone_core_cbs_set_default_account_changed(nativePtr, cb);
#else
				linphone_core_cbs_set_default_account_changed(nativePtr, on_default_account_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_account_added(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_account_added(IntPtr thiz, OnAccountAddedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAccountAddedDelegatePrivate(IntPtr core, IntPtr account);

		/// <summary>
		/// Account added callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="account"><see cref="Linphone.Account">Linphone.Account</see>
		/// object that has been added to the Core using <see cref="Linphone.Core.AddAccount()">
		/// Linphone.Core.AddAccount()</see> for example.    </param>
		public delegate void OnAccountAddedDelegate(Linphone.Core core, Linphone.Account account);
		private OnAccountAddedDelegatePrivate on_account_added_private;
		private OnAccountAddedDelegate on_account_added_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAccountAddedDelegatePrivate))]
#endif
		private static void on_account_added(IntPtr core, IntPtr account)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_account_added_public?.Invoke(thiz, fromNativePtr<Linphone.Account>(account));
			}
		}

		public OnAccountAddedDelegate OnAccountAdded
		{
			get
			{
				return on_account_added_public;
			}
			set
			{
				on_account_added_public = value;
				on_account_added_private = on_account_added;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_account_added_private);
				linphone_core_cbs_set_account_added(nativePtr, cb);
#else
				linphone_core_cbs_set_account_added(nativePtr, on_account_added_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_core_cbs_set_account_removed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_core_cbs_set_account_removed(IntPtr thiz, OnAccountRemovedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnAccountRemovedDelegatePrivate(IntPtr core, IntPtr account);

		/// <summary>
		/// Account removed callback prototype. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core"><see cref="Linphone.Core">Linphone.Core</see> object   
		/// </param>
		/// <param name="account"><see cref="Linphone.Account">Linphone.Account</see>
		/// object that has been added to the Core using <see cref="Linphone.Core.RemoveAccount()">
		/// Linphone.Core.RemoveAccount()</see> for example.    </param>
		public delegate void OnAccountRemovedDelegate(Linphone.Core core, Linphone.Account account);
		private OnAccountRemovedDelegatePrivate on_account_removed_private;
		private OnAccountRemovedDelegate on_account_removed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnAccountRemovedDelegatePrivate))]
#endif
		private static void on_account_removed(IntPtr core, IntPtr account)
		{
			Core thiz = fromNativePtr<Core>(core);

			IntPtr ptr = linphone_core_get_current_callbacks(thiz.nativePtr);
			CoreListener current_listener = fromNativePtr<CoreListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_account_removed_public?.Invoke(thiz, fromNativePtr<Linphone.Account>(account));
			}
		}

		public OnAccountRemovedDelegate OnAccountRemoved
		{
			get
			{
				return on_account_removed_public;
			}
			set
			{
				on_account_removed_public = value;
				on_account_removed_private = on_account_removed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_account_removed_private);
				linphone_core_cbs_set_account_removed(nativePtr, cb);
#else
				linphone_core_cbs_set_account_removed(nativePtr, on_account_removed_private);
#endif
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for handling the LinphoneEvent operations. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class EventListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_event_cbs_set_notify_response(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_event_cbs_set_notify_response(IntPtr thiz, OnNotifyResponseDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnNotifyResponseDelegatePrivate(IntPtr linphoneEvent);

		/// <summary>
		/// Callback used to notify the response to a sent NOTIFY. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="linphoneEvent">The <see cref="Linphone.Event">Linphone.Event</see>
		/// object that has sent the NOTIFY and for which we received a response    </param>
		public delegate void OnNotifyResponseDelegate(Linphone.Event linphoneEvent);
		private OnNotifyResponseDelegatePrivate on_notify_response_private;
		private OnNotifyResponseDelegate on_notify_response_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnNotifyResponseDelegatePrivate))]
#endif
		private static void on_notify_response(IntPtr linphoneEvent)
		{
			Event thiz = fromNativePtr<Event>(linphoneEvent);

			IntPtr ptr = linphone_event_get_current_callbacks(thiz.nativePtr);
			EventListener current_listener = fromNativePtr<EventListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_notify_response_public?.Invoke(thiz);
			}
		}

		public OnNotifyResponseDelegate OnNotifyResponse
		{
			get
			{
				return on_notify_response_public;
			}
			set
			{
				on_notify_response_public = value;
				on_notify_response_private = on_notify_response;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_notify_response_private);
				linphone_event_cbs_set_notify_response(nativePtr, cb);
#else
				linphone_event_cbs_set_notify_response(nativePtr, on_notify_response_private);
#endif
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for <see cref="Linphone.Friend">
	/// Linphone.Friend</see>. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class FriendListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_friend_cbs_set_presence_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_friend_cbs_set_presence_received(IntPtr thiz, OnPresenceReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnPresenceReceivedDelegatePrivate(IntPtr linphoneFriend);

		/// <summary>
		/// Callback used to notify a friend that it has received presence information. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="linphoneFriend">The <see cref="Linphone.Friend">
		/// Linphone.Friend</see> object for which the status has changed    </param>
		public delegate void OnPresenceReceivedDelegate(Linphone.Friend linphoneFriend);
		private OnPresenceReceivedDelegatePrivate on_presence_received_private;
		private OnPresenceReceivedDelegate on_presence_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnPresenceReceivedDelegatePrivate))]
#endif
		private static void on_presence_received(IntPtr linphoneFriend)
		{
			Friend thiz = fromNativePtr<Friend>(linphoneFriend);

			IntPtr ptr = linphone_friend_get_current_callbacks(thiz.nativePtr);
			FriendListener current_listener = fromNativePtr<FriendListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_presence_received_public?.Invoke(thiz);
			}
		}

		public OnPresenceReceivedDelegate OnPresenceReceived
		{
			get
			{
				return on_presence_received_public;
			}
			set
			{
				on_presence_received_public = value;
				on_presence_received_private = on_presence_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_presence_received_private);
				linphone_friend_cbs_set_presence_received(nativePtr, cb);
#else
				linphone_friend_cbs_set_presence_received(nativePtr, on_presence_received_private);
#endif
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for <see cref="Linphone.Friend">
	/// Linphone.Friend</see> synchronization. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class FriendListListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_friend_list_cbs_set_contact_created(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_friend_list_cbs_set_contact_created(IntPtr thiz, OnContactCreatedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnContactCreatedDelegatePrivate(IntPtr friendList, IntPtr linphoneFriend);

		/// <summary>
		/// Callback used to notify a new contact has been created on the CardDAV server
		/// and downloaded locally. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="friendList">The <see cref="Linphone.FriendList">
		/// Linphone.FriendList</see> object the new contact is added to    </param>
		/// <param name="linphoneFriend">The <see cref="Linphone.Friend">
		/// Linphone.Friend</see> object that has been created    </param>
		public delegate void OnContactCreatedDelegate(Linphone.FriendList friendList, Linphone.Friend linphoneFriend);
		private OnContactCreatedDelegatePrivate on_contact_created_private;
		private OnContactCreatedDelegate on_contact_created_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnContactCreatedDelegatePrivate))]
#endif
		private static void on_contact_created(IntPtr friendList, IntPtr linphoneFriend)
		{
			FriendList thiz = fromNativePtr<FriendList>(friendList);

			IntPtr ptr = linphone_friend_list_get_current_callbacks(thiz.nativePtr);
			FriendListListener current_listener = fromNativePtr<FriendListListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_contact_created_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(linphoneFriend));
			}
		}

		public OnContactCreatedDelegate OnContactCreated
		{
			get
			{
				return on_contact_created_public;
			}
			set
			{
				on_contact_created_public = value;
				on_contact_created_private = on_contact_created;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_contact_created_private);
				linphone_friend_list_cbs_set_contact_created(nativePtr, cb);
#else
				linphone_friend_list_cbs_set_contact_created(nativePtr, on_contact_created_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_friend_list_cbs_set_contact_deleted(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_friend_list_cbs_set_contact_deleted(IntPtr thiz, OnContactDeletedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnContactDeletedDelegatePrivate(IntPtr friendList, IntPtr linphoneFriend);

		/// <summary>
		/// Callback used to notify a contact has been deleted on the CardDAV server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="friendList">The <see cref="Linphone.FriendList">
		/// Linphone.FriendList</see> object a contact has been removed from    </param>
		/// <param name="linphoneFriend">The <see cref="Linphone.Friend">
		/// Linphone.Friend</see> object that has been deleted    </param>
		public delegate void OnContactDeletedDelegate(Linphone.FriendList friendList, Linphone.Friend linphoneFriend);
		private OnContactDeletedDelegatePrivate on_contact_deleted_private;
		private OnContactDeletedDelegate on_contact_deleted_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnContactDeletedDelegatePrivate))]
#endif
		private static void on_contact_deleted(IntPtr friendList, IntPtr linphoneFriend)
		{
			FriendList thiz = fromNativePtr<FriendList>(friendList);

			IntPtr ptr = linphone_friend_list_get_current_callbacks(thiz.nativePtr);
			FriendListListener current_listener = fromNativePtr<FriendListListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_contact_deleted_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(linphoneFriend));
			}
		}

		public OnContactDeletedDelegate OnContactDeleted
		{
			get
			{
				return on_contact_deleted_public;
			}
			set
			{
				on_contact_deleted_public = value;
				on_contact_deleted_private = on_contact_deleted;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_contact_deleted_private);
				linphone_friend_list_cbs_set_contact_deleted(nativePtr, cb);
#else
				linphone_friend_list_cbs_set_contact_deleted(nativePtr, on_contact_deleted_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_friend_list_cbs_set_contact_updated(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_friend_list_cbs_set_contact_updated(IntPtr thiz, OnContactUpdatedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnContactUpdatedDelegatePrivate(IntPtr friendList, IntPtr newFriend, IntPtr oldFriend);

		/// <summary>
		/// Callback used to notify a contact has been updated on the CardDAV server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="friendList">The <see cref="Linphone.FriendList">
		/// Linphone.FriendList</see> object in which a contact has been updated    </param>
		/// <param name="newFriend">The new <see cref="Linphone.Friend">
		/// Linphone.Friend</see> object corresponding to the updated contact    </param>
		/// <param name="oldFriend">The old <see cref="Linphone.Friend">
		/// Linphone.Friend</see> object before update    </param>
		public delegate void OnContactUpdatedDelegate(Linphone.FriendList friendList, Linphone.Friend newFriend, Linphone.Friend oldFriend);
		private OnContactUpdatedDelegatePrivate on_contact_updated_private;
		private OnContactUpdatedDelegate on_contact_updated_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnContactUpdatedDelegatePrivate))]
#endif
		private static void on_contact_updated(IntPtr friendList, IntPtr newFriend, IntPtr oldFriend)
		{
			FriendList thiz = fromNativePtr<FriendList>(friendList);

			IntPtr ptr = linphone_friend_list_get_current_callbacks(thiz.nativePtr);
			FriendListListener current_listener = fromNativePtr<FriendListListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_contact_updated_public?.Invoke(thiz, fromNativePtr<Linphone.Friend>(newFriend), fromNativePtr<Linphone.Friend>(oldFriend));
			}
		}

		public OnContactUpdatedDelegate OnContactUpdated
		{
			get
			{
				return on_contact_updated_public;
			}
			set
			{
				on_contact_updated_public = value;
				on_contact_updated_private = on_contact_updated;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_contact_updated_private);
				linphone_friend_list_cbs_set_contact_updated(nativePtr, cb);
#else
				linphone_friend_list_cbs_set_contact_updated(nativePtr, on_contact_updated_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_friend_list_cbs_set_sync_status_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_friend_list_cbs_set_sync_status_changed(IntPtr thiz, OnSyncStatusChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSyncStatusChangedDelegatePrivate(IntPtr friendList, int status, IntPtr message);

		/// <summary>
		/// Callback used to notify the status of the synchronization has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="friendList">The <see cref="Linphone.FriendList">
		/// Linphone.FriendList</see> object for which the status has changed    </param>
		/// <param name="status">The new <see cref="Linphone.FriendListSyncStatus">
		/// Linphone.FriendListSyncStatus</see> </param>
		/// <param name="message">An additional information on the status update    </param>
		public delegate void OnSyncStatusChangedDelegate(Linphone.FriendList friendList, Linphone.FriendListSyncStatus status, string message);
		private OnSyncStatusChangedDelegatePrivate on_sync_status_changed_private;
		private OnSyncStatusChangedDelegate on_sync_status_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSyncStatusChangedDelegatePrivate))]
#endif
		private static void on_sync_status_changed(IntPtr friendList, int status, IntPtr message)
		{
			FriendList thiz = fromNativePtr<FriendList>(friendList);

			IntPtr ptr = linphone_friend_list_get_current_callbacks(thiz.nativePtr);
			FriendListListener current_listener = fromNativePtr<FriendListListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_sync_status_changed_public?.Invoke(thiz, (Linphone.FriendListSyncStatus)status, PtrToStringSafe(message));
			}
		}

		public OnSyncStatusChangedDelegate OnSyncStatusChanged
		{
			get
			{
				return on_sync_status_changed_public;
			}
			set
			{
				on_sync_status_changed_public = value;
				on_sync_status_changed_private = on_sync_status_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_sync_status_changed_private);
				linphone_friend_list_cbs_set_sync_status_changed(nativePtr, cb);
#else
				linphone_friend_list_cbs_set_sync_status_changed(nativePtr, on_sync_status_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_friend_list_cbs_set_presence_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_friend_list_cbs_set_presence_received(IntPtr thiz, OnPresenceReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnPresenceReceivedDelegatePrivate(IntPtr friendList, IntPtr friends);

		/// <summary>
		/// Callback used to notify a list with all friends that have received presence
		/// information. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="friendList">The LinphoneFriendList object for which the status has
		/// changed    </param>
		/// <param name="friends">A   of the relevant friends    </param>
		public delegate void OnPresenceReceivedDelegate(Linphone.FriendList friendList, IEnumerable<Linphone.Friend> friends);
		private OnPresenceReceivedDelegatePrivate on_presence_received_private;
		private OnPresenceReceivedDelegate on_presence_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnPresenceReceivedDelegatePrivate))]
#endif
		private static void on_presence_received(IntPtr friendList, IntPtr friends)
		{
			FriendList thiz = fromNativePtr<FriendList>(friendList);

			IntPtr ptr = linphone_friend_list_get_current_callbacks(thiz.nativePtr);
			FriendListListener current_listener = fromNativePtr<FriendListListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_presence_received_public?.Invoke(thiz, MarshalBctbxList<Linphone.Friend>(friends));
			}
		}

		public OnPresenceReceivedDelegate OnPresenceReceived
		{
			get
			{
				return on_presence_received_public;
			}
			set
			{
				on_presence_received_public = value;
				on_presence_received_private = on_presence_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_presence_received_private);
				linphone_friend_list_cbs_set_presence_received(nativePtr, cb);
#else
				linphone_friend_list_cbs_set_presence_received(nativePtr, on_presence_received_private);
#endif
			}
		}
	}

	/// <summary>
	/// Listener for <see cref="Linphone.LoggingService">Linphone.LoggingService</see>. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class LoggingServiceListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_logging_service_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_logging_service_cbs_set_log_message_written(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_logging_service_cbs_set_log_message_written(IntPtr thiz, OnLogMessageWrittenDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLogMessageWrittenDelegatePrivate(IntPtr logService, IntPtr domain, int level, IntPtr message);

		/// <summary>
		/// Type of callbacks called each time liblinphone write a log message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="logService">A pointer on the logging service singleton.    </param>
		/// <param name="domain">A string describing which sub-library of liblinphone the
		/// message is coming from.    </param>
		/// <param name="level">Verbosity <see cref="Linphone.LogLevel">
		/// Linphone.LogLevel</see> of the message. </param>
		/// <param name="message">Content of the message.    </param>
		public delegate void OnLogMessageWrittenDelegate(Linphone.LoggingService logService, string domain, Linphone.LogLevel level, string message);
		private OnLogMessageWrittenDelegatePrivate on_log_message_written_private;
		private OnLogMessageWrittenDelegate on_log_message_written_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnLogMessageWrittenDelegatePrivate))]
#endif
		private static void on_log_message_written(IntPtr logService, IntPtr domain, int level, IntPtr message)
		{
			LoggingService thiz = fromNativePtr<LoggingService>(logService);

			IntPtr ptr = linphone_logging_service_get_current_callbacks(thiz.nativePtr);
			LoggingServiceListener current_listener = fromNativePtr<LoggingServiceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_log_message_written_public?.Invoke(thiz, PtrToStringSafe(domain), (Linphone.LogLevel)level, PtrToStringSafe(message));
			}
		}

		public OnLogMessageWrittenDelegate OnLogMessageWritten
		{
			get
			{
				return on_log_message_written_public;
			}
			set
			{
				on_log_message_written_public = value;
				on_log_message_written_private = on_log_message_written;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_log_message_written_private);
				linphone_logging_service_cbs_set_log_message_written(nativePtr, cb);
#else
				linphone_logging_service_cbs_set_log_message_written(nativePtr, on_log_message_written_private);
#endif
			}
		}
	}

	/// <summary>
	/// A <see cref="Linphone.MagicSearchListener">Linphone.MagicSearchListener</see>
	/// is used to do specifics searchs. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class MagicSearchListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_magic_search_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_magic_search_cbs_set_search_results_received(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_magic_search_cbs_set_search_results_received(IntPtr thiz, OnSearchResultsReceivedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnSearchResultsReceivedDelegatePrivate(IntPtr magicSearch);

		/// <summary>
		/// Callback used to notify when results are received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="magicSearch"><see cref="Linphone.MagicSearch">
		/// Linphone.MagicSearch</see> object    </param>
		public delegate void OnSearchResultsReceivedDelegate(Linphone.MagicSearch magicSearch);
		private OnSearchResultsReceivedDelegatePrivate on_search_results_received_private;
		private OnSearchResultsReceivedDelegate on_search_results_received_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnSearchResultsReceivedDelegatePrivate))]
#endif
		private static void on_search_results_received(IntPtr magicSearch)
		{
			MagicSearch thiz = fromNativePtr<MagicSearch>(magicSearch);

			IntPtr ptr = linphone_magic_search_get_current_callbacks(thiz.nativePtr);
			MagicSearchListener current_listener = fromNativePtr<MagicSearchListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_search_results_received_public?.Invoke(thiz);
			}
		}

		public OnSearchResultsReceivedDelegate OnSearchResultsReceived
		{
			get
			{
				return on_search_results_received_public;
			}
			set
			{
				on_search_results_received_public = value;
				on_search_results_received_private = on_search_results_received;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_search_results_received_private);
				linphone_magic_search_cbs_set_search_results_received(nativePtr, cb);
#else
				linphone_magic_search_cbs_set_search_results_received(nativePtr, on_search_results_received_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_magic_search_cbs_set_ldap_have_more_results(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_magic_search_cbs_set_ldap_have_more_results(IntPtr thiz, OnLdapHaveMoreResultsDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnLdapHaveMoreResultsDelegatePrivate(IntPtr magicSearch, IntPtr ldap);

		/// <summary>
		/// Callback used to notify when LDAP have more results available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="magicSearch"><see cref="Linphone.MagicSearch">
		/// Linphone.MagicSearch</see> object    </param>
		/// <param name="ldap"><see cref="Linphone.Ldap">Linphone.Ldap</see> object   
		/// </param>
		public delegate void OnLdapHaveMoreResultsDelegate(Linphone.MagicSearch magicSearch, Linphone.Ldap ldap);
		private OnLdapHaveMoreResultsDelegatePrivate on_ldap_have_more_results_private;
		private OnLdapHaveMoreResultsDelegate on_ldap_have_more_results_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnLdapHaveMoreResultsDelegatePrivate))]
#endif
		private static void on_ldap_have_more_results(IntPtr magicSearch, IntPtr ldap)
		{
			MagicSearch thiz = fromNativePtr<MagicSearch>(magicSearch);

			IntPtr ptr = linphone_magic_search_get_current_callbacks(thiz.nativePtr);
			MagicSearchListener current_listener = fromNativePtr<MagicSearchListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_ldap_have_more_results_public?.Invoke(thiz, fromNativePtr<Linphone.Ldap>(ldap));
			}
		}

		public OnLdapHaveMoreResultsDelegate OnLdapHaveMoreResults
		{
			get
			{
				return on_ldap_have_more_results_public;
			}
			set
			{
				on_ldap_have_more_results_public = value;
				on_ldap_have_more_results_private = on_ldap_have_more_results;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_ldap_have_more_results_private);
				linphone_magic_search_cbs_set_ldap_have_more_results(nativePtr, cb);
#else
				linphone_magic_search_cbs_set_ldap_have_more_results(nativePtr, on_ldap_have_more_results_private);
#endif
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for the handling a <see cref="Linphone.ParticipantDevice">
	/// Linphone.ParticipantDevice</see> objects. 
	/// <para>
	/// Use <see cref="Linphone.Factory.CreateParticipantDeviceCbs()">
	/// Linphone.Factory.CreateParticipantDeviceCbs()</see> to create an instance. Then
	/// pass the object to a <see cref="Linphone.ParticipantDevice">
	/// Linphone.ParticipantDevice</see> instance through <see cref="Linphone.ParticipantDevice.AddListener()">
	/// Linphone.ParticipantDevice.AddListener()</see>. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ParticipantDeviceListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_participant_device_cbs_set_is_speaking_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_participant_device_cbs_set_is_speaking_changed(IntPtr thiz, OnIsSpeakingChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsSpeakingChangedDelegatePrivate(IntPtr participantDevice, char isSpeaking);

		/// <summary>
		/// Callback used to notify that is this participant device speaking has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participantDevice"><see cref="Linphone.ParticipantDevice">
		/// Linphone.ParticipantDevice</see> object    </param>
		/// <param name="isSpeaking">is this participant device speaking </param>
		public delegate void OnIsSpeakingChangedDelegate(Linphone.ParticipantDevice participantDevice, bool isSpeaking);
		private OnIsSpeakingChangedDelegatePrivate on_is_speaking_changed_private;
		private OnIsSpeakingChangedDelegate on_is_speaking_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsSpeakingChangedDelegatePrivate))]
#endif
		private static void on_is_speaking_changed(IntPtr participantDevice, char isSpeaking)
		{
			ParticipantDevice thiz = fromNativePtr<ParticipantDevice>(participantDevice);

			IntPtr ptr = linphone_participant_device_get_current_callbacks(thiz.nativePtr);
			ParticipantDeviceListener current_listener = fromNativePtr<ParticipantDeviceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_is_speaking_changed_public?.Invoke(thiz, isSpeaking == 0);
			}
		}

		public OnIsSpeakingChangedDelegate OnIsSpeakingChanged
		{
			get
			{
				return on_is_speaking_changed_public;
			}
			set
			{
				on_is_speaking_changed_public = value;
				on_is_speaking_changed_private = on_is_speaking_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_speaking_changed_private);
				linphone_participant_device_cbs_set_is_speaking_changed(nativePtr, cb);
#else
				linphone_participant_device_cbs_set_is_speaking_changed(nativePtr, on_is_speaking_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_participant_device_cbs_set_is_muted(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_participant_device_cbs_set_is_muted(IntPtr thiz, OnIsMutedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnIsMutedDelegatePrivate(IntPtr participantDevice, char isMuted);

		/// <summary>
		/// Callback used to notify that this participant device is muted or is no longer
		/// muted. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participantDevice"><see cref="Linphone.ParticipantDevice">
		/// Linphone.ParticipantDevice</see> object    </param>
		/// <param name="isMuted">is this participant device muted </param>
		public delegate void OnIsMutedDelegate(Linphone.ParticipantDevice participantDevice, bool isMuted);
		private OnIsMutedDelegatePrivate on_is_muted_private;
		private OnIsMutedDelegate on_is_muted_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnIsMutedDelegatePrivate))]
#endif
		private static void on_is_muted(IntPtr participantDevice, char isMuted)
		{
			ParticipantDevice thiz = fromNativePtr<ParticipantDevice>(participantDevice);

			IntPtr ptr = linphone_participant_device_get_current_callbacks(thiz.nativePtr);
			ParticipantDeviceListener current_listener = fromNativePtr<ParticipantDeviceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_is_muted_public?.Invoke(thiz, isMuted == 0);
			}
		}

		public OnIsMutedDelegate OnIsMuted
		{
			get
			{
				return on_is_muted_public;
			}
			set
			{
				on_is_muted_public = value;
				on_is_muted_private = on_is_muted;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_is_muted_private);
				linphone_participant_device_cbs_set_is_muted(nativePtr, cb);
#else
				linphone_participant_device_cbs_set_is_muted(nativePtr, on_is_muted_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_participant_device_cbs_set_state_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_participant_device_cbs_set_state_changed(IntPtr thiz, OnStateChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnStateChangedDelegatePrivate(IntPtr participantDevice, int state);

		/// <summary>
		/// Callback used to notify that participant device changed state. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participantDevice">LinphoneParticipantDevice object    </param>
		/// <param name="state">new participant device state </param>
		public delegate void OnStateChangedDelegate(Linphone.ParticipantDevice participantDevice, Linphone.ParticipantDeviceState state);
		private OnStateChangedDelegatePrivate on_state_changed_private;
		private OnStateChangedDelegate on_state_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnStateChangedDelegatePrivate))]
#endif
		private static void on_state_changed(IntPtr participantDevice, int state)
		{
			ParticipantDevice thiz = fromNativePtr<ParticipantDevice>(participantDevice);

			IntPtr ptr = linphone_participant_device_get_current_callbacks(thiz.nativePtr);
			ParticipantDeviceListener current_listener = fromNativePtr<ParticipantDeviceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_state_changed_public?.Invoke(thiz, (Linphone.ParticipantDeviceState)state);
			}
		}

		public OnStateChangedDelegate OnStateChanged
		{
			get
			{
				return on_state_changed_public;
			}
			set
			{
				on_state_changed_public = value;
				on_state_changed_private = on_state_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_state_changed_private);
				linphone_participant_device_cbs_set_state_changed(nativePtr, cb);
#else
				linphone_participant_device_cbs_set_state_changed(nativePtr, on_state_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_participant_device_cbs_set_stream_capability_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_participant_device_cbs_set_stream_capability_changed(IntPtr thiz, OnStreamCapabilityChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnStreamCapabilityChangedDelegatePrivate(IntPtr participantDevice, int direction, int streamType);

		/// <summary>
		/// Callback used to notify that participant device stream capability has changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participantDevice"><see cref="Linphone.ParticipantDevice">
		/// Linphone.ParticipantDevice</see> object    </param>
		/// <param name="direction">participant device&apos;s audio direction </param>
		/// <param name="streamType">type of the stream </param>
		public delegate void OnStreamCapabilityChangedDelegate(Linphone.ParticipantDevice participantDevice, Linphone.MediaDirection direction, Linphone.StreamType streamType);
		private OnStreamCapabilityChangedDelegatePrivate on_stream_capability_changed_private;
		private OnStreamCapabilityChangedDelegate on_stream_capability_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnStreamCapabilityChangedDelegatePrivate))]
#endif
		private static void on_stream_capability_changed(IntPtr participantDevice, int direction, int streamType)
		{
			ParticipantDevice thiz = fromNativePtr<ParticipantDevice>(participantDevice);

			IntPtr ptr = linphone_participant_device_get_current_callbacks(thiz.nativePtr);
			ParticipantDeviceListener current_listener = fromNativePtr<ParticipantDeviceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_stream_capability_changed_public?.Invoke(thiz, (Linphone.MediaDirection)direction, (Linphone.StreamType)streamType);
			}
		}

		public OnStreamCapabilityChangedDelegate OnStreamCapabilityChanged
		{
			get
			{
				return on_stream_capability_changed_public;
			}
			set
			{
				on_stream_capability_changed_public = value;
				on_stream_capability_changed_private = on_stream_capability_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_stream_capability_changed_private);
				linphone_participant_device_cbs_set_stream_capability_changed(nativePtr, cb);
#else
				linphone_participant_device_cbs_set_stream_capability_changed(nativePtr, on_stream_capability_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_participant_device_cbs_set_stream_availability_changed(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_participant_device_cbs_set_stream_availability_changed(IntPtr thiz, OnStreamAvailabilityChangedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnStreamAvailabilityChangedDelegatePrivate(IntPtr participantDevice, char available, int streamType);

		/// <summary>
		/// Callback used to notify that participant device stream availability has
		/// changed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participantDevice"><see cref="Linphone.ParticipantDevice">
		/// Linphone.ParticipantDevice</see> object    </param>
		/// <param name="available">true if the stream is available on our side </param>
		/// <param name="streamType">type of the stream </param>
		public delegate void OnStreamAvailabilityChangedDelegate(Linphone.ParticipantDevice participantDevice, bool available, Linphone.StreamType streamType);
		private OnStreamAvailabilityChangedDelegatePrivate on_stream_availability_changed_private;
		private OnStreamAvailabilityChangedDelegate on_stream_availability_changed_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnStreamAvailabilityChangedDelegatePrivate))]
#endif
		private static void on_stream_availability_changed(IntPtr participantDevice, char available, int streamType)
		{
			ParticipantDevice thiz = fromNativePtr<ParticipantDevice>(participantDevice);

			IntPtr ptr = linphone_participant_device_get_current_callbacks(thiz.nativePtr);
			ParticipantDeviceListener current_listener = fromNativePtr<ParticipantDeviceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_stream_availability_changed_public?.Invoke(thiz, available == 0, (Linphone.StreamType)streamType);
			}
		}

		public OnStreamAvailabilityChangedDelegate OnStreamAvailabilityChanged
		{
			get
			{
				return on_stream_availability_changed_public;
			}
			set
			{
				on_stream_availability_changed_public = value;
				on_stream_availability_changed_private = on_stream_availability_changed;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_stream_availability_changed_private);
				linphone_participant_device_cbs_set_stream_availability_changed(nativePtr, cb);
#else
				linphone_participant_device_cbs_set_stream_availability_changed(nativePtr, on_stream_availability_changed_private);
#endif
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_participant_device_cbs_set_video_display_error_occurred(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_participant_device_cbs_set_video_display_error_occurred(IntPtr thiz, OnVideoDisplayErrorOccurredDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnVideoDisplayErrorOccurredDelegatePrivate(IntPtr participantDevice, int errorCode);

		/// <summary>
		/// Callback to notify that there are errors from the video rendering of the
		/// participant device. 
		/// <para>
		/// Check LinphoneCallCbsVideoDisplayErrorOccurredCb for more details.
		/// </para>
		/// </summary>
		/// <param name="participantDevice">LinphoneParticipantDevice object    </param>
		/// <param name="errorCode">the error code coming from the display render. </param>
		public delegate void OnVideoDisplayErrorOccurredDelegate(Linphone.ParticipantDevice participantDevice, int errorCode);
		private OnVideoDisplayErrorOccurredDelegatePrivate on_video_display_error_occurred_private;
		private OnVideoDisplayErrorOccurredDelegate on_video_display_error_occurred_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnVideoDisplayErrorOccurredDelegatePrivate))]
#endif
		private static void on_video_display_error_occurred(IntPtr participantDevice, int errorCode)
		{
			ParticipantDevice thiz = fromNativePtr<ParticipantDevice>(participantDevice);

			IntPtr ptr = linphone_participant_device_get_current_callbacks(thiz.nativePtr);
			ParticipantDeviceListener current_listener = fromNativePtr<ParticipantDeviceListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_video_display_error_occurred_public?.Invoke(thiz, errorCode);
			}
		}

		public OnVideoDisplayErrorOccurredDelegate OnVideoDisplayErrorOccurred
		{
			get
			{
				return on_video_display_error_occurred_public;
			}
			set
			{
				on_video_display_error_occurred_public = value;
				on_video_display_error_occurred_private = on_video_display_error_occurred;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_video_display_error_occurred_private);
				linphone_participant_device_cbs_set_video_display_error_occurred(nativePtr, cb);
#else
				linphone_participant_device_cbs_set_video_display_error_occurred(nativePtr, on_video_display_error_occurred_private);
#endif
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for the handling a <see cref="Linphone.Player">
	/// Linphone.Player</see> objects. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PlayerListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_player_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_player_cbs_set_eof_reached(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_player_cbs_set_eof_reached(IntPtr thiz, OnEofReachedDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnEofReachedDelegatePrivate(IntPtr player);

		/// <summary>
		/// Callback for notifying end of play (file). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="player">The <see cref="Linphone.Player">Linphone.Player</see>
		/// object    </param>
		public delegate void OnEofReachedDelegate(Linphone.Player player);
		private OnEofReachedDelegatePrivate on_eof_reached_private;
		private OnEofReachedDelegate on_eof_reached_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnEofReachedDelegatePrivate))]
#endif
		private static void on_eof_reached(IntPtr player)
		{
			Player thiz = fromNativePtr<Player>(player);

			IntPtr ptr = linphone_player_get_current_callbacks(thiz.nativePtr);
			PlayerListener current_listener = fromNativePtr<PlayerListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_eof_reached_public?.Invoke(thiz);
			}
		}

		public OnEofReachedDelegate OnEofReached
		{
			get
			{
				return on_eof_reached_public;
			}
			set
			{
				on_eof_reached_public = value;
				on_eof_reached_private = on_eof_reached;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_eof_reached_private);
				linphone_player_cbs_set_eof_reached(nativePtr, cb);
#else
				linphone_player_cbs_set_eof_reached(nativePtr, on_eof_reached_private);
#endif
			}
		}
	}

	/// <summary>
	/// An object to handle the callbacks for handling the <see cref="Linphone.XmlRpcRequest">
	/// Linphone.XmlRpcRequest</see> operations. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class XmlRpcRequestListener : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_get_current_callbacks(IntPtr thiz);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
#if (_WIN32 || WINDOWS_UWP)
		static extern void linphone_xml_rpc_request_cbs_set_response(IntPtr thiz, IntPtr cb);
#else
		static extern void linphone_xml_rpc_request_cbs_set_response(IntPtr thiz, OnResponseDelegatePrivate cb);
#endif
		
		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
		private delegate void OnResponseDelegatePrivate(IntPtr request);

		/// <summary>
		/// Callback used to notify the response to an XML-RPC request. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="request"><see cref="Linphone.XmlRpcRequest">
		/// Linphone.XmlRpcRequest</see> object    </param>
		public delegate void OnResponseDelegate(Linphone.XmlRpcRequest request);
		private OnResponseDelegatePrivate on_response_private;
		private OnResponseDelegate on_response_public;

#if __IOS__
		[MonoPInvokeCallback(typeof(OnResponseDelegatePrivate))]
#endif
		private static void on_response(IntPtr request)
		{
			XmlRpcRequest thiz = fromNativePtr<XmlRpcRequest>(request);

			IntPtr ptr = linphone_xml_rpc_request_get_current_callbacks(thiz.nativePtr);
			XmlRpcRequestListener current_listener = fromNativePtr<XmlRpcRequestListener>(ptr, false, true);

			if (current_listener != null)
			{
				current_listener.on_response_public?.Invoke(thiz);
			}
		}

		public OnResponseDelegate OnResponse
		{
			get
			{
				return on_response_public;
			}
			set
			{
				on_response_public = value;
				on_response_private = on_response;
#if (_WIN32 || WINDOWS_UWP)
				IntPtr cb = Marshal.GetFunctionPointerForDelegate(on_response_private);
				linphone_xml_rpc_request_cbs_set_response(nativePtr, cb);
#else
				linphone_xml_rpc_request_cbs_set_response(nativePtr, on_response_private);
#endif
			}
		}
	}

#endregion

#region Classes
	/// <summary>
	/// Object that represents a Linphone Account. 
	/// <para>
	/// This object replaces the deprecated <see cref="Linphone.ProxyConfig">
	/// Linphone.ProxyConfig</see>. Use a <see cref="Linphone.AccountParams">
	/// Linphone.AccountParams</see> object to configure it. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Account : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_account_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private AccountListener listener;

		public AccountListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_account_cbs(linphone_factory_get());
					listener = fromNativePtr<AccountListener>(nativeListener, false, true);
					linphone_account_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_account_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_new_with_config(IntPtr lc, IntPtr parameters, IntPtr config);

		/// <summary>
		/// Create a new <see cref="Linphone.Account">Linphone.Account</see> with a Proxy
		/// config backpointer. 
		/// <para>
		/// This is only intended to be used while keeping a backward compatibility with
		/// proxy config. 
		/// </para>
		/// </summary>
		/// <param name="lc">The <see cref="Linphone.Core">Linphone.Core</see> object.   
		/// </param>
		/// <param name="parameters">The <see cref="Linphone.AccountParams">
		/// Linphone.AccountParams</see> object.    </param>
		/// <param name="config">The <see cref="Linphone.ProxyConfig">
		/// Linphone.ProxyConfig</see> object.    </param>
		/// <returns>The newly created <see cref="Linphone.Account">Linphone.Account</see>
		/// object.    </returns>
		public static Linphone.Account NewWithConfig(Linphone.Core lc, Linphone.AccountParams parameters, Linphone.ProxyConfig config)
		{
			IntPtr ptr = linphone_account_new_with_config(lc != null ? lc.nativePtr : IntPtr.Zero, parameters != null ? parameters.nativePtr : IntPtr.Zero, config != null ? config.nativePtr : IntPtr.Zero);
			Linphone.Account returnVal = fromNativePtr<Linphone.Account>(ptr, false);
			
			GC.KeepAlive(lc);
GC.KeepAlive(parameters);
GC.KeepAlive(config);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_avpf_enabled(IntPtr thiz);

		/// <summary>
		/// Indicates whether AVPF/SAVPF is being used for calls using this account. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if AVPF/SAVPF is enabled, false otherwise. </returns>
		public bool AvpfEnabled
		{
			get
			{
				return linphone_account_avpf_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_get_call_logs(IntPtr thiz);

		/// <summary>
		/// Returns the list of call logs for a given account. 
		/// <para>
		/// This list must be freed after use. 
		/// </para>
		/// </summary>
		/// <returns>The list of call logs  .       </returns>
		public IEnumerable<Linphone.CallLog> CallLogs
		{
			get
			{
				return MarshalBctbxList<Linphone.CallLog>(linphone_account_get_call_logs(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_get_chat_rooms(IntPtr thiz);

		/// <summary>
		/// Returns the list of chat rooms for a given account. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The list of chat rooms  .       </returns>
		public IEnumerable<Linphone.ChatRoom> ChatRooms
		{
			get
			{
				return MarshalBctbxList<Linphone.ChatRoom>(linphone_account_get_chat_rooms(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_get_conference_information_list(IntPtr thiz);

		/// <summary>
		/// Returns the list of conference information for a given account. 
		/// <para>
		/// This list must be freed after use. 
		/// </para>
		/// </summary>
		/// <returns>The list of call logs  .       </returns>
		public IEnumerable<Linphone.ConferenceInfo> ConferenceInformationList
		{
			get
			{
				return MarshalBctbxList<Linphone.ConferenceInfo>(linphone_account_get_conference_information_list(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_get_contact_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_set_contact_address(IntPtr thiz, IntPtr addr);

		/// <summary>
		/// Return the contact address of the account. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Address">Linphone.Address</see> correspong to
		/// the contact address of the account.    </returns>
		public Linphone.Address ContactAddress
		{
			get
			{
				IntPtr ptr = linphone_account_get_contact_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				linphone_account_set_contact_address(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_get_core(IntPtr thiz);

		/// <summary>
		/// Get the <see cref="Linphone.Core">Linphone.Core</see> object to which is
		/// associated the <see cref="Linphone.Account">Linphone.Account</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Core">Linphone.Core</see> object to which is
		/// associated the <see cref="Linphone.Account">Linphone.Account</see>.   
		/// </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_account_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_get_dependency(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_set_dependency(IntPtr thiz, IntPtr dependsOn);

		/// <summary>
		/// Get the dependency of a <see cref="Linphone.Account">Linphone.Account</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The account this one is dependent upon, or null if not marked
		/// dependent.    </returns>
		public Linphone.Account Dependency
		{
			get
			{
				IntPtr ptr = linphone_account_get_dependency(nativePtr);
				Linphone.Account obj = fromNativePtr<Linphone.Account>(ptr, true);
				return obj;
			}
			set
			{
				linphone_account_set_dependency(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.Reason linphone_account_get_error(IntPtr thiz);

		/// <summary>
		/// Get the reason why registration failed when the account state is
		/// LinphoneRegistrationFailed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Reason">Linphone.Reason</see> why registration
		/// failed for this account. </returns>
		public Linphone.Reason Error
		{
			get
			{
				return linphone_account_get_error(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_get_error_info(IntPtr thiz);

		/// <summary>
		/// Get detailed information why registration failed when the account state is
		/// LinphoneRegistrationFailed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.ErrorInfo">Linphone.ErrorInfo</see> explaining
		/// why registration failed for this account.    </returns>
		public Linphone.ErrorInfo ErrorInfo
		{
			get
			{
				IntPtr ptr = linphone_account_get_error_info(nativePtr);
				Linphone.ErrorInfo obj = fromNativePtr<Linphone.ErrorInfo>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_is_avpf_enabled(IntPtr thiz);

		/// <summary>
		/// Indicates whether AVPF/SAVPF is being used for calls using this account. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if AVPF/SAVPF is enabled, false otherwise. </returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.Account.AvpfEnabled()">
		/// Linphone.Account.AvpfEnabled()</see> instead. 
		public bool IsAvpfEnabled
		{
			get
			{
				return linphone_account_is_avpf_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_account_get_missed_calls_count(IntPtr thiz);

		/// <summary>
		/// Returns the missed calls count for a given account. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The missed calls count. </returns>
		public int MissedCallsCount
		{
			get
			{
				return linphone_account_get_missed_calls_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_get_params(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_account_set_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Get the <see cref="Linphone.AccountParams">Linphone.AccountParams</see> as
		/// read-only object. 
		/// <para>
		/// To make changes, clone the returned object using <see cref="Linphone.AccountParams.Clone()">
		/// Linphone.AccountParams.Clone()</see> method, make your changes on it and apply
		/// them using with <see cref="Linphone.Account.Params">
		/// Linphone.Account.Params</see>. 
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.AccountParams">Linphone.AccountParams</see>
		/// attached to this account.    </returns>
		public Linphone.AccountParams Params
		{
			get
			{
				IntPtr ptr = linphone_account_get_params(nativePtr);
				Linphone.AccountParams obj = fromNativePtr<Linphone.AccountParams>(ptr, true);
				return obj;
			}
			set
			{
				linphone_account_set_params(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.RegistrationState linphone_account_get_state(IntPtr thiz);

		/// <summary>
		/// Get the registration state of the given account. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.RegistrationState">
		/// Linphone.RegistrationState</see> of the account. </returns>
		public Linphone.RegistrationState State
		{
			get
			{
				return linphone_account_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.TransportType linphone_account_get_transport(IntPtr thiz);

		/// <summary>
		/// Get the transport from either service route, route or addr. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The transport as a string (I.E udp, tcp, tls, dtls). </returns>
		/// deprecated : 01/03/2021 Use Linphone_account_params_get_transport() instead. 
		public Linphone.TransportType Transport
		{
			get
			{
				return linphone_account_get_transport(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_account_get_unread_chat_message_count(IntPtr thiz);

		/// <summary>
		/// Returns the unread chat message count for a given account. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The unread chat message count. </returns>
		public int UnreadChatMessageCount
		{
			get
			{
				return linphone_account_get_unread_chat_message_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_add_custom_param(IntPtr thiz, string key, string val);

		/// <summary>
		/// Set one custom parameter to this <see cref="Linphone.Account">
		/// Linphone.Account</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">key of the searched parameter.    </param>
		/// <param name="val">value of the searched parameter.    </param>
		public void AddCustomParam(string key, string val)
		{
			linphone_account_add_custom_param(nativePtr, key, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_clear_call_logs(IntPtr thiz);

		/// <summary>
		/// Deletes all the call logs related to this account from the database. 
		/// <para>
		/// </para>
		/// </summary>
		public void ClearCallLogs()
		{
			linphone_account_clear_call_logs(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_clone(IntPtr thiz);

		/// <summary>
		/// Instantiate a new account with values from source. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The newly created <see cref="Linphone.Account">Linphone.Account</see>
		/// object.    </returns>
		public Linphone.Account Clone()
		{
			IntPtr ptr = linphone_account_clone(nativePtr);
			Linphone.Account returnVal = fromNativePtr<Linphone.Account>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_find_auth_info(IntPtr thiz);

		/// <summary>
		/// Find authentication info matching account, if any, similarly to
		/// linphone_core_find_auth_info. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.AuthInfo">Linphone.AuthInfo</see> matching
		/// account criteria if possible, null if nothing can be found.    </returns>
		public Linphone.AuthInfo FindAuthInfo()
		{
			IntPtr ptr = linphone_account_find_auth_info(nativePtr);
			Linphone.AuthInfo returnVal = fromNativePtr<Linphone.AuthInfo>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_get_call_logs_for_address(IntPtr thiz, IntPtr remoteAddress);

		/// <summary>
		/// Returns the list of call logs for a given account. 
		/// <para>
		/// This list must be freed after use. 
		/// </para>
		/// </summary>
		/// <param name="remoteAddress">the <see cref="Linphone.Address">
		/// Linphone.Address</see> object to filter call logs.    </param>
		/// <returns>The list of filtered call logs  .       </returns>
		public IEnumerable<Linphone.CallLog> GetCallLogsForAddress(Linphone.Address remoteAddress)
		{
			IEnumerable<Linphone.CallLog> returnVal = MarshalBctbxList<Linphone.CallLog>(linphone_account_get_call_logs_for_address(nativePtr, remoteAddress != null ? remoteAddress.nativePtr : IntPtr.Zero), false);
			
			GC.KeepAlive(remoteAddress);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_get_custom_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Obtain the value of a header sent by the server in last answer to REGISTER. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">The header name for which to fetch corresponding
		/// value.    </param>
		/// <returns>The value of the queried header.    </returns>
		public string GetCustomHeader(string headerName)
		{
			IntPtr stringPtr = linphone_account_get_custom_header(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_get_custom_param(IntPtr thiz, string key);

		/// <summary>
		/// Get the custom parameter with key to this <see cref="Linphone.Account">
		/// Linphone.Account</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">key of the searched parameter.    </param>
		/// <returns>The value of the parameter with key if found or an empty string
		/// otherwise.    </returns>
		public string GetCustomParam(string key)
		{
			IntPtr stringPtr = linphone_account_get_custom_param(nativePtr, key);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_is_phone_number(IntPtr thiz, string username);

		/// <summary>
		/// Detect if the given input is a phone number or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="username">The string to parse.    </param>
		/// <returns>true if input is a phone number, false otherwise. </returns>
		public bool IsPhoneNumber(string username)
		{
			bool returnVal = linphone_account_is_phone_number(nativePtr, username) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_normalize_phone_number(IntPtr thiz, string username);

		/// <summary>
		/// Normalize a human readable phone number into a basic string. 
		/// <para>
		/// 888-444-222 becomes 888444222 or +33888444222 depending on the <see cref="Linphone.Account">
		/// Linphone.Account</see> object. This function will always generate a normalized
		/// username if input is a phone number. 
		/// </para>
		/// </summary>
		/// <param name="username">The string to parse.    </param>
		/// <returns>null if input is an invalid phone number, normalized phone number from
		/// username input otherwise.       </returns>
		public string NormalizePhoneNumber(string username)
		{
			IntPtr stringPtr = linphone_account_normalize_phone_number(nativePtr, username);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_normalize_sip_uri(IntPtr thiz, string username);

		/// <summary>
		/// Normalize a human readable sip uri into a fully qualified LinphoneAddress. 
		/// <para>
		/// A sip address should look like DisplayName &lt;sip:username@domain:port&gt; .
		/// Basically this function performs the following tasks
		/// The result is a syntactically correct SIP address. 
		/// </para>
		/// </summary>
		/// <param name="username">The string to parse.    </param>
		/// <returns>null if invalid input, normalized sip address otherwise.      
		/// </returns>
		public Linphone.Address NormalizeSipUri(string username)
		{
			IntPtr ptr = linphone_account_normalize_sip_uri(nativePtr, username);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_pause_register(IntPtr thiz);

		/// <summary>
		/// Prevent an account from refreshing its registration. 
		/// <para>
		/// This is useful to let registrations to expire naturally (or) when the
		/// application wants to keep control on when refreshes are sent. However,
		/// linphone_core_set_network_reachable(lc,true) will always request the accounts
		/// to refresh their registrations. The refreshing operations can be resumed with
		/// <see cref="Linphone.Account.RefreshRegister()">
		/// Linphone.Account.RefreshRegister()</see>. 
		/// </para>
		/// </summary>
		public void PauseRegister()
		{
			linphone_account_pause_register(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_refresh_register(IntPtr thiz);

		/// <summary>
		/// Refresh a proxy registration. 
		/// <para>
		/// This is useful if for example you resuming from suspend, thus IP address may
		/// have changed. 
		/// </para>
		/// </summary>
		public void RefreshRegister()
		{
			linphone_account_refresh_register(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_reset_missed_calls_count(IntPtr thiz);

		/// <summary>
		/// Re-sets the number of missed calls for this account to 0. 
		/// <para>
		/// </para>
		/// </summary>
		public void ResetMissedCallsCount()
		{
			linphone_account_reset_missed_calls_count(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_set_custom_header(IntPtr thiz, string headerName, string headerValue);

		/// <summary>
		/// Set the value of a custom header sent to the server in REGISTERs request. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">The header name.    </param>
		/// <param name="headerValue">The header value.    </param>
		public void SetCustomHeader(string headerName, string headerValue)
		{
			linphone_account_set_custom_header(nativePtr, headerName, headerValue);
			
			
						
		}
	}
	/// <summary>
	/// The object used to configure an account on a server via XML-RPC, see
	/// https://wiki.linphone.org/xwiki/wiki/public/view/Lib/Features/Override%20account%20creator%20request/.
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class AccountCreator : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_account_creator_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private AccountCreatorListener listener;

		public AccountCreatorListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_account_creator_cbs(linphone_factory_get());
					listener = fromNativePtr<AccountCreatorListener>(nativeListener, false, true);
					linphone_account_creator_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_account_creator_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_create(IntPtr core);

		/// <summary>
		/// Create a <see cref="Linphone.AccountCreator">Linphone.AccountCreator</see> and
		/// set Linphone Request callbacks. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">The <see cref="Linphone.Core">Linphone.Core</see> used for
		/// the XML-RPC communication    </param>
		/// <returns>The new <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object.    </returns>
		public static Linphone.AccountCreator Create(Linphone.Core core)
		{
			IntPtr ptr = linphone_account_creator_create(core != null ? core.nativePtr : IntPtr.Zero);
			Linphone.AccountCreator returnVal = fromNativePtr<Linphone.AccountCreator>(ptr, false);
			
			GC.KeepAlive(core);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_account_creation_request_token(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_creator_set_account_creation_request_token(IntPtr thiz, string token);

		/// <summary>
		/// Get the account creation request token received to be used to check user
		/// validation. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The token set, if any    </returns>
		public string AccountCreationRequestToken
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_account_creation_request_token(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_account_creation_request_token(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_activation_code(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorActivationCodeStatus linphone_account_creator_set_activation_code(IntPtr thiz, string activationCode);

		/// <summary>
		/// Get the activation code. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The activation code of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see>.    </returns>
		public string ActivationCode
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_activation_code(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_activation_code(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_algorithm(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorAlgoStatus linphone_account_creator_set_algorithm(IntPtr thiz, string algorithm);

		/// <summary>
		/// Get the algorithm configured in the account creator. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The algorithm of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see>.    </returns>
		public string Algorithm
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_algorithm(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_algorithm(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_set_as_default(IntPtr thiz, char setAsDefault);

		/// <summary>
		/// Set the set_as_default property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="setAsDefault">true for the created proxy config to be set as
		/// default in <see cref="Linphone.Core">Linphone.Core</see>, false otherwise
		/// </param>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if everything is OK, or a
		/// specific error otherwise. </returns>
		public bool AsDefault
		{
			set
			{
				linphone_account_creator_set_as_default(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_display_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorUsernameStatus linphone_account_creator_set_display_name(IntPtr thiz, string displayName);

		/// <summary>
		/// Get the display name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The display name of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see>.    </returns>
		public string DisplayName
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_display_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_display_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_domain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorDomainStatus linphone_account_creator_set_domain(IntPtr thiz, string domain);

		/// <summary>
		/// Get the domain. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The domain of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see>.    </returns>
		public string Domain
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_domain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_email(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorEmailStatus linphone_account_creator_set_email(IntPtr thiz, string email);

		/// <summary>
		/// Get the email. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The email of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see>.    </returns>
		public string Email
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_email(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_email(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_ha1(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorPasswordStatus linphone_account_creator_set_ha1(IntPtr thiz, string ha1);

		/// <summary>
		/// Get the ha1. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The ha1 of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see>.    </returns>
		public string Ha1
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_ha1(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_ha1(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_language(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorLanguageStatus linphone_account_creator_set_language(IntPtr thiz, string lang);

		/// <summary>
		/// Get the language use in email of SMS. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The language of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see>.    </returns>
		public string Language
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_language(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_language(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_password(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorPasswordStatus linphone_account_creator_set_password(IntPtr thiz, string password);

		/// <summary>
		/// Get the password. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The password of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see>.    </returns>
		public string Password
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_password(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_password(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_phone_country_code(IntPtr thiz);

		/// <summary>
		/// Get the international prefix. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The international prefix (or phone country code) of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see>.    </returns>
		public string PhoneCountryCode
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_phone_country_code(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_phone_number(IntPtr thiz);

		/// <summary>
		/// Get the RFC 3966 normalized phone number. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The phone number of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see>.    </returns>
		public string PhoneNumber
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_phone_number(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_pn_param(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_creator_set_pn_param(IntPtr thiz, string pnParam);

		/// <summary>
		/// Get the param to be used by the backend to send the push notification to the
		/// device asking for an auth token. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The pn_param set, if any    </returns>
		public string PnParam
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_pn_param(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_pn_param(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_pn_prid(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_creator_set_pn_prid(IntPtr thiz, string pnPrid);

		/// <summary>
		/// Get the prid to be used by the backend to send the push notification to the
		/// device asking for an auth token. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The pn_prid set, if any    </returns>
		public string PnPrid
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_pn_prid(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_pn_prid(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_pn_provider(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_creator_set_pn_provider(IntPtr thiz, string pnProvider);

		/// <summary>
		/// Get the provider to be used by the backend to send the push notification to the
		/// device asking for an auth token. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The pn_provider set, if any    </returns>
		public string PnProvider
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_pn_provider(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_pn_provider(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_creator_set_proxy_config(IntPtr thiz, IntPtr cfg);

		/// <summary>
		/// Assign a proxy config pointer to the LinphoneAccountCreator. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="cfg">The LinphoneProxyConfig to associate with the
		/// LinphoneAccountCreator.    </param>
		public Linphone.ProxyConfig ProxyConfig
		{
			set
			{
				linphone_account_creator_set_proxy_config(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_route(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_set_route(IntPtr thiz, string route);

		/// <summary>
		/// Get the route. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The route of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see>.    </returns>
		public string Route
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_route(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_route(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_creator_get_set_as_default(IntPtr thiz);

		/// <summary>
		/// Get the set_as_default property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if account will be set as default, false otherwise. </returns>
		public bool SetAsDefault
		{
			get
			{
				return linphone_account_creator_get_set_as_default(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_token(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_creator_set_token(IntPtr thiz, string token);

		/// <summary>
		/// Get the authentication token set (if any) to be used to authenticate next
		/// queries, if required. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The token set, if any    </returns>
		public string Token
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_token(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_token(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.TransportType linphone_account_creator_get_transport(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorTransportStatus linphone_account_creator_set_transport(IntPtr thiz, int transport);

		/// <summary>
		/// Get Transport. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.TransportType">Linphone.TransportType</see> of
		/// the creator. </returns>
		public Linphone.TransportType Transport
		{
			get
			{
				return linphone_account_creator_get_transport(nativePtr);
			}
			set
			{
				linphone_account_creator_set_transport(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_get_username(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorUsernameStatus linphone_account_creator_set_username(IntPtr thiz, string username);

		/// <summary>
		/// Get the username. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The username of the <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see>.    </returns>
		public string Username
		{
			get
			{
				IntPtr stringPtr = linphone_account_creator_get_username(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_creator_set_username(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_activate_account(IntPtr thiz);

		/// <summary>
		/// Send a request to activate an account on server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if the request has been sent,
		/// <see cref="Linphone.AccountCreatorStatus.RequestFailed">
		/// Linphone.AccountCreatorStatus.RequestFailed</see> otherwise </returns>
		public Linphone.AccountCreatorStatus ActivateAccount()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_activate_account(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_activate_alias(IntPtr thiz);

		/// <summary>
		/// Send a request to activate an alias. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if the request has been sent,
		/// <see cref="Linphone.AccountCreatorStatus.RequestFailed">
		/// Linphone.AccountCreatorStatus.RequestFailed</see> otherwise </returns>
		public Linphone.AccountCreatorStatus ActivateAlias()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_activate_alias(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_create_account(IntPtr thiz);

		/// <summary>
		/// Send a request to create an account on server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if the request has been sent,
		/// <see cref="Linphone.AccountCreatorStatus.RequestFailed">
		/// Linphone.AccountCreatorStatus.RequestFailed</see> otherwise </returns>
		public Linphone.AccountCreatorStatus CreateAccount()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_create_account(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_create_account_in_core(IntPtr thiz);

		/// <summary>
		/// Create and configure a <see cref="Linphone.Account">Linphone.Account</see> and
		/// a <see cref="Linphone.AuthInfo">Linphone.AuthInfo</see> from informations set
		/// in the <see cref="Linphone.AccountCreator">Linphone.AccountCreator</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.Account">Linphone.Account</see> object if
		/// successful, null otherwise.       </returns>
		public Linphone.Account CreateAccountInCore()
		{
			IntPtr ptr = linphone_account_creator_create_account_in_core(nativePtr);
			Linphone.Account returnVal = fromNativePtr<Linphone.Account>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_creator_create_proxy_config(IntPtr thiz);

		/// <summary>
		/// Create and configure a proxy config and a authentication info for an account
		/// creator. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.ProxyConfig">Linphone.ProxyConfig</see> object
		/// if successful, null otherwise.    </returns>
		/// deprecated : 05/05/2023 Use <see cref="Linphone.AccountCreator.CreateAccountInCore()">
		/// Linphone.AccountCreator.CreateAccountInCore()</see> instead. 
		public Linphone.ProxyConfig CreateProxyConfig()
		{
			IntPtr ptr = linphone_account_creator_create_proxy_config(nativePtr);
			Linphone.ProxyConfig returnVal = fromNativePtr<Linphone.ProxyConfig>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_create_push_account(IntPtr thiz);

		/// <summary>
		/// Send a request to create a push account on server. 
		/// <para>
		/// Push accounts are used in account dependent situation when account cannot send
		/// push notifications. A username and password are automatically generated, an
		/// account is automatically activated. 
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if the request has been sent,
		/// <see cref="Linphone.AccountCreatorStatus.RequestFailed">
		/// Linphone.AccountCreatorStatus.RequestFailed</see> otherwise </returns>
		public Linphone.AccountCreatorStatus CreatePushAccount()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_create_push_account(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_is_account_activated(IntPtr thiz);

		/// <summary>
		/// Send a request to know if an account is activated on server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if the request has been sent,
		/// <see cref="Linphone.AccountCreatorStatus.RequestFailed">
		/// Linphone.AccountCreatorStatus.RequestFailed</see> otherwise </returns>
		public Linphone.AccountCreatorStatus IsAccountActivated()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_is_account_activated(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_is_account_exist(IntPtr thiz);

		/// <summary>
		/// Send a request to know the existence of account on server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if the request has been sent,
		/// <see cref="Linphone.AccountCreatorStatus.RequestFailed">
		/// Linphone.AccountCreatorStatus.RequestFailed</see> otherwise </returns>
		public Linphone.AccountCreatorStatus IsAccountExist()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_is_account_exist(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_is_account_linked(IntPtr thiz);

		/// <summary>
		/// Send a request to know if an account is linked. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if the request has been sent,
		/// <see cref="Linphone.AccountCreatorStatus.RequestFailed">
		/// Linphone.AccountCreatorStatus.RequestFailed</see> otherwise </returns>
		public Linphone.AccountCreatorStatus IsAccountLinked()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_is_account_linked(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_is_alias_used(IntPtr thiz);

		/// <summary>
		/// Send a request to know if an alias is used. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if the request has been sent,
		/// <see cref="Linphone.AccountCreatorStatus.RequestFailed">
		/// Linphone.AccountCreatorStatus.RequestFailed</see> otherwise </returns>
		public Linphone.AccountCreatorStatus IsAliasUsed()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_is_alias_used(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_link_account(IntPtr thiz);

		/// <summary>
		/// Send a request to link an account to an alias. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if the request has been sent,
		/// <see cref="Linphone.AccountCreatorStatus.RequestFailed">
		/// Linphone.AccountCreatorStatus.RequestFailed</see> otherwise </returns>
		public Linphone.AccountCreatorStatus LinkAccount()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_link_account(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_login_linphone_account(IntPtr thiz);

		/// <summary>
		/// Send a request to get the password &amp; algorithm of an account using the
		/// confirmation key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if everything is OK, or a
		/// specific error otherwise. </returns>
		public Linphone.AccountCreatorStatus LoginLinphoneAccount()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_login_linphone_account(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_recover_account(IntPtr thiz);

		/// <summary>
		/// Send a request to recover an account. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if the request has been sent,
		/// <see cref="Linphone.AccountCreatorStatus.RequestFailed">
		/// Linphone.AccountCreatorStatus.RequestFailed</see> otherwise </returns>
		public Linphone.AccountCreatorStatus RecoverAccount()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_recover_account(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_request_account_creation_request_token(IntPtr thiz);

		/// <summary>
		/// Request an account creation &quot;request_token&quot; to be used on account
		/// creations. 
		/// <para>
		/// The request_token is retrieved from the callback
		/// linphone_account_creator_cbs_get_account_creation_request_token 
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if everything is OK, or a
		/// specific error otherwise. </returns>
		public Linphone.AccountCreatorStatus RequestAccountCreationRequestToken()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_request_account_creation_request_token(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_request_account_creation_token_using_request_token(IntPtr thiz);

		/// <summary>
		/// Send a request to get a token to be used for account creation from a
		/// request_token. 
		/// <para>
		/// The token is retrieved from the callback
		/// linphone_account_creator_cbs_get_account_creation_token_using_request_token 
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if the request has been sent,
		/// <see cref="Linphone.AccountCreatorStatus.RequestFailed">
		/// Linphone.AccountCreatorStatus.RequestFailed</see> otherwise </returns>
		public Linphone.AccountCreatorStatus RequestAccountCreationTokenUsingRequestToken()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_request_account_creation_token_using_request_token(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_request_auth_token(IntPtr thiz);

		/// <summary>
		/// Request an auth token to be send by the backend by push notification. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if everything is OK, or a
		/// specific error otherwise. </returns>
		public Linphone.AccountCreatorStatus RequestAuthToken()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_request_auth_token(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_creator_reset(IntPtr thiz);

		/// <summary>
		/// Reset the account creator entries like username, password, phone number... 
		/// <para>
		/// </para>
		/// </summary>
		public void Reset()
		{
			linphone_account_creator_reset(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_account_creator_set_phone_number(IntPtr thiz, string phoneNumber, string countryCode);

		/// <summary>
		/// Set the phone number normalized. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">The phone number to set    </param>
		/// <param name="countryCode">Country code to associate phone number with   
		/// </param>
		/// <returns><see cref="Linphone.AccountCreatorPhoneNumberStatus.Ok">
		/// Linphone.AccountCreatorPhoneNumberStatus.Ok</see> if everything is OK, or
		/// specific(s) error(s) otherwise. </returns>
		public uint SetPhoneNumber(string phoneNumber, string countryCode)
		{
			uint returnVal = linphone_account_creator_set_phone_number(nativePtr, phoneNumber, countryCode);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorStatus linphone_account_creator_update_account(IntPtr thiz);

		/// <summary>
		/// Send a request to update an account. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountCreatorStatus.RequestOk">
		/// Linphone.AccountCreatorStatus.RequestOk</see> if the request has been sent,
		/// <see cref="Linphone.AccountCreatorStatus.RequestFailed">
		/// Linphone.AccountCreatorStatus.RequestFailed</see> otherwise </returns>
		public Linphone.AccountCreatorStatus UpdateAccount()
		{
			Linphone.AccountCreatorStatus returnVal = linphone_account_creator_update_account(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_creator_use_test_admin_account(IntPtr thiz);

		/// <summary>
		/// Require the account creator to use special &quot;test admin account&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : The &quot;test admin account&quot; is a special feature
		/// required for automated test, and requires the APP_EVERYONE_IS_ADMIN property to
		/// be enabled on the remote Flexisip Account Manager (FlexiAPI). This feature must
		/// never be turned on for a production-stage app. </remarks> 
		public void UseTestAdminAccount()
		{
			linphone_account_creator_use_test_admin_account(nativePtr);
			
			
						
		}
	}
	/// <summary>
	/// Object that is used to set the different parameters of a <see cref="Linphone.Account">
	/// Linphone.Account</see>. 
	/// <para>
	/// Note that authenticated accounts should have a corresponding <see cref="Linphone.AuthInfo">
	/// Linphone.AuthInfo</see> added to the <see cref="Linphone.Core">
	/// Linphone.Core</see> to register properly. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class AccountParams : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_new_with_config(IntPtr lc, int index);

		/// <summary>
		/// Create a new <see cref="Linphone.AccountParams">Linphone.AccountParams</see>
		/// object from a configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="lc">The <see cref="Linphone.Core">Linphone.Core</see> object.   
		/// </param>
		/// <param name="index">The index of the configuration. </param>
		/// <returns>The newly created <see cref="Linphone.AccountParams">
		/// Linphone.AccountParams</see> object.    </returns>
		public static Linphone.AccountParams NewWithConfig(Linphone.Core lc, int index)
		{
			IntPtr ptr = linphone_account_params_new_with_config(lc != null ? lc.nativePtr : IntPtr.Zero, index);
			Linphone.AccountParams returnVal = fromNativePtr<Linphone.AccountParams>(ptr, false);
			
			GC.KeepAlive(lc);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_audio_video_conference_factory_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_audio_video_conference_factory_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Get the audio video conference factory uri. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Address">Linphone.Address</see> of the audio
		/// video conference factory.    </returns>
		public Linphone.Address AudioVideoConferenceFactoryAddress
		{
			get
			{
				IntPtr ptr = linphone_account_params_get_audio_video_conference_factory_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				linphone_account_params_set_audio_video_conference_factory_address(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AVPFMode linphone_account_params_get_avpf_mode(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_avpf_mode(IntPtr thiz, int mode);

		/// <summary>
		/// Get enablement status of RTCP feedback (also known as AVPF profile). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the enablement mode, which can be <see cref="Linphone.AVPFMode.Default">
		/// Linphone.AVPFMode.Default</see> (use LinphoneCore&apos;s mode), <see cref="Linphone.AVPFMode.Enabled">
		/// Linphone.AVPFMode.Enabled</see> (avpf is enabled), or <see cref="Linphone.AVPFMode.Disabled">
		/// Linphone.AVPFMode.Disabled</see> (disabled). </returns>
		public Linphone.AVPFMode AvpfMode
		{
			get
			{
				return linphone_account_params_get_avpf_mode(nativePtr);
			}
			set
			{
				linphone_account_params_set_avpf_mode(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_account_params_get_avpf_rr_interval(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_avpf_rr_interval(IntPtr thiz, uint interval);

		/// <summary>
		/// Get the interval between regular RTCP reports when using AVPF/SAVPF. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The interval in seconds. </returns>
		public uint AvpfRrInterval
		{
			get
			{
				return linphone_account_params_get_avpf_rr_interval(nativePtr);
			}
			set
			{
				linphone_account_params_set_avpf_rr_interval(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_conference_factory_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_conference_factory_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Get the conference factory uri. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Address">Linphone.Address</see> of the
		/// conference factory.    </returns>
		public Linphone.Address ConferenceFactoryAddress
		{
			get
			{
				IntPtr ptr = linphone_account_params_get_conference_factory_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				linphone_account_params_set_conference_factory_address(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_conference_factory_uri(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_conference_factory_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Get the conference factory uri. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The uri of the conference factory.    </returns>
		public string ConferenceFactoryUri
		{
			get
			{
				IntPtr stringPtr = linphone_account_params_get_conference_factory_uri(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_params_set_conference_factory_uri(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_contact_parameters(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_contact_parameters(IntPtr thiz, string contactParams);

		/// <summary>
		/// Returns the contact parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The previously set contact parameters.    </returns>
		public string ContactParameters
		{
			get
			{
				IntPtr stringPtr = linphone_account_params_get_contact_parameters(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_params_set_contact_parameters(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_contact_uri_parameters(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_contact_uri_parameters(IntPtr thiz, string contactUriParams);

		/// <summary>
		/// Return the contact URI parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The previously set contact URI parameters.    </returns>
		public string ContactUriParameters
		{
			get
			{
				IntPtr stringPtr = linphone_account_params_get_contact_uri_parameters(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_params_set_contact_uri_parameters(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_params_cpim_in_basic_chat_room_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_enable_cpim_in_basic_chat_room(IntPtr thiz, char enable);

		/// <summary>
		/// Indicates whether chat messages sent by this account in a <see cref="Linphone.ChatRoomBackend.Basic">
		/// Linphone.ChatRoomBackend.Basic</see> chat room will be using CPIM format or
		/// not. 
		/// <para>
		/// By default SIP SIMPLE format is used for &quot;basic&quot; chat rooms, CPIM is
		/// only used for <see cref="Linphone.ChatRoomBackend.FlexisipChat">
		/// Linphone.ChatRoomBackend.FlexisipChat</see> chat rooms. </para>
		/// </summary>
		/// <remarks>See :
		/// https://wiki.linphone.org/xwiki/wiki/public/view/Lib/Features/Instant%20Messaging/Reply%20to%20a%20specific%20message/ </remarks>
		/// <returns>true if chat messages will be sent out in CPIM format, false if chat
		/// messages will be sent out as SIP SIMPLE. </returns>
		public bool CpimInBasicChatRoomEnabled
		{
			get
			{
				return linphone_account_params_cpim_in_basic_chat_room_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_account_params_enable_cpim_in_basic_chat_room(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_custom_contact(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_custom_contact(IntPtr thiz, IntPtr contact);

		/// <summary>
		/// Get the custom contact address previously used when registering to the SIP
		/// server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Address">Linphone.Address</see>    </returns>
		public Linphone.Address CustomContact
		{
			get
			{
				IntPtr ptr = linphone_account_params_get_custom_contact(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				linphone_account_params_set_custom_contact(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_params_dial_escape_plus_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_enable_dial_escape_plus(IntPtr thiz, char enable);

		/// <summary>
		/// Return whether or not the + should be replaced by 00. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Whether liblinphone should replace &quot;+&quot; by &quot;00&quot; in
		/// dialed numbers (passed to <see cref="Linphone.Core.Invite()">
		/// Linphone.Core.Invite()</see>). </returns>
		public bool DialEscapePlusEnabled
		{
			get
			{
				return linphone_account_params_dial_escape_plus_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_account_params_enable_dial_escape_plus(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_domain(IntPtr thiz);

		/// <summary>
		/// Get the domain name of the given account params. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The domain name of the account params.    </returns>
		public string Domain
		{
			get
			{
				IntPtr stringPtr = linphone_account_params_get_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_account_params_get_expires(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_expires(IntPtr thiz, int expires);

		/// <summary>
		/// Get the account params expires. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The duration of registration. </returns>
		public int Expires
		{
			get
			{
				return linphone_account_params_get_expires(nativePtr);
			}
			set
			{
				linphone_account_params_set_expires(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_identity(IntPtr thiz);

		/// <summary>
		/// Get the identity of the account params. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The SIP identity that belongs to this account params.    </returns>
		/// deprecated : 01/03/2021 Use <see cref="Linphone.AccountParams.IdentityAddress">
		/// Linphone.AccountParams.IdentityAddress</see> instead. 
		public string Identity
		{
			get
			{
				IntPtr stringPtr = linphone_account_params_get_identity(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_identity_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_account_params_set_identity_address(IntPtr thiz, IntPtr identity);

		/// <summary>
		/// Get the identity address of the account params. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The SIP identity that belongs to this account params.    </returns>
		public Linphone.Address IdentityAddress
		{
			get
			{
				IntPtr ptr = linphone_account_params_get_identity_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				int exception_result = linphone_account_params_set_identity_address(nativePtr, value.nativePtr);
				if (exception_result != 0) throw new LinphoneException("IdentityAddress setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_idkey(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_idkey(IntPtr thiz, string idkey);

		/// <summary>
		/// Get the idkey property of a <see cref="Linphone.AccountParams">
		/// Linphone.AccountParams</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The idkey string, or null.    </returns>
		public string Idkey
		{
			get
			{
				IntPtr stringPtr = linphone_account_params_get_idkey(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_params_set_idkey(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_international_prefix(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_international_prefix(IntPtr thiz, string prefix);

		/// <summary>
		/// Get the prefix set for this account params. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The international prefix.    </returns>
		public string InternationalPrefix
		{
			get
			{
				IntPtr stringPtr = linphone_account_params_get_international_prefix(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_params_set_international_prefix(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_params_is_push_notification_available(IntPtr thiz);

		/// <summary>
		/// Gets whether push notifications are available or not (Android &amp; iOS only). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if push notifications are available, false otherwise </returns>
		public bool IsPushNotificationAvailable
		{
			get
			{
				return linphone_account_params_is_push_notification_available(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_lime_server_url(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_lime_server_url(IntPtr thiz, string url);

		/// <summary>
		/// Get the x3dh server url. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The x3dh server url.    </returns>
		public string LimeServerUrl
		{
			get
			{
				IntPtr stringPtr = linphone_account_params_get_lime_server_url(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_params_set_lime_server_url(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_nat_policy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_nat_policy(IntPtr thiz, IntPtr policy);

		/// <summary>
		/// Get The policy that is used to pass through NATs/firewalls when using this
		/// account params. 
		/// <para>
		/// If it is set to null, the default NAT policy from the core will be used
		/// instead. 
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.NatPolicy">Linphone.NatPolicy</see> object in
		/// use.    </returns>
		/// <remarks>See : <see cref="Linphone.Core.NatPolicy">
		/// Linphone.Core.NatPolicy</see> </remarks>
		public Linphone.NatPolicy NatPolicy
		{
			get
			{
				IntPtr ptr = linphone_account_params_get_nat_policy(nativePtr);
				Linphone.NatPolicy obj = fromNativePtr<Linphone.NatPolicy>(ptr, true);
				return obj;
			}
			set
			{
				linphone_account_params_set_nat_policy(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_params_outbound_proxy_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_enable_outbound_proxy(IntPtr thiz, char enable);

		/// <summary>
		/// Tell if the proxy is used as the only route. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>enable true if enabled, false otherwise. </returns>
		public bool OutboundProxyEnabled
		{
			get
			{
				return linphone_account_params_outbound_proxy_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_account_params_enable_outbound_proxy(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_picture_uri(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_picture_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Gets the account picture URI if set, null otherwise. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The account picture URI.    </returns>
		public string PictureUri
		{
			get
			{
				IntPtr stringPtr = linphone_account_params_get_picture_uri(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_params_set_picture_uri(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_account_params_get_privacy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_privacy(IntPtr thiz, uint privacy);

		/// <summary>
		/// Get default privacy policy for all calls routed through this proxy. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Privacy mode as LinphonePrivacyMask </returns>
		public uint Privacy
		{
			get
			{
				return linphone_account_params_get_privacy(nativePtr);
			}
			set
			{
				linphone_account_params_set_privacy(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_params_publish_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_enable_publish(IntPtr thiz, char enable);

		/// <summary>
		/// Tell if the PUBLISH is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if PUBLISH request is enabled for this proxy. </returns>
		public bool PublishEnabled
		{
			get
			{
				return linphone_account_params_publish_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_account_params_enable_publish(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_account_params_get_publish_expires(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_publish_expires(IntPtr thiz, int expires);

		/// <summary>
		/// Get the publish expiration time in second. 
		/// <para>
		/// Default value is the registration expiration value. 
		/// </para>
		/// </summary>
		/// <returns>The expire time in seconds. </returns>
		public int PublishExpires
		{
			get
			{
				return linphone_account_params_get_publish_expires(nativePtr);
			}
			set
			{
				linphone_account_params_set_publish_expires(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_params_get_push_notification_allowed(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_push_notification_allowed(IntPtr thiz, char allow);

		/// <summary>
		/// Indicates whether to add to the contact parameters the push notification
		/// information. 
		/// <para>
		/// For IOS, it indicates for VOIP push notification. 
		/// </para>
		/// </summary>
		/// <returns>true if push notification informations should be added, false
		/// otherwise. </returns>
		public bool PushNotificationAllowed
		{
			get
			{
				return linphone_account_params_get_push_notification_allowed(nativePtr) != 0;
			}
			set
			{
				linphone_account_params_set_push_notification_allowed(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_push_notification_config(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_push_notification_config(IntPtr thiz, IntPtr config);

		/// <summary>
		/// Returns the push notification configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.PushNotificationConfig">
		/// Linphone.PushNotificationConfig</see> object.    </returns>
		public Linphone.PushNotificationConfig PushNotificationConfig
		{
			get
			{
				IntPtr ptr = linphone_account_params_get_push_notification_config(nativePtr);
				Linphone.PushNotificationConfig obj = fromNativePtr<Linphone.PushNotificationConfig>(ptr, true);
				return obj;
			}
			set
			{
				linphone_account_params_set_push_notification_config(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_quality_reporting_collector(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_quality_reporting_collector(IntPtr thiz, string collector);

		/// <summary>
		/// Get the route of the collector end-point when using quality reporting. 
		/// <para>
		/// This SIP address should be used on server-side to process packets directly
		/// before discarding packets. Collector address should be a non existing account
		/// and will not receive any messages. If null, reports will be send to the proxy
		/// domain. 
		/// </para>
		/// </summary>
		/// <returns>The SIP address of the collector end-point.    </returns>
		public string QualityReportingCollector
		{
			get
			{
				IntPtr stringPtr = linphone_account_params_get_quality_reporting_collector(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_params_set_quality_reporting_collector(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_params_quality_reporting_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_enable_quality_reporting(IntPtr thiz, char enable);

		/// <summary>
		/// Indicates whether quality statistics during call should be stored and sent to a
		/// collector according to RFC 6035. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if quality repotring is enabled, false otherwise. </returns>
		public bool QualityReportingEnabled
		{
			get
			{
				return linphone_account_params_quality_reporting_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_account_params_enable_quality_reporting(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_account_params_get_quality_reporting_interval(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_quality_reporting_interval(IntPtr thiz, int interval);

		/// <summary>
		/// Get the interval between interval reports when using quality reporting. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The interval in seconds, 0 means interval reports are disabled.
		/// </returns>
		public int QualityReportingInterval
		{
			get
			{
				return linphone_account_params_get_quality_reporting_interval(nativePtr);
			}
			set
			{
				linphone_account_params_set_quality_reporting_interval(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_realm(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_realm(IntPtr thiz, string realm);

		/// <summary>
		/// Get the realm of the given account params. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The realm of the account params.    </returns>
		public string Realm
		{
			get
			{
				IntPtr stringPtr = linphone_account_params_get_realm(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_params_set_realm(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_ref_key(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_ref_key(IntPtr thiz, string refkey);

		/// <summary>
		/// Get the persistent reference key associated to the account params. 
		/// <para>
		/// The reference key can be for example an id to an external database. It is
		/// stored in the config file, thus can survive to process exits/restarts.
		/// </para>
		/// </summary>
		/// <returns>The reference key string that has been associated to the account
		/// params, or null if none has been associated.    </returns>
		public string RefKey
		{
			get
			{
				IntPtr stringPtr = linphone_account_params_get_ref_key(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_account_params_set_ref_key(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_params_register_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_enable_register(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether the account params is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if registration to the proxy is enabled. </returns>
		public bool RegisterEnabled
		{
			get
			{
				return linphone_account_params_register_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_account_params_enable_register(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_params_get_remote_push_notification_allowed(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_remote_push_notification_allowed(IntPtr thiz, char allow);

		/// <summary>
		/// Indicates whether to add to the contact parameters the push notification
		/// information. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if remote push notification informations should be added, false
		/// otherwise. </returns>
		public bool RemotePushNotificationAllowed
		{
			get
			{
				return linphone_account_params_get_remote_push_notification_allowed(nativePtr) != 0;
			}
			set
			{
				linphone_account_params_set_remote_push_notification_allowed(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_routes_addresses(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_account_params_set_routes_addresses(IntPtr thiz, IntPtr routes);

		/// <summary>
		/// Gets the list of the routes set for this account params. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : If linphone_account_params_is_outbound_proxy_enabled is true
		/// then it will only return the proxy address. </remarks> 
		/// <returns>The list of routes.      </returns>
		public IEnumerable<Linphone.Address> RoutesAddresses
		{
			get
			{
				return MarshalBctbxList<Linphone.Address>(linphone_account_params_get_routes_addresses(nativePtr), true);
			}
			set
			{
				int exception_result = linphone_account_params_set_routes_addresses(nativePtr, ObjectArrayToBctbxList<Linphone.Address>(value));
				if (exception_result != 0) throw new LinphoneException("RoutesAddresses setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_params_rtp_bundle_assumption_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_enable_rtp_bundle_assumption(IntPtr thiz, char val);

		/// <summary>
		/// Returns whether RTP bundle mode is assumed. 
		/// <para>
		/// See https://datatracker.ietf.org/doc/html/rfc8843 for more information. 
		/// </para>
		/// </summary>
		/// <returns>a boolean indicating when rtp bundle support is assumed. </returns>
		public bool RtpBundleAssumptionEnabled
		{
			get
			{
				return linphone_account_params_rtp_bundle_assumption_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_account_params_enable_rtp_bundle_assumption(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_params_rtp_bundle_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_enable_rtp_bundle(IntPtr thiz, char val);

		/// <summary>
		/// Returns whether RTP bundle mode (also known as Media Multiplexing) is enabled. 
		/// <para>
		/// See https://datatracker.ietf.org/doc/html/rfc8843 for more information. 
		/// </para>
		/// </summary>
		/// <returns>a boolean indicating the enablement of rtp bundle mode. </returns>
		public bool RtpBundleEnabled
		{
			get
			{
				return linphone_account_params_rtp_bundle_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_account_params_enable_rtp_bundle(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_server_addr(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_account_params_set_server_addr(IntPtr thiz, string serverAddress);

		/// <summary>
		/// Get the account params proxy address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The proxy&apos;s SIP address.    </returns>
		/// deprecated : 01/03/2021 Use <see cref="Linphone.AccountParams.ServerAddress">
		/// Linphone.AccountParams.ServerAddress</see> instead. 
		public string ServerAddr
		{
			get
			{
				IntPtr stringPtr = linphone_account_params_get_server_addr(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_account_params_set_server_addr(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("ServerAddr setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_server_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_account_params_set_server_address(IntPtr thiz, IntPtr serverAddress);

		/// <summary>
		/// Get the account params proxy address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The proxy&apos;s SIP <see cref="Linphone.Address">
		/// Linphone.Address</see>.    </returns>
		public Linphone.Address ServerAddress
		{
			get
			{
				IntPtr ptr = linphone_account_params_get_server_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				int exception_result = linphone_account_params_set_server_address(nativePtr, value.nativePtr);
				if (exception_result != 0) throw new LinphoneException("ServerAddress setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.TransportType linphone_account_params_get_transport(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_transport(IntPtr thiz, int transport);

		/// <summary>
		/// Returns the transport type of the server address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.TransportType">Linphone.TransportType</see> of
		/// the server address. </returns>
		public Linphone.TransportType Transport
		{
			get
			{
				return linphone_account_params_get_transport(nativePtr);
			}
			set
			{
				linphone_account_params_set_transport(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_account_params_get_use_international_prefix_for_calls_and_chats(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_set_use_international_prefix_for_calls_and_chats(IntPtr thiz, char enable);

		/// <summary>
		/// Return whether or not the international prefix will automaticaly be used for
		/// calls and chats. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Whether we should use international prefix automatically for calls.
		/// </returns>
		public bool UseInternationalPrefixForCallsAndChats
		{
			get
			{
				return linphone_account_params_get_use_international_prefix_for_calls_and_chats(nativePtr) != 0;
			}
			set
			{
				linphone_account_params_set_use_international_prefix_for_calls_and_chats(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_account_params_add_custom_param(IntPtr thiz, string key, string val);

		/// <summary>
		/// Set one custom parameter to this <see cref="Linphone.AccountParams">
		/// Linphone.AccountParams</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">key of the searched parameter.    </param>
		/// <param name="val">value of the searched parameter.    </param>
		public void AddCustomParam(string key, string val)
		{
			linphone_account_params_add_custom_param(nativePtr, key, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_clone(IntPtr thiz);

		/// <summary>
		/// Instantiate a new account params with values from source. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The newly created <see cref="Linphone.AccountParams">
		/// Linphone.AccountParams</see> object.    </returns>
		public Linphone.AccountParams Clone()
		{
			IntPtr ptr = linphone_account_params_clone(nativePtr);
			Linphone.AccountParams returnVal = fromNativePtr<Linphone.AccountParams>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_account_params_get_custom_param(IntPtr thiz, string key);

		/// <summary>
		/// Get the custom parameter with key to this <see cref="Linphone.AccountParams">
		/// Linphone.AccountParams</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">key of the searched parameter.    </param>
		/// <returns>The value of the parameter with key if found or an empty string
		/// otherwise.    </returns>
		public string GetCustomParam(string key)
		{
			IntPtr stringPtr = linphone_account_params_get_custom_param(nativePtr, key);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
	}
	/// <summary>
	/// Object that represents a parsed SIP address. 
	/// <para>
	/// A SIP address is made of display name, username, domain name, port, and various
	/// uri headers (such as tags). It looks like &apos;Alice
	/// &lt;sip:alice@example.net&gt;&apos;.
	/// You can create an address using <see cref="Linphone.Factory.CreateAddress()">
	/// Linphone.Factory.CreateAddress()</see> or <see cref="Linphone.Core.InterpretUrl()">
	/// Linphone.Core.InterpretUrl()</see> and both will return a null object if it
	/// doesn&apos;t match the grammar defined by the standard.
	/// This object is used in almost every other major objects to identity people
	/// (including yourself) &amp; servers.
	/// The <see cref="Linphone.Address">Linphone.Address</see> has methods to extract
	/// and manipulate all parts of the address. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Address : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_display_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_address_set_display_name(IntPtr thiz, string displayName);

		/// <summary>
		/// Returns the display name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the display name if any, null otherwise.    </returns>
		public string DisplayName
		{
			get
			{
				IntPtr stringPtr = linphone_address_get_display_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_address_set_display_name(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("DisplayName setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_domain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_address_set_domain(IntPtr thiz, string domain);

		/// <summary>
		/// Returns the domain name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the domain name if any, null otherwise.    </returns>
		public string Domain
		{
			get
			{
				IntPtr stringPtr = linphone_address_get_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_address_set_domain(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Domain setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_address_is_sip(IntPtr thiz);

		/// <summary>
		/// returns whether the address is a routable SIP address or not 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if it is a routable SIP address, false otherwise </returns>
		public bool IsSip
		{
			get
			{
				return linphone_address_is_sip(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_address_is_valid(IntPtr thiz);

		/// <summary>
		/// Returns if address is valid. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the scheme if any, null otherwise.    </returns>
		public bool IsValid
		{
			get
			{
				return linphone_address_is_valid(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_method_param(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_method_param(IntPtr thiz, string methodParam);

		/// <summary>
		/// Get the value of the method parameter. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the value of the parameter or null.    </returns>
		public string MethodParam
		{
			get
			{
				IntPtr stringPtr = linphone_address_get_method_param(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_address_set_method_param(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_password(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_password(IntPtr thiz, string password);

		/// <summary>
		/// Get the password encoded in the address. 
		/// <para>
		/// It is used for basic authentication (not recommended). 
		/// </para>
		/// </summary>
		/// <returns>the password if any, null otherwise.    </returns>
		public string Password
		{
			get
			{
				IntPtr stringPtr = linphone_address_get_password(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_address_set_password(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_address_get_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_address_set_port(IntPtr thiz, int port);

		/// <summary>
		/// Get port number as an integer value, 0 if not present. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the port set in the address or 0 if not present. </returns>
		public int Port
		{
			get
			{
				return linphone_address_get_port(nativePtr);
			}
			set
			{
				int exception_result = linphone_address_set_port(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Port setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_scheme(IntPtr thiz);

		/// <summary>
		/// Returns the address scheme, normally &quot;sip&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the scheme if any, null otherwise.    </returns>
		public string Scheme
		{
			get
			{
				IntPtr stringPtr = linphone_address_get_scheme(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_address_get_secure(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_secure(IntPtr thiz, char enabled);

		/// <summary>
		/// Returns whether the address refers to a secure location (sips) or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if address refers to a secure location, false otherwise </returns>
		public bool Secure
		{
			get
			{
				return linphone_address_get_secure(nativePtr) != 0;
			}
			set
			{
				linphone_address_set_secure(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.TransportType linphone_address_get_transport(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_address_set_transport(IntPtr thiz, int transport);

		/// <summary>
		/// Get the transport. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.TransportType">Linphone.TransportType</see>,
		/// default value if not set is UDP. </returns>
		public Linphone.TransportType Transport
		{
			get
			{
				return linphone_address_get_transport(nativePtr);
			}
			set
			{
				int exception_result = linphone_address_set_transport(nativePtr, (int)value);
				if (exception_result != 0) throw new LinphoneException("Transport setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_uri_params(IntPtr thiz, string parameters);

		/// <summary>
		/// Set the value of the parameters of the URI of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The parameters string </param>
		public string UriParams
		{
			set
			{
				linphone_address_set_uri_params(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_username(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_address_set_username(IntPtr thiz, string username);

		/// <summary>
		/// Returns the username. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the username name if any, null otherwise.    </returns>
		public string Username
		{
			get
			{
				IntPtr stringPtr = linphone_address_get_username(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_address_set_username(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Username setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_as_string(IntPtr thiz);

		/// <summary>
		/// Returns the address as a string. 
		/// <para>
		/// The returned char * must be freed by the application. Use ms_free(). 
		/// </para>
		/// </summary>
		/// <returns>a string representation of the address.       </returns>
		public string AsString()
		{
			IntPtr stringPtr = linphone_address_as_string(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_as_string_uri_only(IntPtr thiz);

		/// <summary>
		/// Returns the SIP uri only as a string, that is display name is removed. 
		/// <para>
		/// The returned char * must be freed by the application. Use ms_free(). 
		/// </para>
		/// </summary>
		/// <returns>a string representation of the address.       </returns>
		public string AsStringUriOnly()
		{
			IntPtr stringPtr = linphone_address_as_string_uri_only(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_clean(IntPtr thiz);

		/// <summary>
		/// Removes address&apos;s tags and uri headers so that it is displayable to the
		/// user. 
		/// <para>
		/// </para>
		/// </summary>
		public void Clean()
		{
			linphone_address_clean(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_clone(IntPtr thiz);

		/// <summary>
		/// Clones a <see cref="Linphone.Address">Linphone.Address</see> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a new <see cref="Linphone.Address">Linphone.Address</see> object.   
		/// </returns>
		public Linphone.Address Clone()
		{
			IntPtr ptr = linphone_address_clone(nativePtr);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_address_equal(IntPtr thiz, IntPtr address2);

		/// <summary>
		/// Compare two <see cref="Linphone.Address">Linphone.Address</see> taking the tags
		/// and headers into account. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address2"><see cref="Linphone.Address">Linphone.Address</see>
		/// object.    </param>
		/// <returns>Boolean value telling if the <see cref="Linphone.Address">
		/// Linphone.Address</see> objects are equal. </returns>
		/// <remarks>See : <see cref="Linphone.Address.WeakEqual()">
		/// Linphone.Address.WeakEqual()</see> </remarks>
		public bool Equal(Linphone.Address address2)
		{
			bool returnVal = linphone_address_equal(nativePtr, address2 != null ? address2.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			GC.KeepAlive(address2);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Get the header encoded in the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">the header name.    </param>
		/// <returns>the header value or null if it doesn&apos;t exists.    </returns>
		public string GetHeader(string headerName)
		{
			IntPtr stringPtr = linphone_address_get_header(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_param(IntPtr thiz, string paramName);

		/// <summary>
		/// Get the value of a parameter of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="paramName">The name of the parameter.    </param>
		/// <returns>The value of the parameter or null if it doesn&apos;t exists.   
		/// </returns>
		public string GetParam(string paramName)
		{
			IntPtr stringPtr = linphone_address_get_param(nativePtr, paramName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_address_get_uri_param(IntPtr thiz, string uriParamName);

		/// <summary>
		/// Get the value of a parameter of the URI of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uriParamName">The name of the parameter.    </param>
		/// <returns>The value of the parameter or null if it doesn&apos;t exists.   
		/// </returns>
		public string GetUriParam(string uriParamName)
		{
			IntPtr stringPtr = linphone_address_get_uri_param(nativePtr, uriParamName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_address_has_param(IntPtr thiz, string paramName);

		/// <summary>
		/// Tell whether a parameter is present in the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="paramName">The name of the parameter.    </param>
		/// <returns>A boolean value telling whether the parameter is present in the
		/// address </returns>
		public bool HasParam(string paramName)
		{
			bool returnVal = linphone_address_has_param(nativePtr, paramName) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_address_has_uri_param(IntPtr thiz, string uriParamName);

		/// <summary>
		/// Tell whether a parameter is present in the URI of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uriParamName">The name of the parameter.    </param>
		/// <returns>A boolean value telling whether the parameter is present in the URI of
		/// the address </returns>
		public bool HasUriParam(string uriParamName)
		{
			bool returnVal = linphone_address_has_uri_param(nativePtr, uriParamName) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_remove_uri_param(IntPtr thiz, string uriParamName);

		/// <summary>
		/// Removes the value of a parameter of the URI of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uriParamName">The name of the parameter.    </param>
		public void RemoveUriParam(string uriParamName)
		{
			linphone_address_remove_uri_param(nativePtr, uriParamName);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_header(IntPtr thiz, string headerName, string headerValue);

		/// <summary>
		/// Set a header into the address. 
		/// <para>
		/// Headers appear in the URI with &apos;?&apos;, such as
		/// &lt;sip:test@linphone.org?SomeHeader=SomeValue&gt;. 
		/// </para>
		/// </summary>
		/// <param name="headerName">the header name.    </param>
		/// <param name="headerValue">the header value.    </param>
		public void SetHeader(string headerName, string headerValue)
		{
			linphone_address_set_header(nativePtr, headerName, headerValue);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_param(IntPtr thiz, string paramName, string paramValue);

		/// <summary>
		/// Set the value of a parameter of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="paramName">The name of the parameter.    </param>
		/// <param name="paramValue">The new value of the parameter.    </param>
		public void SetParam(string paramName, string paramValue)
		{
			linphone_address_set_param(nativePtr, paramName, paramValue);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_address_set_uri_param(IntPtr thiz, string uriParamName, string uriParamValue);

		/// <summary>
		/// Set the value of a parameter of the URI of the address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uriParamName">The name of the parameter.    </param>
		/// <param name="uriParamValue">The new value of the parameter.    </param>
		public void SetUriParam(string uriParamName, string uriParamValue)
		{
			linphone_address_set_uri_param(nativePtr, uriParamName, uriParamValue);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_address_weak_equal(IntPtr thiz, IntPtr address2);

		/// <summary>
		/// Compare two <see cref="Linphone.Address">Linphone.Address</see> ignoring tags
		/// and headers, basically just domain, username, and port. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address2"><see cref="Linphone.Address">Linphone.Address</see>
		/// object.    </param>
		/// <returns>Boolean value telling if the <see cref="Linphone.Address">
		/// Linphone.Address</see> objects are equal. </returns>
		/// <remarks>See : <see cref="Linphone.Address.Equal()">
		/// Linphone.Address.Equal()</see> </remarks>
		public bool WeakEqual(Linphone.Address address2)
		{
			bool returnVal = linphone_address_weak_equal(nativePtr, address2 != null ? address2.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			GC.KeepAlive(address2);
			return returnVal;
		}
	}
	/// <summary>
	/// Object that represents an alert. 
	/// <para>
	/// Alerts are raised at run-time when particular conditions are met, for example
	/// bad network quality. The full list of available alert types is described by the
	/// <see cref="Linphone.AlertType">Linphone.AlertType</see> enum. An application is
	/// notified of new alerts through the <see cref="Linphone.CoreListener">
	/// Linphone.CoreListener</see> interface. Once raised, the application may use the
	/// <see cref="Linphone.AlertListener">Linphone.AlertListener</see> interface to
	/// get notified when the alert stops. For each kind of alert, a <see cref="Linphone.Dictionary">
	/// Linphone.Dictionary</see> is filled with relevant informations, returned by
	/// <see cref="Linphone.Alert.Informations">Linphone.Alert.Informations</see>. The
	/// keys available are documented per-type in <see cref="Linphone.AlertType">
	/// Linphone.AlertType</see> enum. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Alert : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_alert_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_alert_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_alert_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private AlertListener listener;

		public AlertListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_alert_cbs(linphone_factory_get());
					listener = fromNativePtr<AlertListener>(nativeListener, false, true);
					linphone_alert_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_alert_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_alert_type_to_string(int type);

		/// <summary>
		/// Provide a string describing the alert type. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="type">the <see cref="Linphone.AlertType">Linphone.AlertType</see>
		/// </param>
		/// <returns>a string </returns>
		public static string TypeToString(Linphone.AlertType type)
		{
			IntPtr stringPtr = linphone_alert_type_to_string((int)type);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_alert_get_call(IntPtr thiz);

		/// <summary>
		/// Return the call from the alert. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.Call">Linphone.Call</see> from the alert.   
		/// </returns>
		public Linphone.Call Call
		{
			get
			{
				IntPtr ptr = linphone_alert_get_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_alert_get_end_time(IntPtr thiz);

		/// <summary>
		/// Return the end time of the alert. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the end time of the alert. </returns>
		public long EndTime
		{
			get
			{
				return linphone_alert_get_end_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_alert_get_informations(IntPtr thiz);

		/// <summary>
		/// Return more informations about the alerts. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.Dictionary">Linphone.Dictionary</see> containing
		/// informations about the current alert.    </returns>
		public Linphone.Dictionary Informations
		{
			get
			{
				IntPtr ptr = linphone_alert_get_informations(nativePtr);
				Linphone.Dictionary obj = fromNativePtr<Linphone.Dictionary>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_alert_get_start_time(IntPtr thiz);

		/// <summary>
		/// Return the start time of the alert. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the start time of the alert. </returns>
		public long StartTime
		{
			get
			{
				return linphone_alert_get_start_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_alert_get_state(IntPtr thiz);

		/// <summary>
		/// Return the state of the alert. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if and only if the alert is active. </returns>
		public bool State
		{
			get
			{
				return linphone_alert_get_state(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AlertType linphone_alert_get_type(IntPtr thiz);

		/// <summary>
		/// Return the type of the alert. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.AlertType">Linphone.AlertType</see>
		/// corresponding to the current alert. </returns>
		public Linphone.AlertType Type
		{
			get
			{
				return linphone_alert_get_type(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_alert_clone(IntPtr thiz);

		/// <summary>
		/// Clone the given alert. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A new alert with exactly same informations that param.    </returns>
		public Linphone.Alert Clone()
		{
			IntPtr ptr = linphone_alert_clone(nativePtr);
			Linphone.Alert returnVal = fromNativePtr<Linphone.Alert>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_alert_notify_on_terminated(IntPtr thiz);

		/// <summary>
		/// Notify the alert if it is terminated. 
		/// <para>
		/// </para>
		/// </summary>
		public void NotifyOnTerminated()
		{
			linphone_alert_notify_on_terminated(nativePtr);
			
			
						
		}
	}
	/// <summary>
	/// Object holding audio device information. 
	/// <para>
	/// It contains the name of the device, it&apos;s type if available (Earpiece,
	/// Speaker, Bluetooth, etc..) and capabilities (input, output or both) the name of
	/// the driver that created it (filter in mediastreamer).
	/// You can use the <see cref="Linphone.AudioDevice">Linphone.AudioDevice</see>
	/// objects to configure default input/output devices or do it dynamically during a
	/// call.
	/// To get the list of available devices, use <see cref="Linphone.Core.AudioDevices">
	/// Linphone.Core.AudioDevices</see>. This list will be limited to one device of
	/// each type. Use <see cref="Linphone.Core.ExtendedAudioDevices">
	/// Linphone.Core.ExtendedAudioDevices</see> for a complete list. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class AudioDevice : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AudioDeviceCapabilities linphone_audio_device_get_capabilities(IntPtr thiz);

		/// <summary>
		/// Returns the capabilities of the device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.AudioDeviceCapabilities">
		/// Linphone.AudioDeviceCapabilities</see> of the audio device (RECORD, PLAY or
		/// both) as a bit mask </returns>
		public Linphone.AudioDeviceCapabilities Capabilities
		{
			get
			{
				return linphone_audio_device_get_capabilities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_audio_device_get_device_name(IntPtr thiz);

		/// <summary>
		/// Returns the name of the audio device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the name of the audio device.    </returns>
		public string DeviceName
		{
			get
			{
				IntPtr stringPtr = linphone_audio_device_get_device_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_audio_device_get_driver_name(IntPtr thiz);

		/// <summary>
		/// Returns the driver name used by the device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the name of the driver used by this audio device.    </returns>
		public string DriverName
		{
			get
			{
				IntPtr stringPtr = linphone_audio_device_get_driver_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_audio_device_get_follows_system_routing_policy(IntPtr thiz);

		/// <summary>
		/// Returns whether the audio device automatically follows the system&apos;s audio
		/// routing policy. 
		/// <para>
		/// This capability is available on some system (typically iOS) and might be
		/// convenient to simply specify liblinphone to let the system decide about which
		/// audio route is being used to handle a call. The actual <see cref="Linphone.AudioDeviceType">
		/// Linphone.AudioDeviceType</see> may be unknown at some point, typically when no
		/// calls are running, otherwise it is reflected to be the actual system&apos;s
		/// audio route. 
		/// </para>
		/// </summary>
		/// <returns>true if the audio device automatically follows the system audio
		/// routing policy. </returns>
		public bool FollowsSystemRoutingPolicy
		{
			get
			{
				return linphone_audio_device_get_follows_system_routing_policy(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_audio_device_get_id(IntPtr thiz);

		/// <summary>
		/// Returns the id of the audio device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the id of the audio device.    </returns>
		public string Id
		{
			get
			{
				IntPtr stringPtr = linphone_audio_device_get_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AudioDeviceType linphone_audio_device_get_type(IntPtr thiz);

		/// <summary>
		/// Returns the type of the device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.AudioDeviceType">
		/// Linphone.AudioDeviceType</see> of the audio device (microphone, speaker,
		/// earpiece, bluetooth, etc...) </returns>
		public Linphone.AudioDeviceType Type
		{
			get
			{
				return linphone_audio_device_get_type(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_audio_device_has_capability(IntPtr thiz, int capability);

		/// <summary>
		/// Returns whether or not the audio device has the given capability. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">the <see cref="Linphone.AudioDeviceCapabilities">
		/// Linphone.AudioDeviceCapabilities</see> to check </param>
		/// <returns>true if the audio device has the capability, false otherwise </returns>
		public bool HasCapability(Linphone.AudioDeviceCapabilities capability)
		{
			bool returnVal = linphone_audio_device_has_capability(nativePtr, (int)capability) == (char)0 ? false : true;
			
						return returnVal;
		}
	}
	/// <summary>
	/// Object holding authentication information. 
	/// <para>
	/// In most case, authentication information consists of a username and password.
	/// If realm isn&apos;t set, it will be deduced automatically from the first
	/// authentication challenge as for the hash algorithm. Sometimes, a userid is
	/// required by the proxy and then domain can be useful to discriminate different
	/// credentials. You can also use this object if you need to use a client
	/// certificate.
	/// Once created and filled, a <see cref="Linphone.AuthInfo">
	/// Linphone.AuthInfo</see> must be added to the <see cref="Linphone.Core">
	/// Linphone.Core</see> in order to become known and used automatically when
	/// needed. Use <see cref="Linphone.Core.AddAuthInfo()">
	/// Linphone.Core.AddAuthInfo()</see> for that purpose.
	/// The <see cref="Linphone.Core">Linphone.Core</see> object can take the
	/// initiative to request authentication information when needed to the application
	/// through the authentication_requested() callback of it&apos;s <see cref="Linphone.CoreListener">
	/// Linphone.CoreListener</see>.
	/// The application can respond to this information request later using <see cref="Linphone.Core.AddAuthInfo()">
	/// Linphone.Core.AddAuthInfo()</see>. This will unblock all pending authentication
	/// transactions and retry them with authentication headers. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class AuthInfo : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_algorithm(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_algorithm(IntPtr thiz, string algorithm);

		/// <summary>
		/// Gets the algorithm. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The algorithm.    </returns>
		public string Algorithm
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_algorithm(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_algorithm(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_available_algorithms(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_available_algorithms(IntPtr thiz, IntPtr algorithms);

		/// <summary>
		/// Gets all available algorithms. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of available algorithms.      </returns>
		public IEnumerable<string> AvailableAlgorithms
		{
			get
			{
				return MarshalStringArray(linphone_auth_info_get_available_algorithms(nativePtr));
			}
			set
			{
				linphone_auth_info_set_available_algorithms(nativePtr, StringArrayToBctbxList(value));
				CleanStringArrayPtrs();
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_domain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_domain(IntPtr thiz, string domain);

		/// <summary>
		/// Gets the domain. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The domain.    </returns>
		public string Domain
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_domain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_ha1(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_ha1(IntPtr thiz, string ha1);

		/// <summary>
		/// Gets the ha1. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The ha1.    </returns>
		public string Ha1
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_ha1(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_ha1(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_password(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_password(IntPtr thiz, string password);

		/// <summary>
		/// Gets the password. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The password.    </returns>
		public string Password
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_password(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_password(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_realm(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_realm(IntPtr thiz, string realm);

		/// <summary>
		/// Gets the realm. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The realm.    </returns>
		public string Realm
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_realm(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_realm(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_tls_cert(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_tls_cert(IntPtr thiz, string tlsCert);

		/// <summary>
		/// Gets the TLS certificate. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The TLS certificate.    </returns>
		public string TlsCert
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_tls_cert(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_tls_cert(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_tls_cert_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_tls_cert_path(IntPtr thiz, string tlsCertPath);

		/// <summary>
		/// Gets the TLS certificate path. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The TLS certificate path.    </returns>
		public string TlsCertPath
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_tls_cert_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_tls_cert_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_tls_key(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_tls_key(IntPtr thiz, string tlsKey);

		/// <summary>
		/// Gets the TLS key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The TLS key.    </returns>
		public string TlsKey
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_tls_key(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_tls_key(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_tls_key_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_tls_key_path(IntPtr thiz, string tlsKeyPath);

		/// <summary>
		/// Gets the TLS key path. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The TLS key path.    </returns>
		public string TlsKeyPath
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_tls_key_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_tls_key_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_userid(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_userid(IntPtr thiz, string userId);

		/// <summary>
		/// Gets the user id. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The user id.    </returns>
		public string Userid
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_userid(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_userid(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_get_username(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_set_username(IntPtr thiz, string username);

		/// <summary>
		/// Gets the username. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The username.    </returns>
		public string Username
		{
			get
			{
				IntPtr stringPtr = linphone_auth_info_get_username(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_auth_info_set_username(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_add_available_algorithm(IntPtr thiz, string algorithm);

		/// <summary>
		/// Add an unique algorithm in the the available algorithms list : Algorithms that
		/// already exist will not be added. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="algorithm">The algorithm to add.    </param>
		public void AddAvailableAlgorithm(string algorithm)
		{
			linphone_auth_info_add_available_algorithm(nativePtr, algorithm);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_auth_info_clear_available_algorithms(IntPtr thiz);

		/// <summary>
		/// Remove all algorithms from the available algorithms list. 
		/// <para>
		/// </para>
		/// </summary>
		public void ClearAvailableAlgorithms()
		{
			linphone_auth_info_clear_available_algorithms(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_auth_info_clone(IntPtr thiz);

		/// <summary>
		/// Instantiates a new auth info with values from source. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The newly created <see cref="Linphone.AuthInfo">
		/// Linphone.AuthInfo</see> object.    </returns>
		public Linphone.AuthInfo Clone()
		{
			IntPtr ptr = linphone_auth_info_clone(nativePtr);
			Linphone.AuthInfo returnVal = fromNativePtr<Linphone.AuthInfo>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_auth_info_is_equal_but_algorithms(IntPtr thiz, IntPtr authInfo2);

		/// <summary>
		/// Check if Authinfos are the same without taking account algorithms. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="authInfo2">The second <see cref="Linphone.AuthInfo">
		/// Linphone.AuthInfo</see> object.    </param>
		/// <returns>true if all fields (Username, UserId, Realm, Domain) are the same.
		/// </returns>
		public bool IsEqualButAlgorithms(Linphone.AuthInfo authInfo2)
		{
			bool returnVal = linphone_auth_info_is_equal_but_algorithms(nativePtr, authInfo2 != null ? authInfo2.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			GC.KeepAlive(authInfo2);
			return returnVal;
		}
	}
	/// <summary>
	/// The object representing a data buffer. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Buffer : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_buffer_new_from_data(uint data, long size);

		/// <summary>
		/// Create a new <see cref="Linphone.Buffer">Linphone.Buffer</see> object from
		/// existing data. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="data">The initial data to store in the LinphoneBuffer.    </param>
		/// <param name="size">The size of the initial data to stroe in the LinphoneBuffer.
		/// </param>
		/// <returns>A new <see cref="Linphone.Buffer">Linphone.Buffer</see> object.   
		/// </returns>
		public static Linphone.Buffer NewFromData(uint data, long size)
		{
			IntPtr ptr = linphone_buffer_new_from_data(data, size);
			Linphone.Buffer returnVal = fromNativePtr<Linphone.Buffer>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_buffer_new_from_string(string data);

		/// <summary>
		/// Create a new <see cref="Linphone.Buffer">Linphone.Buffer</see> object from a
		/// string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="data">The initial string content of the LinphoneBuffer.    </param>
		/// <returns>A new <see cref="Linphone.Buffer">Linphone.Buffer</see> object.   
		/// </returns>
		public static Linphone.Buffer NewFromString(string data)
		{
			IntPtr ptr = linphone_buffer_new_from_string(data);
			Linphone.Buffer returnVal = fromNativePtr<Linphone.Buffer>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_buffer_get_content(IntPtr thiz);

		/// <summary>
		/// Get the content of the data buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The content of the data buffer.    </returns>
		public uint Content
		{
			get
			{
				return linphone_buffer_get_content(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_buffer_is_empty(IntPtr thiz);

		/// <summary>
		/// Tell whether the <see cref="Linphone.Buffer">Linphone.Buffer</see> is empty. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether the <see cref="Linphone.Buffer">
		/// Linphone.Buffer</see> is empty or not. </returns>
		public bool IsEmpty
		{
			get
			{
				return linphone_buffer_is_empty(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_buffer_get_size(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_buffer_set_size(IntPtr thiz, long size);

		/// <summary>
		/// Get the size of the content of the data buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The size of the content of the data buffer. </returns>
		public long Size
		{
			get
			{
				return linphone_buffer_get_size(nativePtr);
			}
			set
			{
				linphone_buffer_set_size(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_buffer_get_string_content(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_buffer_set_string_content(IntPtr thiz, string content);

		/// <summary>
		/// Get the string content of the data buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The string content of the data buffer.    </returns>
		public string StringContent
		{
			get
			{
				IntPtr stringPtr = linphone_buffer_get_string_content(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_buffer_set_string_content(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_buffer_set_content(IntPtr thiz, uint content, long size);

		/// <summary>
		/// Set the content of the data buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">The content of the data buffer.    </param>
		/// <param name="size">The size of the content of the data buffer. </param>
		public void SetContent(uint content, long size)
		{
			linphone_buffer_set_content(nativePtr, content, size);
			
			
						
		}
	}
	/// <summary>
	/// This object represents a call issued or received by the <see cref="Linphone.Core">
	/// Linphone.Core</see>. 
	/// <para>
	/// Linphone only allows at most one active call at any given time and it will be
	/// in <see cref="Linphone.CallState.StreamsRunning">
	/// Linphone.CallState.StreamsRunning</see>. However, if the core is locally
	/// hosting a <see cref="Linphone.Conference">Linphone.Conference</see>, you may
	/// have some or all the calls in the conference in <see cref="Linphone.CallState.StreamsRunning">
	/// Linphone.CallState.StreamsRunning</see> as well as an additional active call
	/// outside of the conference in <see cref="Linphone.CallState.StreamsRunning">
	/// Linphone.CallState.StreamsRunning</see> if the local participant of the <see cref="Linphone.Conference">
	/// Linphone.Conference</see> is not part of it.
	/// You can get the <see cref="Linphone.CallState">Linphone.CallState</see> of the
	/// call using <see cref="Linphone.Call.State">Linphone.Call.State</see>, it&apos;s
	/// current <see cref="Linphone.CallParams">Linphone.CallParams</see> with <see cref="Linphone.Call.CurrentParams">
	/// Linphone.Call.CurrentParams</see> and the latest statistics by calling <see cref="Linphone.Call.AudioStats">
	/// Linphone.Call.AudioStats</see> or <see cref="Linphone.Call.VideoStats">
	/// Linphone.Call.VideoStats</see>. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Call : LinphoneObject
	{
		/// Get the native window handle of the video window, casted as an unsigned long.
		public string NativeVideoWindowIdString
		{
			get
			{
				return Marshal.PtrToStringUni(linphone_call_get_native_video_window_id(nativePtr));
			}
			set
			{
				IntPtr string_ptr_to_remove = linphone_call_get_native_video_window_id(nativePtr);
				IntPtr string_ptr = Marshal.StringToHGlobalUni(value);
				linphone_call_set_native_video_window_id(nativePtr, string_ptr);
				if(string_ptr_to_remove != IntPtr.Zero)
					Marshal.FreeHGlobal(string_ptr_to_remove);
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_call_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private CallListener listener;

		public CallListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_call_cbs(linphone_factory_get());
					listener = fromNativePtr<CallListener>(nativeListener, false, true);
					linphone_call_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_call_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_audio_stats(IntPtr thiz);

		/// <summary>
		/// Returns a copy of the call statistics for the audio stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.CallStats">Linphone.CallStats</see> object for
		/// the audio stream or null if it isn&apos;t available.       </returns>
		public Linphone.CallStats AudioStats
		{
			get
			{
				IntPtr ptr = linphone_call_get_audio_stats(nativePtr);
				Linphone.CallStats obj = fromNativePtr<Linphone.CallStats>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_authentication_token(IntPtr thiz);

		/// <summary>
		/// Returns the ZRTP authentication token to verify. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the authentication token to verify or null if ZRTP isn&apos;t enabled.
		///    </returns>
		public string AuthenticationToken
		{
			get
			{
				IntPtr stringPtr = linphone_call_get_authentication_token(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_get_authentication_token_verified(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_authentication_token_verified(IntPtr thiz, char verified);

		/// <summary>
		/// Returns whether ZRTP authentication token is verified. 
		/// <para>
		/// If not, it must be verified by users as described in ZRTP procedure. Once done,
		/// the application must inform of the results with <see cref="Linphone.Call.AuthenticationTokenVerified">
		/// Linphone.Call.AuthenticationTokenVerified</see>. 
		/// </para>
		/// </summary>
		/// <returns>true if authentication token is verifed, false otherwise. </returns>
		public bool AuthenticationTokenVerified
		{
			get
			{
				return linphone_call_get_authentication_token_verified(nativePtr) != 0;
			}
			set
			{
				linphone_call_set_authentication_token_verified(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_get_average_quality(IntPtr thiz);

		/// <summary>
		/// Returns call quality averaged over all the duration of the call. 
		/// <para>
		/// See <see cref="Linphone.Call.CurrentQuality">Linphone.Call.CurrentQuality</see>
		/// for more details about quality measurement. 
		/// </para>
		/// </summary>
		/// <returns>the call average quality since tbe beginning of the call. </returns>
		public float AverageQuality
		{
			get
			{
				return linphone_call_get_average_quality(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_call_log(IntPtr thiz);

		/// <summary>
		/// Gets the call log associated to this call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.CallLog">Linphone.CallLog</see> associated
		/// with the specified <see cref="Linphone.Call">Linphone.Call</see>.    </returns>
		public Linphone.CallLog CallLog
		{
			get
			{
				IntPtr ptr = linphone_call_get_call_log(nativePtr);
				Linphone.CallLog obj = fromNativePtr<Linphone.CallLog>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_camera_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_enable_camera(IntPtr thiz, char enabled);

		/// <summary>
		/// Returns if camera pictures are allowed to be sent to the remote party. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if local video stream is being sent, false otherwise. </returns>
		public bool CameraEnabled
		{
			get
			{
				return linphone_call_camera_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_enable_camera(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_chat_room(IntPtr thiz);

		/// <summary>
		/// Create a new chat room for real time messaging from a call if not already
		/// existing, else return existing one. 
		/// <para>
		/// No reference is given to the caller: the chat room will be deleted when the
		/// call is ended. 
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see> where real time
		/// messaging can take place or null if chat room couldn&apos;t be created.   
		/// </returns>
		public Linphone.ChatRoom ChatRoom
		{
			get
			{
				IntPtr ptr = linphone_call_get_chat_room(nativePtr);
				Linphone.ChatRoom obj = fromNativePtr<Linphone.ChatRoom>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_conference(IntPtr thiz);

		/// <summary>
		/// Return the associated conference object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer on <see cref="Linphone.Conference">Linphone.Conference</see>
		/// or null if the call is not part of any conference.    </returns>
		public Linphone.Conference Conference
		{
			get
			{
				IntPtr ptr = linphone_call_get_conference(nativePtr);
				Linphone.Conference obj = fromNativePtr<Linphone.Conference>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_core(IntPtr thiz);

		/// <summary>
		/// Get the core that has created the specified call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Core">Linphone.Core</see> object that has
		/// created the specified call.    </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_call_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_current_params(IntPtr thiz);

		/// <summary>
		/// Returns current parameters associated to the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the current <see cref="Linphone.CallParams">Linphone.CallParams</see>
		/// of this call.    </returns>
		public Linphone.CallParams CurrentParams
		{
			get
			{
				IntPtr ptr = linphone_call_get_current_params(nativePtr);
				Linphone.CallParams obj = fromNativePtr<Linphone.CallParams>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_get_current_quality(IntPtr thiz);

		/// <summary>
		/// Obtain real-time quality rating of the call. 
		/// <para>
		/// Based on local RTP statistics and RTCP feedback, a quality rating is computed
		/// and updated during all the duration of the call. This function returns its
		/// value at the time of the function call. It is expected that the rating is
		/// updated at least every 5 seconds or so. The rating is a floating point number
		/// comprised between 0 and 5.
		/// 4-5 = good quality  3-4 = average quality  2-3 = poor quality  1-2 = very poor
		/// quality  0-1 = can&apos;t be worse, mostly unusable 
		/// </para>
		/// </summary>
		/// <returns>The function returns -1 if no quality measurement is available, for
		/// example if no active audio stream exist. Otherwise it returns the quality
		/// rating. </returns>
		public float CurrentQuality
		{
			get
			{
				return linphone_call_get_current_quality(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.CallDir linphone_call_get_dir(IntPtr thiz);

		/// <summary>
		/// Returns direction of the call (incoming or outgoing). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.CallDir">Linphone.CallDir</see> </returns>
		public Linphone.CallDir Dir
		{
			get
			{
				return linphone_call_get_dir(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_diversion_address(IntPtr thiz);

		/// <summary>
		/// Returns the diversion address associated to this call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the diversion address as <see cref="Linphone.Address">
		/// Linphone.Address</see> or null.    </returns>
		public Linphone.Address DiversionAddress
		{
			get
			{
				IntPtr ptr = linphone_call_get_diversion_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_get_duration(IntPtr thiz);

		/// <summary>
		/// Returns call&apos;s duration in seconds. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the call&apos;s duration in seconds. </returns>
		public int Duration
		{
			get
			{
				return linphone_call_get_duration(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_echo_cancellation_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_enable_echo_cancellation(IntPtr thiz, char enable);

		/// <summary>
		/// Returns if echo cancellation is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if echo cancellation is enabled, false otherwise. </returns>
		public bool EchoCancellationEnabled
		{
			get
			{
				return linphone_call_echo_cancellation_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_enable_echo_cancellation(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_echo_limiter_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_enable_echo_limiter(IntPtr thiz, char enable);

		/// <summary>
		/// Returns if echo limiter is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if echo limiter is enabled, false otherwise. </returns>
		public bool EchoLimiterEnabled
		{
			get
			{
				return linphone_call_echo_limiter_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_enable_echo_limiter(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_error_info(IntPtr thiz);

		/// <summary>
		/// Returns full details about call errors or termination reasons. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.ErrorInfo">Linphone.ErrorInfo</see> object holding
		/// the reason error.    </returns>
		public Linphone.ErrorInfo ErrorInfo
		{
			get
			{
				IntPtr ptr = linphone_call_get_error_info(nativePtr);
				Linphone.ErrorInfo obj = fromNativePtr<Linphone.ErrorInfo>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_input_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_input_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the current input device for this call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.AudioDevice">Linphone.AudioDevice</see> used
		/// by this call as input or null if there is currently no soundcard configured
		/// (depending on the state of the call)    </returns>
		public Linphone.AudioDevice InputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_call_get_input_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_call_set_input_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_is_recording(IntPtr thiz);

		/// <summary>
		/// Returns whether or not the call is currently being recorded. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if recording is in progress, false otherwise </returns>
		/// deprecated : 15/09/2021 Use <see cref="Linphone.CallParams.IsRecording()">
		/// Linphone.CallParams.IsRecording()</see> instead. 
		public bool IsRecording
		{
			get
			{
				return linphone_call_is_recording(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_get_microphone_muted(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_microphone_muted(IntPtr thiz, char muted);

		/// <summary>
		/// Get microphone muted state. 
		/// <para>
		/// Note that the microphone may be disabled globally if false was given to <see cref="Linphone.Core.EnableMic()">
		/// Linphone.Core.EnableMic()</see>. 
		/// </para>
		/// </summary>
		/// <returns>The microphone muted state. </returns>
		/// <remarks>Warning : This method returns state of the mute capability of the call
		/// passed as argument. If this call is part of a conference, it is strongly
		/// recommended to call <see cref="Linphone.Conference.MicrophoneMuted">
		/// Linphone.Conference.MicrophoneMuted</see> to know whether this device is muted
		/// or not. </remarks> 
		public bool MicrophoneMuted
		{
			get
			{
				return linphone_call_get_microphone_muted(nativePtr) != 0;
			}
			set
			{
				linphone_call_set_microphone_muted(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_get_microphone_volume_gain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_microphone_volume_gain(IntPtr thiz, float volume);

		/// <summary>
		/// Get microphone volume gain. 
		/// <para>
		/// If the sound backend supports it, the returned gain is equal to the gain set
		/// with the system mixer. 
		/// </para>
		/// </summary>
		/// <returns>double Percentage of the max supported volume gain. Valid values are
		/// in [ 0.0 : 1.0 ]. In case of failure, a negative value is returned </returns>
		public float MicrophoneVolumeGain
		{
			get
			{
				return linphone_call_get_microphone_volume_gain(nativePtr);
			}
			set
			{
				linphone_call_set_microphone_volume_gain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_native_video_window_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_native_video_window_id(IntPtr thiz, IntPtr windowId);

		/// <summary>
		/// Get the native window handle of the video window, casted as an unsigned long. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the native video window id (type may vary depending on platform).   
		/// </returns>
		public IntPtr NativeVideoWindowId
		{
			get
			{
				return linphone_call_get_native_video_window_id(nativePtr);
			}
			set
			{
				linphone_call_set_native_video_window_id(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_output_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_output_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the current output device for this call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.AudioDevice">Linphone.AudioDevice</see> used
		/// by this call as output or null if there is currently no soundcard configured
		/// (depending on the state of the call)    </returns>
		public Linphone.AudioDevice OutputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_call_get_output_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_call_set_output_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_params(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Returns local parameters associated with the call. 
		/// <para>
		/// This is typically the parameters passed at call initiation to <see cref="Linphone.Core.InviteAddressWithParams()">
		/// Linphone.Core.InviteAddressWithParams()</see> or <see cref="Linphone.Call.AcceptWithParams()">
		/// Linphone.Call.AcceptWithParams()</see>, or some default parameters if no <see cref="Linphone.CallParams">
		/// Linphone.CallParams</see> was explicitely passed during call initiation. 
		/// </para>
		/// </summary>
		/// <returns>the call&apos;s local parameters.    </returns>
		public Linphone.CallParams Params
		{
			get
			{
				IntPtr ptr = linphone_call_get_params(nativePtr);
				Linphone.CallParams obj = fromNativePtr<Linphone.CallParams>(ptr, true);
				return obj;
			}
			set
			{
				linphone_call_set_params(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_get_play_volume(IntPtr thiz);

		/// <summary>
		/// Get the mesured playback volume level (received from remote) in dbm0. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>float Volume level in percentage. </returns>
		public float PlayVolume
		{
			get
			{
				return linphone_call_get_play_volume(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_player(IntPtr thiz);

		/// <summary>
		/// Gets a player associated with the call to play a local file and stream it to
		/// the remote peer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.Player">Linphone.Player</see> object   
		/// </returns>
		public Linphone.Player Player
		{
			get
			{
				IntPtr ptr = linphone_call_get_player(nativePtr);
				Linphone.Player obj = fromNativePtr<Linphone.Player>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.Reason linphone_call_get_reason(IntPtr thiz);

		/// <summary>
		/// Returns the reason for a call termination (either error or normal termination) 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Reason">Linphone.Reason</see> of the call
		/// termination. </returns>
		public Linphone.Reason Reason
		{
			get
			{
				return linphone_call_get_reason(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_get_record_volume(IntPtr thiz);

		/// <summary>
		/// Get the mesured record volume level (sent to remote) in dbm0. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>float Volume level in percentage. </returns>
		public float RecordVolume
		{
			get
			{
				return linphone_call_get_record_volume(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_refer_to(IntPtr thiz);

		/// <summary>
		/// Gets the refer-to uri (if the call was transfered). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The refer-to uri of the call (if it was transfered).    </returns>
		public string ReferTo
		{
			get
			{
				IntPtr stringPtr = linphone_call_get_refer_to(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_remote_address(IntPtr thiz);

		/// <summary>
		/// Returns the remote address associated to this call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Address">Linphone.Address</see> of the remote
		/// end of the call.    </returns>
		public Linphone.Address RemoteAddress
		{
			get
			{
				IntPtr ptr = linphone_call_get_remote_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_remote_address_as_string(IntPtr thiz);

		/// <summary>
		/// Returns the remote address associated to this call as a string. 
		/// <para>
		/// The result string must be freed by user using ms_free(). 
		/// </para>
		/// </summary>
		/// <returns>the remote address as a string.       </returns>
		/// deprecated : 06/07/2020 use <see cref="Linphone.Call.RemoteAddress">
		/// Linphone.Call.RemoteAddress</see> instead. 
		public string RemoteAddressAsString
		{
			get
			{
				IntPtr stringPtr = linphone_call_get_remote_address_as_string(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_remote_contact(IntPtr thiz);

		/// <summary>
		/// Returns the far end&apos;s sip contact as a string, if available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the remote contact or null.    </returns>
		public string RemoteContact
		{
			get
			{
				IntPtr stringPtr = linphone_call_get_remote_contact(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_remote_contact_address(IntPtr thiz);

		/// <summary>
		/// Returns the far end&apos;s sip contact as an address, if available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the remote contact as a <see cref="Linphone.Address">
		/// Linphone.Address</see> or null.    </returns>
		public Linphone.Address RemoteContactAddress
		{
			get
			{
				IntPtr ptr = linphone_call_get_remote_contact_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_remote_params(IntPtr thiz);

		/// <summary>
		/// Returns call parameters proposed by remote. 
		/// <para>
		/// This is useful when receiving an incoming call, to know whether the remote
		/// party supports video, encryption or whatever.
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.CallParams">Linphone.CallParams</see>
		/// suggested by the remote or null.    </returns>
		public Linphone.CallParams RemoteParams
		{
			get
			{
				IntPtr ptr = linphone_call_get_remote_params(nativePtr);
				Linphone.CallParams obj = fromNativePtr<Linphone.CallParams>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_remote_user_agent(IntPtr thiz);

		/// <summary>
		/// Returns the far end&apos;s user agent description string, if available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the remote user agent or null.    </returns>
		public string RemoteUserAgent
		{
			get
			{
				IntPtr stringPtr = linphone_call_get_remote_user_agent(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_replaced_call(IntPtr thiz);

		/// <summary>
		/// Returns the call object this call is replacing, if any. 
		/// <para>
		/// Call replacement can occur during call transfers. By default, the core
		/// automatically terminates the replaced call and accept the new one. This
		/// function allows the application to know whether a new incoming call is a one
		/// that replaces another one. 
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Call">Linphone.Call</see> object this call is
		/// replacing or null.    </returns>
		public Linphone.Call ReplacedCall
		{
			get
			{
				IntPtr ptr = linphone_call_get_replaced_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_request_address(IntPtr thiz);

		/// <summary>
		/// The address to which the call has been sent, taken directly from the SIP URI of
		/// the INVITE. 
		/// <para>
		/// Usually equal to the To field, except when e.g. using a fallback contact
		/// address. You should probably use getToAddress() instead, unless you know what
		/// you&apos;re doing. 
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Address">Linphone.Address</see> matching the
		/// URI of the INVITE request.    </returns>
		public Linphone.Address RequestAddress
		{
			get
			{
				IntPtr ptr = linphone_call_get_request_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_get_speaker_muted(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_speaker_muted(IntPtr thiz, char muted);

		/// <summary>
		/// Get speaker muted state. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The speaker muted state. </returns>
		public bool SpeakerMuted
		{
			get
			{
				return linphone_call_get_speaker_muted(nativePtr) != 0;
			}
			set
			{
				linphone_call_set_speaker_muted(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_get_speaker_volume_gain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_speaker_volume_gain(IntPtr thiz, float volume);

		/// <summary>
		/// Get speaker volume gain. 
		/// <para>
		/// If the sound backend supports it, the returned gain is equal to the gain set
		/// with the system mixer. 
		/// </para>
		/// </summary>
		/// <returns>Percentage of the max supported volume gain. Valid values are in [ 0.0
		/// : 1.0 ]. In case of failure, a negative value is returned </returns>
		public float SpeakerVolumeGain
		{
			get
			{
				return linphone_call_get_speaker_volume_gain(nativePtr);
			}
			set
			{
				linphone_call_set_speaker_volume_gain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.CallState linphone_call_get_state(IntPtr thiz);

		/// <summary>
		/// Retrieves the call&apos;s current state. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the current <see cref="Linphone.CallState">Linphone.CallState</see> of
		/// this call. </returns>
		public Linphone.CallState State
		{
			get
			{
				return linphone_call_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_get_stream_count(IntPtr thiz);

		/// <summary>
		/// Returns the number of stream for the given call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the amount of streams for this call. </returns>
		public int StreamCount
		{
			get
			{
				return linphone_call_get_stream_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_text_stats(IntPtr thiz);

		/// <summary>
		/// Returns a copy of the call statistics for the text stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.CallStats">Linphone.CallStats</see> object for
		/// the text stream or null if it isn&apos;t available.       </returns>
		public Linphone.CallStats TextStats
		{
			get
			{
				IntPtr ptr = linphone_call_get_text_stats(nativePtr);
				Linphone.CallStats obj = fromNativePtr<Linphone.CallStats>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_to_address(IntPtr thiz);

		/// <summary>
		/// Returns the to address with its headers associated to this call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Address">Linphone.Address</see> matching the
		/// TO of the call.    </returns>
		public Linphone.Address ToAddress
		{
			get
			{
				IntPtr ptr = linphone_call_get_to_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.CallState linphone_call_get_transfer_state(IntPtr thiz);

		/// <summary>
		/// Returns the current transfer state, if a transfer has been initiated from this
		/// call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>See : linphone_core_transfer_call ,
		/// linphone_core_transfer_call_to_another </remarks>
		/// <returns>the <see cref="Linphone.CallState">Linphone.CallState</see>. </returns>
		public Linphone.CallState TransferState
		{
			get
			{
				return linphone_call_get_transfer_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_transfer_target_call(IntPtr thiz);

		/// <summary>
		/// When this call has received a transfer request, returns the new call that was
		/// automatically created as a result of the transfer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the transfer <see cref="Linphone.Call">Linphone.Call</see> created.   
		/// </returns>
		public Linphone.Call TransferTargetCall
		{
			get
			{
				IntPtr ptr = linphone_call_get_transfer_target_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_transferer_call(IntPtr thiz);

		/// <summary>
		/// Gets the transferer if this call was started automatically as a result of an
		/// incoming transfer request. 
		/// <para>
		/// The call in which the transfer request was received is returned in this case. 
		/// </para>
		/// </summary>
		/// <returns>The transferer <see cref="Linphone.Call">Linphone.Call</see> if the
		/// specified call was started automatically as a result of an incoming transfer
		/// request, null otherwise.    </returns>
		public Linphone.Call TransfererCall
		{
			get
			{
				IntPtr ptr = linphone_call_get_transferer_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_video_source(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_set_video_source(IntPtr thiz, IntPtr descriptor);

		/// <summary>
		/// Gets the video source of a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.VideoSourceDescriptor">
		/// Linphone.VideoSourceDescriptor</see> describing the video source that is set   
		/// </returns>
		public Linphone.VideoSourceDescriptor VideoSource
		{
			get
			{
				IntPtr ptr = linphone_call_get_video_source(nativePtr);
				Linphone.VideoSourceDescriptor obj = fromNativePtr<Linphone.VideoSourceDescriptor>(ptr, true);
				return obj;
			}
			set
			{
				linphone_call_set_video_source(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_video_stats(IntPtr thiz);

		/// <summary>
		/// Returns a copy of the call statistics for the video stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.CallStats">Linphone.CallStats</see> object for
		/// the video stream or null if it isn&apos;t available.       </returns>
		public Linphone.CallStats VideoStats
		{
			get
			{
				IntPtr ptr = linphone_call_get_video_stats(nativePtr);
				Linphone.CallStats obj = fromNativePtr<Linphone.CallStats>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_accept(IntPtr thiz);

		/// <summary>
		/// Accept an incoming call. 
		/// <para>
		/// Basically the application is notified of incoming calls within the
		/// call_state_changed callback of the LinphoneCoreVTable structure, where it will
		/// receive a <see cref="Linphone.CallDir.Incoming">Linphone.CallDir.Incoming</see>
		/// event with the associated <see cref="Linphone.Call">Linphone.Call</see> object.
		/// The application can later accept the call using this method. 
		/// </para>
		/// </summary>
		/// <returns>0 on success, -1 on failure </returns>
		public void Accept()
		{
			int exception_result = linphone_call_accept(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Accept returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_accept_early_media(IntPtr thiz);

		/// <summary>
		/// Accept an early media session for an incoming call. 
		/// <para>
		/// This is identical as calling <see cref="Linphone.Call.AcceptEarlyMediaWithParams()">
		/// Linphone.Call.AcceptEarlyMediaWithParams()</see> with null parameters. 
		/// </para>
		/// </summary>
		/// <returns>0 if successful, -1 otherwise </returns>
		/// <remarks>See : <see cref="Linphone.Call.AcceptEarlyMediaWithParams()">
		/// Linphone.Call.AcceptEarlyMediaWithParams()</see> </remarks>
		public void AcceptEarlyMedia()
		{
			int exception_result = linphone_call_accept_early_media(nativePtr);
			if (exception_result != 0) throw new LinphoneException("AcceptEarlyMedia returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_accept_early_media_with_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// When receiving an incoming, accept to start a media session as early-media. 
		/// <para>
		/// This means the call is not accepted but audio &amp; video streams can be
		/// established if the remote party supports early media. However, unlike after
		/// call acceptance, mic and camera input are not sent during early-media, though
		/// received audio &amp; video are played normally. The call can then later be
		/// fully accepted using <see cref="Linphone.Call.Accept()">
		/// Linphone.Call.Accept()</see> or <see cref="Linphone.Call.AcceptWithParams()">
		/// Linphone.Call.AcceptWithParams()</see>. 
		/// </para>
		/// </summary>
		/// <param name="parameters">The call parameters to use (can be null).    </param>
		/// <returns>0 if successful, -1 otherwise </returns>
		public void AcceptEarlyMediaWithParams(Linphone.CallParams parameters)
		{
			int exception_result = linphone_call_accept_early_media_with_params(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AcceptEarlyMediaWithParams returned value" + exception_result);
			
			GC.KeepAlive(parameters);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_accept_update(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Accept call modifications initiated by other end. 
		/// <para>
		/// This call may be performed in response to a #LinphoneCallUpdatedByRemote state
		/// notification. When such notification arrives, the application can decide to
		/// call <see cref="Linphone.Call.DeferUpdate()">Linphone.Call.DeferUpdate()</see>
		/// so that it can have the time to prompt the user. <see cref="Linphone.Call.RemoteParams">
		/// Linphone.Call.RemoteParams</see> can be used to get information about the call
		/// parameters requested by the other party, such as whether a video stream is
		/// requested.
		/// When the user accepts or refuse the change, <see cref="Linphone.Call.AcceptUpdate()">
		/// Linphone.Call.AcceptUpdate()</see> can be done to answer to the other party. If
		/// params is null, then the same call parameters established before the update
		/// request will continue to be used (no change). If params is not null, then the
		/// update will be accepted according to the parameters passed. Typical example is
		/// when a user accepts to start video, then params should indicate that video
		/// stream should be used (see <see cref="Linphone.CallParams.EnableVideo()">
		/// Linphone.CallParams.EnableVideo()</see>). 
		/// </para>
		/// </summary>
		/// <param name="parameters">A <see cref="Linphone.CallParams">
		/// Linphone.CallParams</see> object describing the call parameters to accept.   
		/// </param>
		/// <returns>0 if successful, -1 otherwise (actually when this function call is
		/// performed outside ot #LinphoneCallUpdatedByRemote state) </returns>
		public void AcceptUpdate(Linphone.CallParams parameters)
		{
			int exception_result = linphone_call_accept_update(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AcceptUpdate returned value" + exception_result);
			
			GC.KeepAlive(parameters);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_accept_with_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Accept an incoming call, with parameters. 
		/// <para>
		/// Basically the application is notified of incoming calls within the
		/// call_state_changed callback of the LinphoneCoreVTable structure, where it will
		/// receive a <see cref="Linphone.CallDir.Incoming">Linphone.CallDir.Incoming</see>
		/// event with the associated <see cref="Linphone.Call">Linphone.Call</see> object.
		/// The application can later accept the call using this method. 
		/// </para>
		/// </summary>
		/// <param name="parameters">The specific parameters for this call, for example
		/// whether video is accepted or not. Use null to use default parameters.   
		/// </param>
		/// <returns>0 on success, -1 on failure </returns>
		public void AcceptWithParams(Linphone.CallParams parameters)
		{
			int exception_result = linphone_call_accept_with_params(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AcceptWithParams returned value" + exception_result);
			
			GC.KeepAlive(parameters);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_asked_to_autoanswer(IntPtr thiz);

		/// <summary>
		/// Tell whether a call has been asked to autoanswer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether the call has been asked to autoanswer
		/// </returns>
		public bool AskedToAutoanswer()
		{
			bool returnVal = linphone_call_asked_to_autoanswer(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_cancel_dtmfs(IntPtr thiz);

		/// <summary>
		/// Stop current DTMF sequence sending. 
		/// <para>
		/// Please note that some DTMF could be already sent, depending on when this
		/// function call is delayed from <see cref="Linphone.Call.SendDtmfs()">
		/// Linphone.Call.SendDtmfs()</see>. This function will be automatically called if
		/// call state change to anything but LinphoneCallStreamsRunning. 
		/// </para>
		/// </summary>
		public void CancelDtmfs()
		{
			linphone_call_cancel_dtmfs(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_confirm_go_clear(IntPtr thiz);

		/// <summary>
		/// Method to be called after the user confirm that he/she is notifed of the on
		/// going Go Clear procedure. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : this operation must be imperatevely initiate by a user
		/// action on sending of the GoClear ACK </remarks> 
		public void ConfirmGoClear()
		{
			linphone_call_confirm_go_clear(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_create_native_video_window_id(IntPtr thiz);

		/// <summary>
		/// Create a native video window id where the video is to be displayed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the native video window id (type may vary depending on platform).   
		/// </returns>
		public IntPtr CreateNativeVideoWindowId()
		{
			IntPtr returnVal = linphone_call_create_native_video_window_id(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_decline(IntPtr thiz, int reason);

		/// <summary>
		/// Decline a pending incoming call, with a reason. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="reason">The reason for rejecting the call: <see cref="Linphone.Reason.Declined">
		/// Linphone.Reason.Declined</see> or <see cref="Linphone.Reason.Busy">
		/// Linphone.Reason.Busy</see> </param>
		/// <returns>0 on success, -1 on failure </returns>
		public void Decline(Linphone.Reason reason)
		{
			int exception_result = linphone_call_decline(nativePtr, (int)reason);
			if (exception_result != 0) throw new LinphoneException("Decline returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_decline_with_error_info(IntPtr thiz, IntPtr ei);

		/// <summary>
		/// Decline a pending incoming call, with a <see cref="Linphone.ErrorInfo">
		/// Linphone.ErrorInfo</see> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="ei"><see cref="Linphone.ErrorInfo">Linphone.ErrorInfo</see>
		/// containing more information on the call rejection.    </param>
		/// <returns>0 on success, -1 on failure </returns>
		public int DeclineWithErrorInfo(Linphone.ErrorInfo ei)
		{
			int returnVal = linphone_call_decline_with_error_info(nativePtr, ei != null ? ei.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(ei);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_defer_update(IntPtr thiz);

		/// <summary>
		/// When receiving a #LinphoneCallUpdatedByRemote state notification, prevent <see cref="Linphone.Core">
		/// Linphone.Core</see> from performing an automatic answer. 
		/// <para>
		/// When receiving a #LinphoneCallUpdatedByRemote state notification (ie an
		/// incoming reINVITE), the default behaviour of <see cref="Linphone.Core">
		/// Linphone.Core</see> is defined by the &quot;defer_update_default&quot; option
		/// of the &quot;sip&quot; section of the config. If this option is 0 (the default)
		/// then the <see cref="Linphone.Core">Linphone.Core</see> automatically answers
		/// the reINIVTE with call parameters unchanged. However when for example when the
		/// remote party updated the call to propose a video stream, it can be useful to
		/// prompt the user before answering. This can be achieved by calling
		/// linphone_core_defer_call_update during the call state notification, to
		/// deactivate the automatic answer that would just confirm the audio but reject
		/// the video. Then, when the user responds to dialog prompt, it becomes possible
		/// to call <see cref="Linphone.Call.AcceptUpdate()">
		/// Linphone.Call.AcceptUpdate()</see> to answer the reINVITE, with eventually
		/// video enabled in the <see cref="Linphone.CallParams">Linphone.CallParams</see>
		/// argument.
		/// The #LinphoneCallUpdatedByRemote notification can also arrive when receiving an
		/// INVITE without SDP. In such case, an unchanged offer is made in the 200Ok, and
		/// when the ACK containing the SDP answer is received,
		/// #LinphoneCallUpdatedByRemote is triggered to notify the application of possible
		/// changes in the media session. However in such case defering the update has no
		/// meaning since we just generating an offer.
		/// </para>
		/// </summary>
		/// <returns>0 if successful, -1 if the <see cref="Linphone.Call.DeferUpdate()">
		/// Linphone.Call.DeferUpdate()</see> was done outside a valid
		/// #LinphoneCallUpdatedByRemote notification </returns>
		public void DeferUpdate()
		{
			int exception_result = linphone_call_defer_update(nativePtr);
			if (exception_result != 0) throw new LinphoneException("DeferUpdate returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_stats(IntPtr thiz, int type);

		/// <summary>
		/// Returns a copy of the call statistics for a particular stream type. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="type">the <see cref="Linphone.StreamType">
		/// Linphone.StreamType</see> </param>
		/// <returns>a <see cref="Linphone.CallStats">Linphone.CallStats</see> object for
		/// the given stream or null if stream isn&apos;t available.       </returns>
		public Linphone.CallStats GetStats(Linphone.StreamType type)
		{
			IntPtr ptr = linphone_call_get_stats(nativePtr, (int)type);
			Linphone.CallStats returnVal = fromNativePtr<Linphone.CallStats>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_get_to_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Returns the value of the header name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">the name of the header to check.    </param>
		/// <returns>the value of the header if exists.    </returns>
		/// deprecated : 27/10/2020. Use <see cref="Linphone.CallParams.CustomHeader">
		/// Linphone.CallParams.CustomHeader</see> on <see cref="Linphone.Call.RemoteParams">
		/// Linphone.Call.RemoteParams</see> instead. 
		public string GetToHeader(string headerName)
		{
			IntPtr stringPtr = linphone_call_get_to_header(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_has_transfer_pending(IntPtr thiz);

		/// <summary>
		/// Returns if this calls has received a transfer that has not been executed yet. 
		/// <para>
		/// Pending transfers are executed when this call is being paused or closed,
		/// locally or by remote endpoint. If the call is already paused while receiving
		/// the transfer request, the transfer immediately occurs. 
		/// </para>
		/// </summary>
		/// <returns>true if transfer is pending, false otherwise. </returns>
		public bool HasTransferPending()
		{
			bool returnVal = linphone_call_has_transfer_pending(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_media_in_progress(IntPtr thiz);

		/// <summary>
		/// Indicates whether an operation is in progress at the media side. 
		/// <para>
		/// It can be a bad idea to initiate signaling operations (adding video, pausing
		/// the call, removing video, changing video parameters) while the media is busy in
		/// establishing the connection (typically ICE connectivity checks). It can result
		/// in failures generating loss of time in future operations in the call.
		/// Applications are invited to check this function after each call state change to
		/// decide whether certain operations are permitted or not. 
		/// </para>
		/// </summary>
		/// <returns>true if media is busy in establishing the connection, false otherwise.
		/// </returns>
		public bool MediaInProgress()
		{
			bool returnVal = linphone_call_media_in_progress(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_notify_ringing(IntPtr thiz);

		/// <summary>
		/// Starts the process of replying 180 Ringing. 
		/// <para>
		/// This function is used in conjonction with <see cref="Linphone.Core.EnableAutoSendRinging()">
		/// Linphone.Core.EnableAutoSendRinging()</see>. If the automatic sending of the
		/// 180 Ringing is disabled, this function needs to be called manually before the
		/// call timeouts.
		/// </para>
		/// </summary>
		public void NotifyRinging()
		{
			linphone_call_notify_ringing(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_ogl_render(IntPtr thiz);

		/// <summary>
		/// Calls generic OpenGL render for a given call. 
		/// <para>
		/// </para>
		/// </summary>
		public void OglRender()
		{
			linphone_call_ogl_render(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_pause(IntPtr thiz);

		/// <summary>
		/// Pauses the call. 
		/// <para>
		/// If a music file has been setup using <see cref="Linphone.Core.PlayFile">
		/// Linphone.Core.PlayFile</see>, this file will be played to the remote user. The
		/// only way to resume a paused call is to call <see cref="Linphone.Call.Resume()">
		/// Linphone.Call.Resume()</see>. 
		/// </para>
		/// </summary>
		/// <returns>0 on success, -1 on failure </returns>
		/// <remarks>See : <see cref="Linphone.Call.Resume()">Linphone.Call.Resume()</see>
		/// </remarks>
		public void Pause()
		{
			int exception_result = linphone_call_pause(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Pause returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_redirect(IntPtr thiz, string redirectUri);

		/// <summary>
		/// Redirect the specified call to the given redirect URI. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="redirectUri">The URI to redirect the call to    </param>
		/// <returns>0 if successful, -1 on error. </returns>
		/// deprecated : 27/10/2020. Use <see cref="Linphone.Call.RedirectTo()">
		/// Linphone.Call.RedirectTo()</see> instead. 
		public void Redirect(string redirectUri)
		{
			int exception_result = linphone_call_redirect(nativePtr, redirectUri);
			if (exception_result != 0) throw new LinphoneException("Redirect returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_redirect_to(IntPtr thiz, IntPtr redirectAddress);

		/// <summary>
		/// Redirect the specified call to the given redirect Address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="redirectAddress">The <see cref="Linphone.Address">
		/// Linphone.Address</see> to redirect the call to    </param>
		/// <returns>0 if successful, -1 on error. </returns>
		public void RedirectTo(Linphone.Address redirectAddress)
		{
			int exception_result = linphone_call_redirect_to(nativePtr, redirectAddress != null ? redirectAddress.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("RedirectTo returned value" + exception_result);
			
			GC.KeepAlive(redirectAddress);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_request_notify_next_video_frame_decoded(IntPtr thiz);

		/// <summary>
		/// Request the callback passed to linphone_call_cbs_set_next_video_frame_decoded
		/// to be called the next time the video decoder properly decodes a video frame. 
		/// <para>
		/// </para>
		/// </summary>
		public void RequestNotifyNextVideoFrameDecoded()
		{
			linphone_call_request_notify_next_video_frame_decoded(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_resume(IntPtr thiz);

		/// <summary>
		/// Resumes a call. 
		/// <para>
		/// The call needs to have been paused previously with <see cref="Linphone.Call.Pause()">
		/// Linphone.Call.Pause()</see>. 
		/// </para>
		/// </summary>
		/// <returns>0 on success, -1 on failure </returns>
		/// <remarks>See : <see cref="Linphone.Call.Pause()">Linphone.Call.Pause()</see>
		/// </remarks>
		public void Resume()
		{
			int exception_result = linphone_call_resume(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Resume returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_send_dtmf(IntPtr thiz, sbyte dtmf);

		/// <summary>
		/// Send the specified dtmf. 
		/// <para>
		/// The dtmf is automatically played to the user. 
		/// </para>
		/// </summary>
		/// <param name="dtmf">The dtmf name specified as a char, such as &apos;0&apos;,
		/// &apos;#&apos; etc... </param>
		/// <returns>0 if successful, -1 on error. </returns>
		public void SendDtmf(sbyte dtmf)
		{
			int exception_result = linphone_call_send_dtmf(nativePtr, dtmf);
			if (exception_result != 0) throw new LinphoneException("SendDtmf returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_send_dtmfs(IntPtr thiz, string dtmfs);

		/// <summary>
		/// Send a list of dtmf. 
		/// <para>
		/// The dtmfs are automatically sent to remote, separated by some needed
		/// customizable delay. Sending is canceled if the call state changes to something
		/// not LinphoneCallStreamsRunning. 
		/// </para>
		/// </summary>
		/// <param name="dtmfs">A dtmf sequence such as &apos;123#123123&apos;    </param>
		/// <returns>-2 if there is already a DTMF sequence, -1 if call is not ready, 0
		/// otherwise. </returns>
		public void SendDtmfs(string dtmfs)
		{
			int exception_result = linphone_call_send_dtmfs(nativePtr, dtmfs);
			if (exception_result != 0) throw new LinphoneException("SendDtmfs returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_send_info_message(IntPtr thiz, IntPtr info);

		/// <summary>
		/// Sends an info message through an established call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="info">the <see cref="Linphone.InfoMessage">
		/// Linphone.InfoMessage</see> to send    </param>
		public void SendInfoMessage(Linphone.InfoMessage info)
		{
			int exception_result = linphone_call_send_info_message(nativePtr, info != null ? info.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("SendInfoMessage returned value" + exception_result);
			
			GC.KeepAlive(info);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_send_vfu_request(IntPtr thiz);

		/// <summary>
		/// Request remote side to send us a Video Fast Update. 
		/// <para>
		/// </para>
		/// </summary>
		public void SendVfuRequest()
		{
			linphone_call_send_vfu_request(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_start_recording(IntPtr thiz);

		/// <summary>
		/// Starts call recording. 
		/// <para>
		/// Video record is only available if this function is called in state
		/// StreamRunning. The output file where audio is recorded must be previously
		/// specified with <see cref="Linphone.CallParams.RecordFile">
		/// Linphone.CallParams.RecordFile</see>. 
		/// </para>
		/// </summary>
		public void StartRecording()
		{
			linphone_call_start_recording(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_stop_recording(IntPtr thiz);

		/// <summary>
		/// Stops call recording. 
		/// <para>
		/// </para>
		/// </summary>
		public void StopRecording()
		{
			linphone_call_stop_recording(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_take_preview_snapshot(IntPtr thiz, string filePath);

		/// <summary>
		/// Take a photo of currently captured video and write it into a jpeg file. 
		/// <para>
		/// Note that the snapshot is asynchronous, an application shall not assume that
		/// the file is created when the function returns. 
		/// </para>
		/// </summary>
		/// <param name="filePath">a path where to write the jpeg content.    </param>
		/// <returns>0 if successful, -1 otherwise (typically if jpeg format is not
		/// supported). </returns>
		public void TakePreviewSnapshot(string filePath)
		{
			int exception_result = linphone_call_take_preview_snapshot(nativePtr, filePath);
			if (exception_result != 0) throw new LinphoneException("TakePreviewSnapshot returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_take_video_snapshot(IntPtr thiz, string filePath);

		/// <summary>
		/// Take a photo of currently received video and write it into a jpeg file. 
		/// <para>
		/// Note that the snapshot is asynchronous, an application shall not assume that
		/// the file is created when the function returns. 
		/// </para>
		/// </summary>
		/// <param name="filePath">a path where to write the jpeg content.    </param>
		/// <returns>0 if successful, -1 otherwise (typically if jpeg format is not
		/// supported). </returns>
		public void TakeVideoSnapshot(string filePath)
		{
			int exception_result = linphone_call_take_video_snapshot(nativePtr, filePath);
			if (exception_result != 0) throw new LinphoneException("TakeVideoSnapshot returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_terminate(IntPtr thiz);

		/// <summary>
		/// Terminates a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 on success, -1 on failure </returns>
		public void Terminate()
		{
			int exception_result = linphone_call_terminate(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Terminate returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_terminate_with_error_info(IntPtr thiz, IntPtr ei);

		/// <summary>
		/// Terminates a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="ei"><see cref="Linphone.ErrorInfo">Linphone.ErrorInfo</see>   
		/// </param>
		/// <returns>0 on success, -1 on failure </returns>
		public void TerminateWithErrorInfo(Linphone.ErrorInfo ei)
		{
			int exception_result = linphone_call_terminate_with_error_info(nativePtr, ei != null ? ei.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("TerminateWithErrorInfo returned value" + exception_result);
			
			GC.KeepAlive(ei);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_transfer(IntPtr thiz, string referTo);

		/// <summary>
		/// Performs a simple call transfer to the specified destination. 
		/// <para>
		/// The remote endpoint is expected to issue a new call to the specified
		/// destination. The current call remains active and thus can be later paused or
		/// terminated. It is possible to follow the progress of the transfer provided that
		/// transferee sends notification about it. In this case, the
		/// transfer_state_changed callback of the LinphoneCoreVTable is invoked to notify
		/// of the state of the new call at the other party. The notified states are
		/// #LinphoneCallOutgoingInit , #LinphoneCallOutgoingProgress,
		/// #LinphoneCallOutgoingRinging and #LinphoneCallConnected. 
		/// </para>
		/// </summary>
		/// <param name="referTo">The destination the call is to be refered to.    </param>
		/// <returns>0 on success, -1 on failure </returns>
		/// deprecated : 27/10/2020. Use <see cref="Linphone.Call.TransferTo()">
		/// Linphone.Call.TransferTo()</see> instead. 
		public void Transfer(string referTo)
		{
			int exception_result = linphone_call_transfer(nativePtr, referTo);
			if (exception_result != 0) throw new LinphoneException("Transfer returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_transfer_to(IntPtr thiz, IntPtr referTo);

		/// <summary>
		/// Performs a simple call transfer to the specified destination. 
		/// <para>
		/// The remote endpoint is expected to issue a new call to the specified
		/// destination. The current call remains active and thus can be later paused or
		/// terminated. It is possible to follow the progress of the transfer provided that
		/// transferee sends notification about it. In this case, the
		/// transfer_state_changed callback of the LinphoneCoreVTable is invoked to notify
		/// of the state of the new call at the other party. The notified states are
		/// #LinphoneCallOutgoingInit , #LinphoneCallOutgoingProgress,
		/// #LinphoneCallOutgoingRinging and #LinphoneCallConnected. 
		/// </para>
		/// </summary>
		/// <param name="referTo">The <see cref="Linphone.Address">Linphone.Address</see>
		/// the call is to be refered to.    </param>
		/// <returns>0 on success, -1 on failure </returns>
		public void TransferTo(Linphone.Address referTo)
		{
			int exception_result = linphone_call_transfer_to(nativePtr, referTo != null ? referTo.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("TransferTo returned value" + exception_result);
			
			GC.KeepAlive(referTo);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_transfer_to_another(IntPtr thiz, IntPtr dest);

		/// <summary>
		/// Transfers a call to destination of another running call. 
		/// <para>
		/// This is used for &quot;attended transfer&quot; scenarios. The transfered call
		/// is supposed to be in paused state, so that it is able to accept the transfer
		/// immediately. The destination call is a call previously established to introduce
		/// the transfered person. This method will send a transfer request to the
		/// transfered person. The phone of the transfered is then expected to
		/// automatically call to the destination of the transfer. The receiver of the
		/// transfer will then automatically close the call with us (the &apos;dest&apos;
		/// call). It is possible to follow the progress of the transfer provided that
		/// transferee sends notification about it. In this case, the
		/// transfer_state_changed callback of the LinphoneCoreVTable is invoked to notify
		/// of the state of the new call at the other party. The notified states are
		/// #LinphoneCallOutgoingInit , #LinphoneCallOutgoingProgress,
		/// #LinphoneCallOutgoingRinging and #LinphoneCallConnected. 
		/// </para>
		/// </summary>
		/// <param name="dest">A running call whose remote person will receive the transfer
		///    </param>
		/// <returns>0 on success, -1 on failure </returns>
		public void TransferToAnother(Linphone.Call dest)
		{
			int exception_result = linphone_call_transfer_to_another(nativePtr, dest != null ? dest.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("TransferToAnother returned value" + exception_result);
			
			GC.KeepAlive(dest);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_update(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Updates a running call according to supplied call parameters or parameters
		/// changed in the LinphoneCore. 
		/// <para>
		/// It triggers a SIP reINVITE in order to perform a new offer/answer of media
		/// capabilities. Changing the size of the transmitted video after calling
		/// linphone_core_set_preferred_video_size can be used by passing null as params
		/// argument. In case no changes are requested through the <see cref="Linphone.CallParams">
		/// Linphone.CallParams</see> argument, then this argument can be omitted and set
		/// to null. WARNING: Updating a call in the #LinphoneCallPaused state will still
		/// result in a paused call even if the media directions set in the params are
		/// sendrecv. To resume a paused call, you need to call <see cref="Linphone.Call.Resume()">
		/// Linphone.Call.Resume()</see>.
		/// </para>
		/// </summary>
		/// <param name="parameters">The new call parameters to use (may be null).   
		/// </param>
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void Update(Linphone.CallParams parameters)
		{
			int exception_result = linphone_call_update(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("Update returned value" + exception_result);
			
			GC.KeepAlive(parameters);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_zoom(IntPtr thiz, float zoomFactor, float cx, float cy);

		/// <summary>
		/// Perform a zoom of the video displayed during a call. 
		/// <para>
		/// The zoom ensures that all the screen is fullfilled with the video. 
		/// </para>
		/// </summary>
		/// <param name="zoomFactor">a floating point number describing the zoom factor. A
		/// value 1.0 corresponds to no zoom applied. </param>
		/// <param name="cx">a floating point number pointing the horizontal center of the
		/// zoom to be applied. This value should be between 0.0 and 1.0. </param>
		/// <param name="cy">a floating point number pointing the vertical center of the
		/// zoom to be applied. This value should be between 0.0 and 1.0. </param>
		public void Zoom(float zoomFactor, float cx, float cy)
		{
			linphone_call_zoom(nativePtr, zoomFactor, cx, cy);
			
			
						
		}
	}
	/// <summary>
	/// Object used to keep track of all calls initiated, received or missed. 
	/// <para>
	/// It contains the call ID, date &amp; time at which the call took place and
	/// it&apos;s duration (0 if it wasn&apos;t answered). You can also know if video
	/// was enabled or not or if it was a conference, as well as it&apos;s average
	/// quality.
	/// If needed, you can also create a fake <see cref="Linphone.CallLog">
	/// Linphone.CallLog</see> using <see cref="Linphone.Core.CreateCallLog()">
	/// Linphone.Core.CreateCallLog()</see>, otherwise use <see cref="Linphone.Core.CallLogs">
	/// Linphone.Core.CallLogs</see> or even <see cref="Linphone.Call.CallLog">
	/// Linphone.Call.CallLog</see> to get the log of an ongoing call. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class CallLog : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_call_id(IntPtr thiz);

		/// <summary>
		/// Get the call ID used by the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The call ID used by the call as a string.    </returns>
		public string CallId
		{
			get
			{
				IntPtr stringPtr = linphone_call_log_get_call_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_conference_info(IntPtr thiz);

		/// <summary>
		/// Retrieves the conference info associated to this call log in DB. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.ConferenceInfo">Linphone.ConferenceInfo</see>
		/// associated.    </returns>
		public Linphone.ConferenceInfo ConferenceInfo
		{
			get
			{
				IntPtr ptr = linphone_call_log_get_conference_info(nativePtr);
				Linphone.ConferenceInfo obj = fromNativePtr<Linphone.ConferenceInfo>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.CallDir linphone_call_log_get_dir(IntPtr thiz);

		/// <summary>
		/// Get the direction of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.CallDir">Linphone.CallDir</see> of the call.
		/// </returns>
		public Linphone.CallDir Dir
		{
			get
			{
				return linphone_call_log_get_dir(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_log_get_duration(IntPtr thiz);

		/// <summary>
		/// Get the duration of the call since connected. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The duration of the call in seconds. </returns>
		public int Duration
		{
			get
			{
				return linphone_call_log_get_duration(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_error_info(IntPtr thiz);

		/// <summary>
		/// When the call was failed, return an object describing the failure. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.ErrorInfo">Linphone.ErrorInfo</see> about the
		/// error encountered by the call associated with this call log or null.   
		/// </returns>
		public Linphone.ErrorInfo ErrorInfo
		{
			get
			{
				IntPtr ptr = linphone_call_log_get_error_info(nativePtr);
				Linphone.ErrorInfo obj = fromNativePtr<Linphone.ErrorInfo>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_from_address(IntPtr thiz);

		/// <summary>
		/// Get the origin address (ie from) of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The origin <see cref="Linphone.Address">Linphone.Address</see> (ie
		/// from) of the call.    </returns>
		public Linphone.Address FromAddress
		{
			get
			{
				IntPtr ptr = linphone_call_log_get_from_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_local_address(IntPtr thiz);

		/// <summary>
		/// Get the local address (that is from or to depending on call direction) 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The local <see cref="Linphone.Address">Linphone.Address</see> of the
		/// call    </returns>
		public Linphone.Address LocalAddress
		{
			get
			{
				IntPtr ptr = linphone_call_log_get_local_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_log_get_quality(IntPtr thiz);

		/// <summary>
		/// Get the overall quality indication of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The overall quality indication of the call. </returns>
		public float Quality
		{
			get
			{
				return linphone_call_log_get_quality(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_ref_key(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_log_set_ref_key(IntPtr thiz, string refkey);

		/// <summary>
		/// Get the persistent reference key associated to the call log. 
		/// <para>
		/// The reference key can be for example an id to an external database. It is
		/// stored in the config file, thus can survive to process exits/restarts.
		/// </para>
		/// </summary>
		/// <returns>The reference key string that has been associated to the call log, or
		/// null if none has been associated.    </returns>
		public string RefKey
		{
			get
			{
				IntPtr stringPtr = linphone_call_log_get_ref_key(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_call_log_set_ref_key(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_remote_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_log_set_remote_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Get the remote address (that is from or to depending on call direction). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The remote <see cref="Linphone.Address">Linphone.Address</see> of the
		/// call.    </returns>
		public Linphone.Address RemoteAddress
		{
			get
			{
				IntPtr ptr = linphone_call_log_get_remote_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				linphone_call_log_set_remote_address(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_call_log_get_start_date(IntPtr thiz);

		/// <summary>
		/// Get the start date of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The date of the beginning of the call. </returns>
		public long StartDate
		{
			get
			{
				return linphone_call_log_get_start_date(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.CallStatus linphone_call_log_get_status(IntPtr thiz);

		/// <summary>
		/// Get the status of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.CallStatus">Linphone.CallStatus</see> of the
		/// call. </returns>
		public Linphone.CallStatus Status
		{
			get
			{
				return linphone_call_log_get_status(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_get_to_address(IntPtr thiz);

		/// <summary>
		/// Get the destination address (ie to) of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The destination <see cref="Linphone.Address">Linphone.Address</see>
		/// (ie to) of the call.    </returns>
		public Linphone.Address ToAddress
		{
			get
			{
				IntPtr ptr = linphone_call_log_get_to_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_log_video_enabled(IntPtr thiz);

		/// <summary>
		/// Tell whether video was enabled at the end of the call or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether video was enabled at the end of the
		/// call. </returns>
		public bool VideoEnabled
		{
			get
			{
				return linphone_call_log_video_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_log_to_str(IntPtr thiz);

		/// <summary>
		/// Get a human readable string describing the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Note : : the returned string must be freed by the application (use
		/// ms_free()). </remarks>
		/// <returns>A human readable string describing the call.       </returns>
		public string ToStr()
		{
			IntPtr stringPtr = linphone_call_log_to_str(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_log_was_conference(IntPtr thiz);

		/// <summary>
		/// Tells whether that call was part of a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the call was part of a conference, false otherwise. </returns>
		public bool WasConference()
		{
			bool returnVal = linphone_call_log_was_conference(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
	}
	/// <summary>
	/// An object containing various parameters of a <see cref="Linphone.Call">
	/// Linphone.Call</see>. 
	/// <para>
	/// You can specify your params while answering an incoming call using <see cref="Linphone.Call.AcceptWithParams()">
	/// Linphone.Call.AcceptWithParams()</see> or while initiating an outgoing call
	/// with <see cref="Linphone.Core.InviteAddressWithParams()">
	/// Linphone.Core.InviteAddressWithParams()</see>.
	/// This object can be created using <see cref="Linphone.Core.CreateCallParams()">
	/// Linphone.Core.CreateCallParams()</see>, using null for the call pointer if you
	/// plan to use it for an outgoing call.
	/// For each call, three <see cref="Linphone.CallParams">Linphone.CallParams</see>
	/// are available: yours, your correspondent&apos;s and the one that describe the
	/// current state of the call that is the result of the negociation between the
	/// previous two. For example, you might enable a certain feature in your call
	/// param but this feature can be denied in the remote&apos;s configuration, hence
	/// the difference.
	/// </para>
	/// </summary>
	/// <remarks>See : <see cref="Linphone.Call.CurrentParams">
	/// Linphone.Call.CurrentParams</see>, <see cref="Linphone.Call.RemoteParams">
	/// Linphone.Call.RemoteParams</see> and <see cref="Linphone.Call.Params">
	/// Linphone.Call.Params</see>. </remarks>
	[StructLayout(LayoutKind.Sequential)]
	public class CallParams : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_account(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_account(IntPtr thiz, IntPtr account);

		/// <summary>
		/// Get the <see cref="Linphone.Account">Linphone.Account</see> that is used for
		/// the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The selected <see cref="Linphone.Account">Linphone.Account</see> for
		/// the call, or null if none has been selected.    </returns>
		public Linphone.Account Account
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_account(nativePtr);
				Linphone.Account obj = fromNativePtr<Linphone.Account>(ptr, true);
				return obj;
			}
			set
			{
				linphone_call_params_set_account(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_audio_bandwidth_limit(IntPtr thiz, int bandwidth);

		/// <summary>
		/// Refine bandwidth settings for this call by setting a bandwidth limit for audio
		/// streams. 
		/// <para>
		/// As a consequence, codecs whose bitrates are not compatible with this limit
		/// won&apos;t be used. 
		/// </para>
		/// </summary>
		/// <param name="bandwidth">The audio bandwidth limit to set in kbit/s. </param>
		public int AudioBandwidthLimit
		{
			set
			{
				linphone_call_params_set_audio_bandwidth_limit(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.MediaDirection linphone_call_params_get_audio_direction(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_audio_direction(IntPtr thiz, int direction);

		/// <summary>
		/// Get the audio stream direction. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The audio stream <see cref="Linphone.MediaDirection">
		/// Linphone.MediaDirection</see> associated with the call params. </returns>
		public Linphone.MediaDirection AudioDirection
		{
			get
			{
				return linphone_call_params_get_audio_direction(nativePtr);
			}
			set
			{
				linphone_call_params_set_audio_direction(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_audio_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_audio(IntPtr thiz, char enabled);

		/// <summary>
		/// Tell whether audio is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether audio is enabled or not. </returns>
		public bool AudioEnabled
		{
			get
			{
				return linphone_call_params_audio_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_audio(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_audio_multicast_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_audio_multicast(IntPtr thiz, char yesno);

		/// <summary>
		/// Use to get multicast state of audio stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if subsequent calls will propose multicast ip set by <see cref="Linphone.Core.AudioMulticastAddr">
		/// Linphone.Core.AudioMulticastAddr</see> </returns>
		public bool AudioMulticastEnabled
		{
			get
			{
				return linphone_call_params_audio_multicast_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_audio_multicast(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_avpf_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_avpf(IntPtr thiz, char enable);

		/// <summary>
		/// Whether or not the feedback extension will be used for AVP. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if AVPF is enabled, false otherwise </returns>
		public bool AvpfEnabled
		{
			get
			{
				return linphone_call_params_avpf_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_avpf(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_capability_negotiation_reinvite_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_capability_negotiation_reinvite(IntPtr thiz, char enable);

		/// <summary>
		/// Check if the capability negotiation (RFC5939) reINVITE is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if capability negotiation reINVITE is enabled; false
		/// otherwise.</returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.CallParams.CapabilityNegotiationReinviteEnabled()">
		/// Linphone.CallParams.CapabilityNegotiationReinviteEnabled()</see> instead. 
		public bool CapabilityNegotiationReinviteEnabled
		{
			get
			{
				return linphone_call_params_capability_negotiation_reinvite_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_capability_negotiation_reinvite(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_capability_negotiations_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_capability_negotiations(IntPtr thiz, char enabled);

		/// <summary>
		/// Indicates whether capability negotiations (RFC5939) is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a boolean indicating the enablement of capability negotiations.
		/// </returns>
		public bool CapabilityNegotiationsEnabled
		{
			get
			{
				return linphone_call_params_capability_negotiations_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_capability_negotiations(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_cfg_lines_merging(IntPtr thiz, char enabled);

		/// <summary>
		/// Enable merging of cfg lines with consecutive indexes if capability negotiations
		/// (RFC5939) is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="enabled">A boolean value telling whether to merge pcfg and acfg
		/// lines </param>
		public bool CfgLinesMergingEnabled
		{
			set
			{
				linphone_call_params_enable_cfg_lines_merging(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConferenceLayout linphone_call_params_get_conference_video_layout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_conference_video_layout(IntPtr thiz, int layout);

		/// <summary>
		/// Set video layout for conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Preferred <see cref="Linphone.ConferenceLayout">
		/// Linphone.ConferenceLayout</see> to use at the start of a conference </returns>
		public Linphone.ConferenceLayout ConferenceVideoLayout
		{
			get
			{
				return linphone_call_params_get_conference_video_layout(nativePtr);
			}
			set
			{
				linphone_call_params_set_conference_video_layout(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_custom_contents(IntPtr thiz);

		/// <summary>
		/// Gets a list of <see cref="Linphone.Content">Linphone.Content</see> set if
		/// exists. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of <see cref="Linphone.Content">Linphone.Content</see> set if
		/// exists, null otherwise.         </returns>
		public IEnumerable<Linphone.Content> CustomContents
		{
			get
			{
				return MarshalBctbxList<Linphone.Content>(linphone_call_params_get_custom_contents(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_early_media_sending_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_early_media_sending(IntPtr thiz, char enabled);

		/// <summary>
		/// Indicate whether sending of early media was enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether sending of early media was enabled.
		/// </returns>
		public bool EarlyMediaSendingEnabled
		{
			get
			{
				return linphone_call_params_early_media_sending_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_early_media_sending(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_from_header(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_from_header(IntPtr thiz, string fromValue);

		/// <summary>
		/// Get the from header in the CallParams. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The content of the from header, may be null.    </returns>
		public string FromHeader
		{
			get
			{
				IntPtr stringPtr = linphone_call_params_get_from_header(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_call_params_set_from_header(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_input_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_input_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the default input audio device for a call that will be created using this
		/// call params. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : This method only concerns the call creation, it doesn&apos;t
		/// reflect the currently used input audio device of the call. Instead use <see cref="Linphone.Call.InputAudioDevice">
		/// Linphone.Call.InputAudioDevice</see> when call has been created. </remarks> 
		/// <returns>the <see cref="Linphone.AudioDevice">Linphone.AudioDevice</see> that
		/// will be used by default as input when the call will be created    </returns>
		public Linphone.AudioDevice InputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_input_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_call_params_set_input_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_is_capability_negotiation_reinvite_enabled(IntPtr thiz);

		/// <summary>
		/// Check if the capability negotiation (RFC5939) reINVITE is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if capability negotiation reINVITE is enabled; false otherwise.
		/// </returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.CallParams.CapabilityNegotiationReinviteEnabled()">
		/// Linphone.CallParams.CapabilityNegotiationReinviteEnabled()</see> instead.
		public bool IsCapabilityNegotiationReinviteEnabled
		{
			get
			{
				return linphone_call_params_is_capability_negotiation_reinvite_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_is_recording(IntPtr thiz);

		/// <summary>
		/// Indicates whether the call is being recorded. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the call is being recorded, false otherwise. </returns>
		public bool IsRecording
		{
			get
			{
				return linphone_call_params_is_recording(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_get_local_conference_mode(IntPtr thiz);

		/// <summary>
		/// Tell whether the call is part of the locally managed conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : If a conference server is used to manage conferences, that
		/// function does not return true even if the conference is running. If you want to
		/// test whether the conference is running, you should test whether <see cref="Linphone.Core.Conference">
		/// Linphone.Core.Conference</see> return a non-null pointer. </remarks> 
		/// <returns>A boolean value telling whether the call is part of the locally
		/// managed conference. </returns>
		public bool LocalConferenceMode
		{
			get
			{
				return linphone_call_params_get_local_conference_mode(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_low_bandwidth_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_low_bandwidth(IntPtr thiz, char enabled);

		/// <summary>
		/// Tell whether the call has been configured in low bandwidth mode or not. 
		/// <para>
		/// This mode can be automatically discovered thanks to a stun server when
		/// activate_edge_workarounds=1 in section [net] of configuration file. An
		/// application that would have reliable way to know network capacity may not use
		/// activate_edge_workarounds=1 but instead manually configure low bandwidth mode
		/// with <see cref="Linphone.CallParams.EnableLowBandwidth()">
		/// Linphone.CallParams.EnableLowBandwidth()</see>. When enabled, this param may
		/// transform a call request with video in audio only mode. 
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether the low bandwidth mode has been
		/// configured/detected. </returns>
		public bool LowBandwidthEnabled
		{
			get
			{
				return linphone_call_params_low_bandwidth_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_low_bandwidth(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.MediaEncryption linphone_call_params_get_media_encryption(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_media_encryption(IntPtr thiz, int encryption);

		/// <summary>
		/// Get the kind of media encryption selected for the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The kind of <see cref="Linphone.MediaEncryption">
		/// Linphone.MediaEncryption</see> selected for the call. </returns>
		public Linphone.MediaEncryption MediaEncryption
		{
			get
			{
				return linphone_call_params_get_media_encryption(nativePtr);
			}
			set
			{
				linphone_call_params_set_media_encryption(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_mic_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_mic(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether the microphone will be enabled when the call will be created. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : This method only concerns the call creation, it doesn&apos;t
		/// reflect the actual microphone status during a call. Instead use <see cref="Linphone.Call.MicrophoneMuted">
		/// Linphone.Call.MicrophoneMuted</see> when call has been created. </remarks> 
		/// <returns>true if the microphone will be enabled, false if disabled. </returns>
		public bool MicEnabled
		{
			get
			{
				return linphone_call_params_mic_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_mic(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_output_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_output_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the default output audio device for a call that will be created using this
		/// call params. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : This method only concerns the call creation, it doesn&apos;t
		/// reflect the currently used output audio device of the call. Instead use <see cref="Linphone.Call.OutputAudioDevice">
		/// Linphone.Call.OutputAudioDevice</see> when call has been created. </remarks> 
		/// <returns>the <see cref="Linphone.AudioDevice">Linphone.AudioDevice</see> that
		/// will be used by default as output when the call will be created    </returns>
		public Linphone.AudioDevice OutputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_output_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_call_params_set_output_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_call_params_get_privacy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_privacy(IntPtr thiz, uint privacy);

		/// <summary>
		/// Get requested level of privacy for the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The LinphonePrivacyMask used for the call. </returns>
		public uint Privacy
		{
			get
			{
				return linphone_call_params_get_privacy(nativePtr);
			}
			set
			{
				linphone_call_params_set_privacy(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_proxy_config(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_proxy_config(IntPtr thiz, IntPtr proxyConfig);

		/// <summary>
		/// Get the <see cref="Linphone.ProxyConfig">Linphone.ProxyConfig</see> that is
		/// used for the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The selected <see cref="Linphone.ProxyConfig">
		/// Linphone.ProxyConfig</see> for the call, or null if none has been selected.   
		/// </returns>
		/// deprecated : 28/02/2021 Use <see cref="Linphone.CallParams.Account">
		/// Linphone.CallParams.Account</see> instead. 
		public Linphone.ProxyConfig ProxyConfig
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_proxy_config(nativePtr);
				Linphone.ProxyConfig obj = fromNativePtr<Linphone.ProxyConfig>(ptr, true);
				return obj;
			}
			set
			{
				linphone_call_params_set_proxy_config(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_realtime_text_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_call_params_enable_realtime_text(IntPtr thiz, char yesno);

		/// <summary>
		/// Use to get real time text following rfc4103. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>returns true if call rtt is activated. </returns>
		public bool RealtimeTextEnabled
		{
			get
			{
				return linphone_call_params_realtime_text_enabled(nativePtr) != 0;
			}
			set
			{
				int exception_result = linphone_call_params_enable_realtime_text(nativePtr, value ? (char)1 : (char)0);
				if (exception_result != 0) throw new LinphoneException("RealtimeTextEnabled setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_call_params_get_realtime_text_keepalive_interval(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_realtime_text_keepalive_interval(IntPtr thiz, uint interval);

		/// <summary>
		/// Use to get keep alive interval of real time text following rfc4103. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>returns keep alive interval of real time text. </returns>
		public uint RealtimeTextKeepaliveInterval
		{
			get
			{
				return linphone_call_params_get_realtime_text_keepalive_interval(nativePtr);
			}
			set
			{
				linphone_call_params_set_realtime_text_keepalive_interval(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_params_get_received_framerate(IntPtr thiz);

		/// <summary>
		/// Get the framerate of the video that is received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The actual received framerate in frames per seconds, 0 if not
		/// available. </returns>
		public float ReceivedFramerate
		{
			get
			{
				return linphone_call_params_get_received_framerate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_received_video_definition(IntPtr thiz);

		/// <summary>
		/// Get the definition of the received video. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The received <see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see> or null.    </returns>
		public Linphone.VideoDefinition ReceivedVideoDefinition
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_received_video_definition(nativePtr);
				Linphone.VideoDefinition obj = fromNativePtr<Linphone.VideoDefinition>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_record_file(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_record_file(IntPtr thiz, string path);

		/// <summary>
		/// Get the path for the audio recording of the call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to the audio recording of the call or null.    </returns>
		public string RecordFile
		{
			get
			{
				IntPtr stringPtr = linphone_call_params_get_record_file(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_call_params_set_record_file(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_rtp_bundle_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_rtp_bundle(IntPtr thiz, char val);

		/// <summary>
		/// Indicates whether RTP bundle mode (also known as Media Multiplexing) is
		/// enabled. 
		/// <para>
		/// See https://datatracker.ietf.org/doc/html/rfc8843 for more information. 
		/// </para>
		/// </summary>
		/// <returns>a boolean indicating the enablement of rtp bundle mode. </returns>
		public bool RtpBundleEnabled
		{
			get
			{
				return linphone_call_params_rtp_bundle_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_rtp_bundle(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_rtp_profile(IntPtr thiz);

		/// <summary>
		/// Get the RTP profile being used. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The RTP profile.    </returns>
		public string RtpProfile
		{
			get
			{
				IntPtr stringPtr = linphone_call_params_get_rtp_profile(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_params_get_sent_framerate(IntPtr thiz);

		/// <summary>
		/// Get the framerate of the video that is sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The actual sent framerate in frames per seconds, 0 if not available.
		/// </returns>
		public float SentFramerate
		{
			get
			{
				return linphone_call_params_get_sent_framerate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_sent_video_definition(IntPtr thiz);

		/// <summary>
		/// Get the definition of the sent video. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The sent <see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see> or null.    </returns>
		public Linphone.VideoDefinition SentVideoDefinition
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_sent_video_definition(nativePtr);
				Linphone.VideoDefinition obj = fromNativePtr<Linphone.VideoDefinition>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_session_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_session_name(IntPtr thiz, string name);

		/// <summary>
		/// Get the session name of the media session (ie in SDP). 
		/// <para>
		/// Subject from the SIP message can be retrieved using <see cref="Linphone.CallParams.CustomHeader">
		/// Linphone.CallParams.CustomHeader</see> and is different. 
		/// </para>
		/// </summary>
		/// <returns>The session name of the media session or null.    </returns>
		public string SessionName
		{
			get
			{
				IntPtr stringPtr = linphone_call_params_get_session_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_call_params_set_session_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_tcap_line_merging(IntPtr thiz, char enabled);

		/// <summary>
		/// Enable merging of tcap lines with consecutive indexes if capability
		/// negotiations (RFC5939) is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="enabled">A boolean value telling whether to merge tcap lines
		/// </param>
		public bool TcapLineMergingEnabled
		{
			set
			{
				linphone_call_params_enable_tcap_line_merging(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_tone_indications_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_tone_indications(IntPtr thiz, char enable);

		/// <summary>
		/// Check if tone indications are enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if tone indications are enabled; false otherwise. </returns>
		public bool ToneIndicationsEnabled
		{
			get
			{
				return linphone_call_params_tone_indications_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_tone_indications(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_used_audio_payload_type(IntPtr thiz);

		/// <summary>
		/// Get the audio payload type that has been selected by a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The selected <see cref="Linphone.PayloadType">
		/// Linphone.PayloadType</see>. null is returned if no audio payload type has been
		/// selected by the call.    </returns>
		public Linphone.PayloadType UsedAudioPayloadType
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_used_audio_payload_type(nativePtr);
				Linphone.PayloadType obj = fromNativePtr<Linphone.PayloadType>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_used_text_payload_type(IntPtr thiz);

		/// <summary>
		/// Get the text payload type that has been selected by a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The selected <see cref="Linphone.PayloadType">
		/// Linphone.PayloadType</see>. null is returned if no text payload type has been
		/// selected by the call.    </returns>
		public Linphone.PayloadType UsedTextPayloadType
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_used_text_payload_type(nativePtr);
				Linphone.PayloadType obj = fromNativePtr<Linphone.PayloadType>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_used_video_payload_type(IntPtr thiz);

		/// <summary>
		/// Get the video payload type that has been selected by a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The selected <see cref="Linphone.PayloadType">
		/// Linphone.PayloadType</see>. null is returned if no video payload type has been
		/// selected by the call.    </returns>
		public Linphone.PayloadType UsedVideoPayloadType
		{
			get
			{
				IntPtr ptr = linphone_call_params_get_used_video_payload_type(nativePtr);
				Linphone.PayloadType obj = fromNativePtr<Linphone.PayloadType>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.MediaDirection linphone_call_params_get_video_direction(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_set_video_direction(IntPtr thiz, int direction);

		/// <summary>
		/// Get the video stream direction. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The video stream <see cref="Linphone.MediaDirection">
		/// Linphone.MediaDirection</see> associated with the call params. </returns>
		public Linphone.MediaDirection VideoDirection
		{
			get
			{
				return linphone_call_params_get_video_direction(nativePtr);
			}
			set
			{
				linphone_call_params_set_video_direction(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_video_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_video(IntPtr thiz, char enabled);

		/// <summary>
		/// Tell whether video is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether video is enabled or not. </returns>
		public bool VideoEnabled
		{
			get
			{
				return linphone_call_params_video_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_video(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_video_multicast_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_enable_video_multicast(IntPtr thiz, char yesno);

		/// <summary>
		/// Use to get multicast state of video stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if subsequent calls will propose multicast ip set by <see cref="Linphone.Core.VideoMulticastAddr">
		/// Linphone.Core.VideoMulticastAddr</see> </returns>
		public bool VideoMulticastEnabled
		{
			get
			{
				return linphone_call_params_video_multicast_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_call_params_enable_video_multicast(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_add_custom_content(IntPtr thiz, IntPtr content);

		/// <summary>
		/// Adds a <see cref="Linphone.Content">Linphone.Content</see> to be added to the
		/// INVITE SDP. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">The <see cref="Linphone.Content">Linphone.Content</see>
		/// to be added.    </param>
		public void AddCustomContent(Linphone.Content content)
		{
			linphone_call_params_add_custom_content(nativePtr, content != null ? content.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(content);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_add_custom_header(IntPtr thiz, string headerName, string headerValue);

		/// <summary>
		/// Add a custom SIP header in the INVITE for a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">The name of the header to add.    </param>
		/// <param name="headerValue">The content of the header to add.    </param>
		public void AddCustomHeader(string headerName, string headerValue)
		{
			linphone_call_params_add_custom_header(nativePtr, headerName, headerValue);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_add_custom_sdp_attribute(IntPtr thiz, string attributeName, string attributeValue);

		/// <summary>
		/// Add a custom attribute related to all the streams in the SDP exchanged within
		/// SIP messages during a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="attributeName">The name of the attribute to add.    </param>
		/// <param name="attributeValue">The content value of the attribute to add.   
		/// </param>
		public void AddCustomSdpAttribute(string attributeName, string attributeValue)
		{
			linphone_call_params_add_custom_sdp_attribute(nativePtr, attributeName, attributeValue);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_add_custom_sdp_media_attribute(IntPtr thiz, int type, string attributeName, string attributeValue);

		/// <summary>
		/// Add a custom attribute related to a specific stream in the SDP exchanged within
		/// SIP messages during a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="type">The type of the stream to add a custom SDP attribute to.
		/// </param>
		/// <param name="attributeName">The name of the attribute to add.    </param>
		/// <param name="attributeValue">The content value of the attribute to add.   
		/// </param>
		public void AddCustomSdpMediaAttribute(Linphone.StreamType type, string attributeName, string attributeValue)
		{
			linphone_call_params_add_custom_sdp_media_attribute(nativePtr, (int)type, attributeName, attributeValue);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_cfg_lines_merged(IntPtr thiz);

		/// <summary>
		/// Indicates whether cfg lines with consecutive indexes are going to be merged or
		/// not if capability negotiations (RFC5939) is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a boolean indicating the enablement of pcfg and acfg line merging
		/// </returns>
		public bool CfgLinesMerged()
		{
			bool returnVal = linphone_call_params_cfg_lines_merged(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_clear_custom_sdp_attributes(IntPtr thiz);

		/// <summary>
		/// Clear the custom SDP attributes related to all the streams in the SDP exchanged
		/// within SIP messages during a call. 
		/// <para>
		/// </para>
		/// </summary>
		public void ClearCustomSdpAttributes()
		{
			linphone_call_params_clear_custom_sdp_attributes(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_call_params_clear_custom_sdp_media_attributes(IntPtr thiz, int type);

		/// <summary>
		/// Clear the custom SDP attributes related to a specific stream in the SDP
		/// exchanged within SIP messages during a call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="type">The type of the stream to clear the custom SDP attributes
		/// from. </param>
		public void ClearCustomSdpMediaAttributes(Linphone.StreamType type)
		{
			linphone_call_params_clear_custom_sdp_media_attributes(nativePtr, (int)type);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_copy(IntPtr thiz);

		/// <summary>
		/// Copy an existing <see cref="Linphone.CallParams">Linphone.CallParams</see>
		/// object to a new <see cref="Linphone.CallParams">Linphone.CallParams</see>
		/// object. 
		/// <para>
		/// <see cref="Linphone.CallParams.Copy()">Linphone.CallParams.Copy()</see> is
		/// error-prone, leading to inconsistent parameters being passed to <see cref="Linphone.Core.InviteAddressWithParams()">
		/// Linphone.Core.InviteAddressWithParams()</see> or <see cref="Linphone.Call.AcceptWithParams()">
		/// Linphone.Call.AcceptWithParams()</see>. </para>
		/// </summary>
		/// deprecated : use exclusively <see cref="Linphone.Core.CreateCallParams()">
		/// Linphone.Core.CreateCallParams()</see> to create <see cref="Linphone.CallParams">
		/// Linphone.CallParams</see> object. 
		/// <returns>A copy of the <see cref="Linphone.CallParams">
		/// Linphone.CallParams</see> object.       </returns>
		public Linphone.CallParams Copy()
		{
			IntPtr ptr = linphone_call_params_copy(nativePtr);
			Linphone.CallParams returnVal = fromNativePtr<Linphone.CallParams>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_custom_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Get a custom SIP header. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">The name of the header to get.    </param>
		/// <returns>The content of the header or null if not found.    </returns>
		public string GetCustomHeader(string headerName)
		{
			IntPtr stringPtr = linphone_call_params_get_custom_header(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_custom_sdp_attribute(IntPtr thiz, string attributeName);

		/// <summary>
		/// Get a custom SDP attribute that is related to all the streams. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="attributeName">The name of the attribute to get.    </param>
		/// <returns>The content value of the attribute or null if not found.    </returns>
		public string GetCustomSdpAttribute(string attributeName)
		{
			IntPtr stringPtr = linphone_call_params_get_custom_sdp_attribute(nativePtr, attributeName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_params_get_custom_sdp_media_attribute(IntPtr thiz, int type, string attributeName);

		/// <summary>
		/// Get a custom SDP attribute that is related to a specific stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="type">The type of the stream to add a custom SDP attribute to.
		/// </param>
		/// <param name="attributeName">The name of the attribute to get.    </param>
		/// <returns>The content value of the attribute or null if not found.    </returns>
		public string GetCustomSdpMediaAttribute(Linphone.StreamType type, string attributeName)
		{
			IntPtr stringPtr = linphone_call_params_get_custom_sdp_media_attribute(nativePtr, (int)type, attributeName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_has_custom_sdp_attribute(IntPtr thiz, string attributeName);

		/// <summary>
		/// Returns true if a custom SDP attribute that is related to all the streams is
		/// present. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="attributeName">The name of the attribute to get.    </param>
		/// <returns>Whether the attribute is present. </returns>
		public bool HasCustomSdpAttribute(string attributeName)
		{
			bool returnVal = linphone_call_params_has_custom_sdp_attribute(nativePtr, attributeName) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_has_custom_sdp_media_attribute(IntPtr thiz, int type, string attributeName);

		/// <summary>
		/// Indicates whether a custom SDP attribute that is related to a specific stream
		/// is present or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="type">The type of the stream to add a custom SDP attribute to.
		/// </param>
		/// <param name="attributeName">The name of the attribute to get.    </param>
		/// <returns>Whether the attribute is present. </returns>
		public bool HasCustomSdpMediaAttribute(Linphone.StreamType type, string attributeName)
		{
			bool returnVal = linphone_call_params_has_custom_sdp_media_attribute(nativePtr, (int)type, attributeName) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_is_media_encryption_supported(IntPtr thiz, int encryption);

		/// <summary>
		/// Returns the encryption is supported. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="encryption">The <see cref="Linphone.MediaEncryption">
		/// Linphone.MediaEncryption</see> to check whether is supported </param>
		/// <returns>a boolean indicating whether the encryption is supported </returns>
		public bool IsMediaEncryptionSupported(Linphone.MediaEncryption encryption)
		{
			bool returnVal = linphone_call_params_is_media_encryption_supported(nativePtr, (int)encryption) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_params_tcap_lines_merged(IntPtr thiz);

		/// <summary>
		/// Indicates whether tcap lines with consecutive indexes are going to be merged or
		/// not if capability negotiations (RFC5939) is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a boolean indicating the enablement of tcap line merging </returns>
		public bool TcapLinesMerged()
		{
			bool returnVal = linphone_call_params_tcap_lines_merged(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
	}
	/// <summary>
	/// This object carry various statistic informations regarding the quality of an
	/// audio or video stream for a given <see cref="Linphone.Call">
	/// Linphone.Call</see>. 
	/// <para>
	/// To receive these informations periodically and as soon as they are computed,
	/// implement the call_stats_updated() callback inside a <see cref="Linphone.CoreListener">
	/// Linphone.CoreListener</see>.
	/// At any time, the application can access latest computed statistics using <see cref="Linphone.Call.AudioStats">
	/// Linphone.Call.AudioStats</see> and <see cref="Linphone.Call.VideoStats">
	/// Linphone.Call.VideoStats</see>. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class CallStats : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_download_bandwidth(IntPtr thiz);

		/// <summary>
		/// Get the bandwidth measurement of the received stream, expressed in kbit/s,
		/// including IP/UDP/RTP headers. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The bandwidth measurement of the received stream in kbit/s. </returns>
		public float DownloadBandwidth
		{
			get
			{
				return linphone_call_stats_get_download_bandwidth(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_estimated_download_bandwidth(IntPtr thiz);

		/// <summary>
		/// Get the estimated bandwidth measurement of the received stream, expressed in
		/// kbit/s, including IP/UDP/RTP headers. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The estimated bandwidth measurement of the received stream in kbit/s.
		/// </returns>
		public float EstimatedDownloadBandwidth
		{
			get
			{
				return linphone_call_stats_get_estimated_download_bandwidth(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.IceState linphone_call_stats_get_ice_state(IntPtr thiz);

		/// <summary>
		/// Get the state of ICE processing. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.IceState">Linphone.IceState</see> of ICE
		/// processing </returns>
		public Linphone.IceState IceState
		{
			get
			{
				return linphone_call_stats_get_ice_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AddressFamily linphone_call_stats_get_ip_family_of_remote(IntPtr thiz);

		/// <summary>
		/// Get the IP address family of the remote peer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The IP address family <see cref="Linphone.AddressFamily">
		/// Linphone.AddressFamily</see> of the remote peer. </returns>
		public Linphone.AddressFamily IpFamilyOfRemote
		{
			get
			{
				return linphone_call_stats_get_ip_family_of_remote(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_call_stats_is_zrtp_key_agreement_algo_post_quantum(IntPtr thiz);

		/// <summary>
		/// Did ZRTP used a Post Quantum algorithm to perform a key exchange. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the ZRTP key exchange was performed using a PQ algo false
		/// otherwise: ZRTP exchange not completed or not using a PQ algo </returns>
		public bool IsZrtpKeyAgreementAlgoPostQuantum
		{
			get
			{
				return linphone_call_stats_is_zrtp_key_agreement_algo_post_quantum(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_jitter_buffer_size_ms(IntPtr thiz);

		/// <summary>
		/// Get the jitter buffer size in ms. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The jitter buffer size in ms. </returns>
		public float JitterBufferSizeMs
		{
			get
			{
				return linphone_call_stats_get_jitter_buffer_size_ms(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_call_stats_get_late_packets_cumulative_number(IntPtr thiz);

		/// <summary>
		/// Gets the cumulative number of late packets. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The cumulative number of late packets </returns>
		public uint LatePacketsCumulativeNumber
		{
			get
			{
				return linphone_call_stats_get_late_packets_cumulative_number(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_local_late_rate(IntPtr thiz);

		/// <summary>
		/// Gets the local late rate since last report. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The local late rate </returns>
		public float LocalLateRate
		{
			get
			{
				return linphone_call_stats_get_local_late_rate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_local_loss_rate(IntPtr thiz);

		/// <summary>
		/// Get the local loss rate since last report. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The local loss rate </returns>
		public float LocalLossRate
		{
			get
			{
				return linphone_call_stats_get_local_loss_rate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_receiver_interarrival_jitter(IntPtr thiz);

		/// <summary>
		/// Gets the remote reported interarrival jitter. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The interarrival jitter at last received receiver report </returns>
		public float ReceiverInterarrivalJitter
		{
			get
			{
				return linphone_call_stats_get_receiver_interarrival_jitter(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_receiver_loss_rate(IntPtr thiz);

		/// <summary>
		/// Gets the remote reported loss rate since last report. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The receiver loss rate </returns>
		public float ReceiverLossRate
		{
			get
			{
				return linphone_call_stats_get_receiver_loss_rate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_round_trip_delay(IntPtr thiz);

		/// <summary>
		/// Get the round trip delay in s. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The round trip delay in s. </returns>
		public float RoundTripDelay
		{
			get
			{
				return linphone_call_stats_get_round_trip_delay(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_rtcp_download_bandwidth(IntPtr thiz);

		/// <summary>
		/// Get the bandwidth measurement of the received RTCP, expressed in kbit/s,
		/// including IP/UDP/RTP headers. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The bandwidth measurement of the received RTCP in kbit/s. </returns>
		public float RtcpDownloadBandwidth
		{
			get
			{
				return linphone_call_stats_get_rtcp_download_bandwidth(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_rtcp_upload_bandwidth(IntPtr thiz);

		/// <summary>
		/// Get the bandwidth measurement of the sent RTCP, expressed in kbit/s, including
		/// IP/UDP/RTP headers. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The bandwidth measurement of the sent RTCP in kbit/s. </returns>
		public float RtcpUploadBandwidth
		{
			get
			{
				return linphone_call_stats_get_rtcp_upload_bandwidth(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_sender_interarrival_jitter(IntPtr thiz);

		/// <summary>
		/// Gets the local interarrival jitter. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The interarrival jitter at last emitted sender report </returns>
		public float SenderInterarrivalJitter
		{
			get
			{
				return linphone_call_stats_get_sender_interarrival_jitter(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_sender_loss_rate(IntPtr thiz);

		/// <summary>
		/// Get the local loss rate since last report. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The sender loss rate </returns>
		public float SenderLossRate
		{
			get
			{
				return linphone_call_stats_get_sender_loss_rate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.MediaEncryption linphone_call_stats_get_srtp_source(IntPtr thiz);

		/// <summary>
		/// Get the method used for SRTP key exchange. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.MediaEncryption">
		/// Linphone.MediaEncryption</see> method used to exchange the SRTP keys   
		/// </returns>
		public Linphone.MediaEncryption SrtpSource
		{
			get
			{
				return linphone_call_stats_get_srtp_source(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SrtpSuite linphone_call_stats_get_srtp_suite(IntPtr thiz);

		/// <summary>
		/// Get the SRTP Cryto suite in use. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The SRTP crypto suite currently in use <see cref="Linphone.SrtpSuite">
		/// Linphone.SrtpSuite</see>    </returns>
		public Linphone.SrtpSuite SrtpSuite
		{
			get
			{
				return linphone_call_stats_get_srtp_suite(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.StreamType linphone_call_stats_get_type(IntPtr thiz);

		/// <summary>
		/// Get the type of the stream the stats refer to. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.StreamType">Linphone.StreamType</see> the
		/// stats refer to </returns>
		public Linphone.StreamType Type
		{
			get
			{
				return linphone_call_stats_get_type(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_call_stats_get_upload_bandwidth(IntPtr thiz);

		/// <summary>
		/// Get the bandwidth measurement of the sent stream, expressed in kbit/s,
		/// including IP/UDP/RTP headers. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The bandwidth measurement of the sent stream in kbit/s. </returns>
		public float UploadBandwidth
		{
			get
			{
				return linphone_call_stats_get_upload_bandwidth(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.UpnpState linphone_call_stats_get_upnp_state(IntPtr thiz);

		/// <summary>
		/// Get the state of uPnP processing. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.UpnpState">Linphone.UpnpState</see> of uPnP
		/// processing. </returns>
		public Linphone.UpnpState UpnpState
		{
			get
			{
				return linphone_call_stats_get_upnp_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_stats_get_zrtp_auth_tag_algo(IntPtr thiz);

		/// <summary>
		/// Get the ZRTP algorithm statistics details (authentication method) 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The auth tag algo </returns>
		public string ZrtpAuthTagAlgo
		{
			get
			{
				IntPtr stringPtr = linphone_call_stats_get_zrtp_auth_tag_algo(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_stats_get_zrtp_cipher_algo(IntPtr thiz);

		/// <summary>
		/// Get the ZRTP algorithm statistics details (cipher) 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The cipher algo </returns>
		public string ZrtpCipherAlgo
		{
			get
			{
				IntPtr stringPtr = linphone_call_stats_get_zrtp_cipher_algo(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_stats_get_zrtp_hash_algo(IntPtr thiz);

		/// <summary>
		/// Get the ZRTP algorithm statistics details (hash function) 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The hash algo </returns>
		public string ZrtpHashAlgo
		{
			get
			{
				IntPtr stringPtr = linphone_call_stats_get_zrtp_hash_algo(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_stats_get_zrtp_key_agreement_algo(IntPtr thiz);

		/// <summary>
		/// Get the ZRTP algorithm statistics details (key agreeement) 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The key agreement algo </returns>
		public string ZrtpKeyAgreementAlgo
		{
			get
			{
				IntPtr stringPtr = linphone_call_stats_get_zrtp_key_agreement_algo(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_call_stats_get_zrtp_sas_algo(IntPtr thiz);

		/// <summary>
		/// Get the ZRTP algorithm statistics details (SAS display) 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The sas algo </returns>
		public string ZrtpSasAlgo
		{
			get
			{
				IntPtr stringPtr = linphone_call_stats_get_zrtp_sas_algo(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
	}
	/// <summary>
	/// An chat message is the object that is sent or received through a <see cref="Linphone.ChatRoom">
	/// Linphone.ChatRoom</see>. 
	/// <para>
	/// To create a <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see>, use
	/// <see cref="Linphone.ChatRoom.CreateEmptyMessage()">
	/// Linphone.ChatRoom.CreateEmptyMessage()</see>, then either add text using <see cref="Linphone.ChatMessage.AddUtf8TextContent()">
	/// Linphone.ChatMessage.AddUtf8TextContent()</see> or a <see cref="Linphone.Content">
	/// Linphone.Content</see> with file informations using <see cref="Linphone.ChatMessage.AddFileContent()">
	/// Linphone.ChatMessage.AddFileContent()</see>. A valid <see cref="Linphone.Content">
	/// Linphone.Content</see> for file transfer must contain a type and subtype, the
	/// name of the file and it&apos;s size. Finally call <see cref="Linphone.ChatMessage.Send()">
	/// Linphone.ChatMessage.Send()</see> to send it.
	/// To send files through a <see cref="Linphone.ChatMessage">
	/// Linphone.ChatMessage</see>, you need to have configured a file transfer server
	/// URL with <see cref="Linphone.Core.FileTransferServer">
	/// Linphone.Core.FileTransferServer</see>. On the receiving side, either use <see cref="Linphone.ChatMessage.DownloadContent()">
	/// Linphone.ChatMessage.DownloadContent()</see> to download received files or
	/// enable auto-download in the <see cref="Linphone.Core">Linphone.Core</see> using
	/// <see cref="Linphone.Core.MaxSizeForAutoDownloadIncomingFiles">
	/// Linphone.Core.MaxSizeForAutoDownloadIncomingFiles</see>, -1 disabling the
	/// feature and 0 always downloading files no matter it&apos;s size.
	/// Keep in mind a <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see>
	/// created by a <see cref="Linphone.ChatRoomBackend.Basic">
	/// Linphone.ChatRoomBackend.Basic</see> <see cref="Linphone.ChatRoom">
	/// Linphone.ChatRoom</see> can only contain one <see cref="Linphone.Content">
	/// Linphone.Content</see>, either text or file. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ChatMessage : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_chat_message_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private ChatMessageListener listener;

		public ChatMessageListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_chat_message_cbs(linphone_factory_get());
					listener = fromNativePtr<ChatMessageListener>(nativeListener, false, true);
					linphone_chat_message_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_chat_message_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_appdata(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_set_appdata(IntPtr thiz, string data);

		/// <summary>
		/// Linphone message has an app-specific field that can store a text. 
		/// <para>
		/// The application might want to use it for keeping data over restarts, like
		/// thumbnail image path. 
		/// </para>
		/// </summary>
		/// <returns>the application-specific data or null if none has been stored.   
		/// </returns>
		public string Appdata
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_appdata(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_chat_message_set_appdata(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_call_id(IntPtr thiz);

		/// <summary>
		/// Gets the callId accociated with the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the call Id    </returns>
		public string CallId
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_call_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_chat_room(IntPtr thiz);

		/// <summary>
		/// Returns the chatroom this message belongs to. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.ChatRoom">Linphone.ChatRoom</see> in which
		/// this message has been sent or received.    </returns>
		public Linphone.ChatRoom ChatRoom
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_chat_room(nativePtr);
				Linphone.ChatRoom obj = fromNativePtr<Linphone.ChatRoom>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_content_type(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_set_content_type(IntPtr thiz, string contentType);

		/// <summary>
		/// Get the content type of a chat message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The content type of the chat message    </returns>
		public string ContentType
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_content_type(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_chat_message_set_content_type(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_contents(IntPtr thiz);

		/// <summary>
		/// Returns the list of contents in the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The list of <see cref="Linphone.Content">Linphone.Content</see>.     
		/// </returns>
		public IEnumerable<Linphone.Content> Contents
		{
			get
			{
				return MarshalBctbxList<Linphone.Content>(linphone_chat_message_get_contents(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_core(IntPtr thiz);

		/// <summary>
		/// Returns back pointer to <see cref="Linphone.Core">Linphone.Core</see> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Core">Linphone.Core</see> object associated
		/// with this message.    </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_chat_message_get_ephemeral_expire_time(IntPtr thiz);

		/// <summary>
		/// Returns the real time at which an ephemeral message expires and will be
		/// deleted. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.ChatMessage.IsEphemeral()">
		/// Linphone.ChatMessage.IsEphemeral()</see> </remarks>
		/// <returns>the time at which an ephemeral message expires. 0 means the message
		/// has not been read. </returns>
		public long EphemeralExpireTime
		{
			get
			{
				return linphone_chat_message_get_ephemeral_expire_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_message_get_ephemeral_lifetime(IntPtr thiz);

		/// <summary>
		/// Returns lifetime of an ephemeral message. 
		/// <para>
		/// The lifetime is the duration after which the ephemeral message will disappear
		/// once viewed. </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.ChatMessage.IsEphemeral()">
		/// Linphone.ChatMessage.IsEphemeral()</see> </remarks>
		/// <returns>the lifetime of an ephemeral message, by default 0 (disabled).
		/// </returns>
		public int EphemeralLifetime
		{
			get
			{
				return linphone_chat_message_get_ephemeral_lifetime(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_error_info(IntPtr thiz);

		/// <summary>
		/// Get full details about delivery error of a chat message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.ErrorInfo">Linphone.ErrorInfo</see> describing
		/// the details.    </returns>
		public Linphone.ErrorInfo ErrorInfo
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_error_info(nativePtr);
				Linphone.ErrorInfo obj = fromNativePtr<Linphone.ErrorInfo>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_external_body_url(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_set_external_body_url(IntPtr thiz, string externalBodyUrl);

		/// <summary>
		/// Linphone message can carry external body as defined by rfc2017. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>external body url or null if not present.    </returns>
		public string ExternalBodyUrl
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_external_body_url(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_chat_message_set_external_body_url(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_file_transfer_information(IntPtr thiz);

		/// <summary>
		/// Get the file_transfer_information (used by call backs to recover informations
		/// during a rcs file transfer) 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a pointer to the <see cref="Linphone.Content">Linphone.Content</see>
		/// structure or null if not present.    </returns>
		public Linphone.Content FileTransferInformation
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_file_transfer_information(nativePtr);
				Linphone.Content obj = fromNativePtr<Linphone.Content>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_forward_info(IntPtr thiz);

		/// <summary>
		/// Gets the forward info if available as a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the original sender of the message if it has been forwarded, null
		/// otherwise.    </returns>
		public string ForwardInfo
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_forward_info(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_from_address(IntPtr thiz);

		/// <summary>
		/// Get origin of the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Address">Linphone.Address</see> of the sender.
		///    </returns>
		public Linphone.Address FromAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_from_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_ephemeral(IntPtr thiz);

		/// <summary>
		/// Returns wether the chat message is an ephemeral message or not. 
		/// <para>
		/// An ephemeral message will automatically disappear from the recipient&apos;s
		/// screen after the message has been viewed. 
		/// </para>
		/// </summary>
		/// <returns>true if it is an ephemeral message, false otherwise </returns>
		public bool IsEphemeral
		{
			get
			{
				return linphone_chat_message_is_ephemeral(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_file_transfer(IntPtr thiz);

		/// <summary>
		/// Return whether or not a chat message is a file transfer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Whether or not the message is a file transfer </returns>
		/// deprecated : 06/07/2020 check if <see cref="Linphone.ChatMessage.Contents">
		/// Linphone.ChatMessage.Contents</see> contains a <see cref="Linphone.Content">
		/// Linphone.Content</see> for which <see cref="Linphone.Content.IsFileTransfer()">
		/// Linphone.Content.IsFileTransfer()</see> returns true. 
		public bool IsFileTransfer
		{
			get
			{
				return linphone_chat_message_is_file_transfer(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_file_transfer_in_progress(IntPtr thiz);

		/// <summary>
		/// Gets whether or not a file is currently being downloaded or uploaded. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if download or upload is in progress, false otherwise </returns>
		public bool IsFileTransferInProgress
		{
			get
			{
				return linphone_chat_message_is_file_transfer_in_progress(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_forward(IntPtr thiz);

		/// <summary>
		/// Returns wether the chat message is a forward message or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if it is a forward message, false otherwise </returns>
		public bool IsForward
		{
			get
			{
				return linphone_chat_message_is_forward(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_outgoing(IntPtr thiz);

		/// <summary>
		/// Returns wehther the message has been sent or received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if message has been sent, false if it has been received.
		/// </returns>
		public bool IsOutgoing
		{
			get
			{
				return linphone_chat_message_is_outgoing(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_read(IntPtr thiz);

		/// <summary>
		/// Returns wether the message has been read or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if message has been marked as read, false otherwise. </returns>
		public bool IsRead
		{
			get
			{
				return linphone_chat_message_is_read(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_reply(IntPtr thiz);

		/// <summary>
		/// Returns wether the chat message is a reply message or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if it is a reply message, false otherwise </returns>
		public bool IsReply
		{
			get
			{
				return linphone_chat_message_is_reply(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_secured(IntPtr thiz);

		/// <summary>
		/// Get if the message was encrypted when transfered. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the message was encrypted when transfered, false otherwise.
		/// </returns>
		public bool IsSecured
		{
			get
			{
				return linphone_chat_message_is_secured(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_is_text(IntPtr thiz);

		/// <summary>
		/// Return whether or not a chat message is a text. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Whether or not the message is a text </returns>
		/// deprecated : 06/07/2020 check if <see cref="Linphone.ChatMessage.Contents">
		/// Linphone.ChatMessage.Contents</see> contains a <see cref="Linphone.Content">
		/// Linphone.Content</see> with a PlainText content type. 
		public bool IsText
		{
			get
			{
				return linphone_chat_message_is_text(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_local_address(IntPtr thiz);

		/// <summary>
		/// Returns the local address the message was sent or received with. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Address">Linphone.Address</see> of the local
		/// address used to send/receive this message.    </returns>
		public Linphone.Address LocalAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_local_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_message_id(IntPtr thiz);

		/// <summary>
		/// Get the message identifier. 
		/// <para>
		/// It is used to identify a message so that it can be notified as delivered and/or
		/// displayed. 
		/// </para>
		/// </summary>
		/// <returns>The message identifier.    </returns>
		public string MessageId
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_message_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_own_reaction(IntPtr thiz);

		/// <summary>
		/// Returns our own reaction for a given chat message, if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Our own <see cref="Linphone.ChatMessageReaction">
		/// Linphone.ChatMessageReaction</see> for that message if any, null otherwise.   
		/// </returns>
		public Linphone.ChatMessageReaction OwnReaction
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_own_reaction(nativePtr);
				Linphone.ChatMessageReaction obj = fromNativePtr<Linphone.ChatMessageReaction>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_reactions(IntPtr thiz);

		/// <summary>
		/// Gets the list of reactions received for this chat message. 
		/// <para>
		/// Warning: list is ordered by content of reaction message, not by received
		/// timestamp! 
		/// </para>
		/// </summary>
		/// <returns>The sorted list of reaction if any.         </returns>
		public IEnumerable<Linphone.ChatMessageReaction> Reactions
		{
			get
			{
				return MarshalBctbxList<Linphone.ChatMessageReaction>(linphone_chat_message_get_reactions(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_reply_message(IntPtr thiz);

		/// <summary>
		/// Returns the <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see> this
		/// message is a reply to. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the original message <see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see>.    </returns>
		public Linphone.ChatMessage ReplyMessage
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_reply_message(nativePtr);
				Linphone.ChatMessage obj = fromNativePtr<Linphone.ChatMessage>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_reply_message_id(IntPtr thiz);

		/// <summary>
		/// Returns the ID of the message this is a reply to. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the original message id.    </returns>
		public string ReplyMessageId
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_reply_message_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_reply_message_sender_address(IntPtr thiz);

		/// <summary>
		/// Returns the address of the sender of the message this is a reply to. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the original message sender <see cref="Linphone.Address">
		/// Linphone.Address</see>.    </returns>
		public Linphone.Address ReplyMessageSenderAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_reply_message_sender_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatMessageState linphone_chat_message_get_state(IntPtr thiz);

		/// <summary>
		/// Get the state of the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the current <see cref="Linphone.ChatMessageState">
		/// Linphone.ChatMessageState</see> of the message. </returns>
		public Linphone.ChatMessageState State
		{
			get
			{
				return linphone_chat_message_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_text_content(IntPtr thiz);

		/// <summary>
		/// Gets the text content if available as a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Content">Linphone.Content</see> buffer if
		/// available in System Locale, null otherwise.    </returns>
		/// deprecated : 01/07/2020. Use <see cref="Linphone.ChatMessage.Utf8Text">
		/// Linphone.ChatMessage.Utf8Text</see> instead. 
		public string TextContent
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_text_content(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_chat_message_get_time(IntPtr thiz);

		/// <summary>
		/// Get the time the message was sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the timestamp of when the message was sent. </returns>
		public long Time
		{
			get
			{
				return linphone_chat_message_get_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_to_address(IntPtr thiz);

		/// <summary>
		/// Get destination of the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Address">Linphone.Address</see> of the
		/// recipient.    </returns>
		public Linphone.Address ToAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_message_get_to_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_get_to_be_stored(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_set_to_be_stored(IntPtr thiz, char toBeStored);

		/// <summary>
		/// Get if a chat message is to be stored. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Whether or not the message is to be stored </returns>
		public bool ToBeStored
		{
			get
			{
				return linphone_chat_message_get_to_be_stored(nativePtr) != 0;
			}
			set
			{
				linphone_chat_message_set_to_be_stored(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_utf8_text(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_message_set_utf8_text(IntPtr thiz, string text);

		/// <summary>
		/// Get text part of this message. 
		/// <para>
		/// Introduced in 01/07/2020 
		/// </para>
		/// </summary>
		/// <returns>The text in UTF8 or null if no text.    </returns>
		public string Utf8Text
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_get_utf8_text(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_chat_message_set_utf8_text(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_add_content(IntPtr thiz, IntPtr content);

		/// <summary>
		/// Adds a content to the ChatMessage. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">the <see cref="Linphone.Content">Linphone.Content</see>
		/// object to add.    </param>
		public void AddContent(Linphone.Content content)
		{
			linphone_chat_message_add_content(nativePtr, content != null ? content.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(content);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_add_custom_header(IntPtr thiz, string headerName, string headerValue);

		/// <summary>
		/// Add custom headers to the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">name of the header    </param>
		/// <param name="headerValue">header value    </param>
		public void AddCustomHeader(string headerName, string headerValue)
		{
			linphone_chat_message_add_custom_header(nativePtr, headerName, headerValue);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_add_file_content(IntPtr thiz, IntPtr content);

		/// <summary>
		/// Adds a file content to the ChatMessage. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">the <see cref="Linphone.Content">Linphone.Content</see>
		/// object to add.    </param>
		public void AddFileContent(Linphone.Content content)
		{
			linphone_chat_message_add_file_content(nativePtr, content != null ? content.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(content);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_add_text_content(IntPtr thiz, string text);

		/// <summary>
		/// Creates a <see cref="Linphone.Content">Linphone.Content</see> of type PlainText
		/// with the given text as body. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="text">The text in System Locale to add to the message.    </param>
		/// deprecated : 01/07/2020. Use <see cref="Linphone.ChatMessage.AddUtf8TextContent()">
		/// Linphone.ChatMessage.AddUtf8TextContent()</see> instead. 
		public void AddTextContent(string text)
		{
			linphone_chat_message_add_text_content(nativePtr, text);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_add_utf8_text_content(IntPtr thiz, string text);

		/// <summary>
		/// Creates a <see cref="Linphone.Content">Linphone.Content</see> of type PlainText
		/// with the given text as body. 
		/// <para>
		/// Introduced in 01/07/2020 
		/// </para>
		/// </summary>
		/// <param name="text">The text in UTF8 to add to the message.    </param>
		public void AddUtf8TextContent(string text)
		{
			linphone_chat_message_add_utf8_text_content(nativePtr, text);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_cancel_file_transfer(IntPtr thiz);

		/// <summary>
		/// Cancel an ongoing file transfer attached to this message. 
		/// <para>
		/// (upload or download) 
		/// </para>
		/// </summary>
		public void CancelFileTransfer()
		{
			linphone_chat_message_cancel_file_transfer(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_create_reaction(IntPtr thiz, string utf8Reaction);

		/// <summary>
		/// Creates a emoji reaction for the given chat mesage. 
		/// <para>
		/// To send it, use <see cref="Linphone.ChatMessageReaction.Send()">
		/// Linphone.ChatMessageReaction.Send()</see>. 
		/// </para>
		/// </summary>
		/// <param name="utf8Reaction">the emoji character(s) as UTF-8.    </param>
		/// <returns>a <see cref="Linphone.ChatMessageReaction">
		/// Linphone.ChatMessageReaction</see> object.    </returns>
		public Linphone.ChatMessageReaction CreateReaction(string utf8Reaction)
		{
			IntPtr ptr = linphone_chat_message_create_reaction(nativePtr, utf8Reaction);
			Linphone.ChatMessageReaction returnVal = fromNativePtr<Linphone.ChatMessageReaction>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_download_content(IntPtr thiz, IntPtr content);

		/// <summary>
		/// Start the download of the <see cref="Linphone.Content">Linphone.Content</see>
		/// referenced in the <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see>
		/// from remote server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">the <see cref="Linphone.Content">Linphone.Content</see>
		/// object to download (must have the <see cref="Linphone.Content.IsFileTransfer()">
		/// Linphone.Content.IsFileTransfer()</see> method return true).    </param>
		/// <returns>false if there is an error, true otherwise. </returns>
		public bool DownloadContent(Linphone.Content content)
		{
			bool returnVal = linphone_chat_message_download_content(nativePtr, content != null ? content.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			GC.KeepAlive(content);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_custom_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Retrieve a custom header value given its name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">header name searched    </param>
		/// <returns>the custom header value or null if not found.    </returns>
		public string GetCustomHeader(string headerName)
		{
			IntPtr stringPtr = linphone_chat_message_get_custom_header(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_get_participants_by_imdn_state(IntPtr thiz, int state);

		/// <summary>
		/// Gets the list of participants for which the imdn state has reached the
		/// specified state and the time at which they did. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="state">The LinphoneChatMessageState the imdn have reached (only
		/// use LinphoneChatMessageStateDelivered, LinphoneChatMessageStateDeliveredToUser,
		/// LinphoneChatMessageStateDisplayed and LinphoneChatMessageStateNotDelivered)
		/// </param>
		/// <returns>The list of participants.         </returns>
		public IEnumerable<Linphone.ParticipantImdnState> GetParticipantsByImdnState(Linphone.ChatMessageState state)
		{
			IEnumerable<Linphone.ParticipantImdnState> returnVal = MarshalBctbxList<Linphone.ParticipantImdnState>(linphone_chat_message_get_participants_by_imdn_state(nativePtr, (int)state), false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_has_conference_invitation_content(IntPtr thiz);

		/// <summary>
		/// Returns wether the chat message has a conference invitation content or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if it has one, false otherwise. </returns>
		public bool HasConferenceInvitationContent()
		{
			bool returnVal = linphone_chat_message_has_conference_invitation_content(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_message_has_text_content(IntPtr thiz);

		/// <summary>
		/// Returns wether the chat message has a text content or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if it has one, false otherwise. </returns>
		/// deprecated : 27/10/2020. Check if <see cref="Linphone.ChatMessage.Contents">
		/// Linphone.ChatMessage.Contents</see> contains a <see cref="Linphone.Content">
		/// Linphone.Content</see> for which it&apos;s content type is PlainText. 
		public bool HasTextContent()
		{
			bool returnVal = linphone_chat_message_has_text_content(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_message_put_char(IntPtr thiz, uint character);

		/// <summary>
		/// Fulfill a chat message char by char. 
		/// <para>
		/// Message linked to a Real Time Text Call send char in realtime following RFC
		/// 4103/T.140 To commit a message, use linphone_chat_room_send_message 
		/// </para>
		/// </summary>
		/// <param name="character">T.140 char </param>
		/// <returns>0 if succeed. </returns>
		public void PutChar(uint character)
		{
			int exception_result = linphone_chat_message_put_char(nativePtr, character);
			if (exception_result != 0) throw new LinphoneException("PutChar returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_remove_content(IntPtr thiz, IntPtr content);

		/// <summary>
		/// Removes a content from the ChatMessage. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">the <see cref="Linphone.Content">Linphone.Content</see>
		/// object to remove.    </param>
		public void RemoveContent(Linphone.Content content)
		{
			linphone_chat_message_remove_content(nativePtr, content != null ? content.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(content);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_remove_custom_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Removes a custom header from the message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">name of the header to remove    </param>
		public void RemoveCustomHeader(string headerName)
		{
			linphone_chat_message_remove_custom_header(nativePtr, headerName);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_send(IntPtr thiz);

		/// <summary>
		/// Send a chat message. 
		/// <para>
		/// </para>
		/// </summary>
		public void Send()
		{
			linphone_chat_message_send(nativePtr);
			
			
						
		}
	}
	/// <summary>
	/// A chat message reaction is an emoji sent by someone in the same chat room to
	/// react to a specific <see cref="Linphone.ChatMessage">
	/// Linphone.ChatMessage</see>. 
	/// <para>
	/// To create a <see cref="Linphone.ChatMessageReaction">
	/// Linphone.ChatMessageReaction</see>, use <see cref="Linphone.ChatMessage.CreateReaction()">
	/// Linphone.ChatMessage.CreateReaction()</see>. Once you are ready, send the
	/// reaction using <see cref="Linphone.ChatMessageReaction.Send()">
	/// Linphone.ChatMessageReaction.Send()</see>.
	/// Reactions are available using <see cref="Linphone.ChatMessage.Reactions">
	/// Linphone.ChatMessage.Reactions</see> and will be notified using dedicated
	/// callbacks either in #LinphoneCoreListener or #LinphoneChatMessageListener. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ChatMessageReaction : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_reaction_get_body(IntPtr thiz);

		/// <summary>
		/// Returns the emoji(s) used for the reaction. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the emoji(s) used as UTF-8 characters.    </returns>
		public string Body
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_reaction_get_body(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_reaction_get_call_id(IntPtr thiz);

		/// <summary>
		/// Allows to get the Call ID associated with a <see cref="Linphone.ChatMessageReaction">
		/// Linphone.ChatMessageReaction</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the Call ID associated with this reaction. </returns>
		public string CallId
		{
			get
			{
				IntPtr stringPtr = linphone_chat_message_reaction_get_call_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_message_reaction_get_from_address(IntPtr thiz);

		/// <summary>
		/// Returns the <see cref="Linphone.Address">Linphone.Address</see> of the
		/// participant that sent this reaction. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Address">Linphone.Address</see> that sent this
		/// reaction.    </returns>
		public Linphone.Address FromAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_message_reaction_get_from_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_message_reaction_send(IntPtr thiz);

		/// <summary>
		/// Sends a <see cref="Linphone.ChatMessageReaction">
		/// Linphone.ChatMessageReaction</see>. 
		/// <para>
		/// </para>
		/// </summary>
		public void Send()
		{
			linphone_chat_message_reaction_send(nativePtr);
			
			
						
		}
	}
	/// <summary>
	/// A chat room is the place where <see cref="Linphone.ChatMessage">
	/// Linphone.ChatMessage</see> are exchanged. 
	/// <para>
	/// To create (or find) a <see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>,
	/// you first need a <see cref="Linphone.ChatRoomParams">
	/// Linphone.ChatRoomParams</see> object. A chat room is uniquely identified by
	/// it&apos;s local and remote SIP addresses, meaning you can only have one chat
	/// room between two accounts (unless the backend is <see cref="Linphone.ChatRoomBackend.FlexisipChat">
	/// Linphone.ChatRoomBackend.FlexisipChat</see>). Then you can call <see cref="Linphone.Core.SearchChatRoom()">
	/// Linphone.Core.SearchChatRoom()</see> or <see cref="Linphone.Core.CreateChatRoom()">
	/// Linphone.Core.CreateChatRoom()</see>.
	/// Be careful as a <see cref="Linphone.ChatRoomBackend.FlexisipChat">
	/// Linphone.ChatRoomBackend.FlexisipChat</see> backend <see cref="Linphone.ChatRoom">
	/// Linphone.ChatRoom</see> will be created asynchronously, so make sure you add a
	/// <see cref="Linphone.ChatRoomListener">Linphone.ChatRoomListener</see> to the
	/// returned object to be notified when it will be in state <see cref="Linphone.ChatRoomState.Created">
	/// Linphone.ChatRoomState.Created</see>.
	/// All chat rooms are loaded from database when the <see cref="Linphone.Core">
	/// Linphone.Core</see> starts, and you can get them using <see cref="Linphone.Core.ChatRooms">
	/// Linphone.Core.ChatRooms</see>. This method doesn&apos;t return empty chat rooms
	/// nor ones for which the local address doesn&apos;t match an existing <see cref="Linphone.ProxyConfig">
	/// Linphone.ProxyConfig</see> identity, unless you specify otherwise in the [misc]
	/// section of your configuration file by setting hide_empty_chat_rooms=0 and/or
	/// hide_chat_rooms_from_removed_proxies=0. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ChatRoom : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_chat_room_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private ChatRoomListener listener;

		public ChatRoomListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_chat_room_cbs(linphone_factory_get());
					listener = fromNativePtr<ChatRoomListener>(nativeListener, false, true);
					linphone_chat_room_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_chat_room_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_state_to_string(int state);

		/// <summary>
		/// Converts a <see cref="Linphone.ChatRoomState">Linphone.ChatRoomState</see> enum
		/// to a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="state">a <see cref="Linphone.ChatRoomState">
		/// Linphone.ChatRoomState</see> to convert to string </param>
		/// <returns>the string representation of the <see cref="Linphone.ChatRoomState">
		/// Linphone.ChatRoomState</see>    </returns>
		public static string StateToString(Linphone.ChatRoomState state)
		{
			IntPtr stringPtr = linphone_chat_room_state_to_string((int)state);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_call(IntPtr thiz);

		/// <summary>
		/// Gets the current call associated to this chatroom if any To commit a message,
		/// use <see cref="Linphone.ChatMessage.Send()">Linphone.ChatMessage.Send()</see> 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.Call">Linphone.Call</see> or null.    </returns>
		public Linphone.Call Call
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_chat_room_get_capabilities(IntPtr thiz);

		/// <summary>
		/// Get the capabilities of a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The capabilities of the chat room (as a
		/// LinphoneChatRoomCapabilitiesMask) </returns>
		public uint Capabilities
		{
			get
			{
				return linphone_chat_room_get_capabilities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_chat_room_get_char(IntPtr thiz);

		/// <summary>
		/// When realtime text is enabled <see cref="Linphone.CallParams.RealtimeTextEnabled()">
		/// Linphone.CallParams.RealtimeTextEnabled()</see>,
		/// LinphoneCoreIsComposingReceivedCb is call everytime a char is received from
		/// peer. 
		/// <para>
		/// At the end of remote typing a regular <see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> is received with committed data from
		/// LinphoneCoreCbsMessageReceivedCb. 
		/// </para>
		/// </summary>
		/// <returns>RFC 4103/T.140 char </returns>
		public uint Char
		{
			get
			{
				return linphone_chat_room_get_char(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_composing_addresses(IntPtr thiz);

		/// <summary>
		/// Gets the list of participants that are currently composing. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>List of addresses that are in the is_composing state.   </returns>
		public IEnumerable<Linphone.Address> ComposingAddresses
		{
			get
			{
				return MarshalBctbxList<Linphone.Address>(linphone_chat_room_get_composing_addresses(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_conference_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_set_conference_address(IntPtr thiz, IntPtr conferenceAddress);

		/// <summary>
		/// Get the conference address of the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The conference address of the chat room or null if this type of chat
		/// room is not conference based.    </returns>
		public Linphone.Address ConferenceAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_conference_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				linphone_chat_room_set_conference_address(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_core(IntPtr thiz);

		/// <summary>
		/// Returns back pointer to <see cref="Linphone.Core">Linphone.Core</see> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Core">Linphone.Core</see> object this chat
		/// room is attached to.    </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_chat_room_get_creation_time(IntPtr thiz);

		/// <summary>
		/// Return the creation time for the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the time at which the chat room was created </returns>
		public long CreationTime
		{
			get
			{
				return linphone_chat_room_get_creation_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_current_params(IntPtr thiz);

		/// <summary>
		/// Returns current parameters associated with the chat room. 
		/// <para>
		/// This is typically the parameters passed at chat room chat_roomeation to
		/// linphone_core_chat_roomeate_chat_room() or some default parameters if no <see cref="Linphone.ChatRoomParams">
		/// Linphone.ChatRoomParams</see> was explicitely passed during chat room
		/// chat_roomeation. 
		/// </para>
		/// </summary>
		/// <returns>the current <see cref="Linphone.ChatRoomParams">
		/// Linphone.ChatRoomParams</see> parameters.    </returns>
		public Linphone.ChatRoomParams CurrentParams
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_current_params(nativePtr);
				Linphone.ChatRoomParams obj = fromNativePtr<Linphone.ChatRoomParams>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_ephemeral_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_enable_ephemeral(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether or not the ephemeral message feature is enabled in the chat
		/// room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if ephemeral is enabled, false otherwise. </returns>
		public bool EphemeralEnabled
		{
			get
			{
				return linphone_chat_room_ephemeral_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_chat_room_enable_ephemeral(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_room_get_ephemeral_lifetime(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_set_ephemeral_lifetime(IntPtr thiz, int time);

		/// <summary>
		/// Get lifetime (in seconds) for all new ephemeral messages in the chat room. 
		/// <para>
		/// After the message is read, it will be deleted after &quot;time&quot; seconds.
		/// </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.ChatRoom.EphemeralEnabled()">
		/// Linphone.ChatRoom.EphemeralEnabled()</see> </remarks>
		/// <returns>the ephemeral lifetime (in secoonds) </returns>
		public int EphemeralLifetime
		{
			get
			{
				return linphone_chat_room_get_ephemeral_lifetime(nativePtr);
			}
			set
			{
				linphone_chat_room_set_ephemeral_lifetime(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomEphemeralMode linphone_chat_room_get_ephemeral_mode(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_set_ephemeral_mode(IntPtr thiz, int mode);

		/// <summary>
		/// Get the ephemeral mode of the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.ChatRoom.EphemeralEnabled()">
		/// Linphone.ChatRoom.EphemeralEnabled()</see> </remarks>
		/// <returns>the ephemeral mode <see cref="Linphone.ChatRoomEphemeralMode">
		/// Linphone.ChatRoomEphemeralMode</see> </returns>
		public Linphone.ChatRoomEphemeralMode EphemeralMode
		{
			get
			{
				return linphone_chat_room_get_ephemeral_mode(nativePtr);
			}
			set
			{
				linphone_chat_room_set_ephemeral_mode(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_room_get_history_events_size(IntPtr thiz);

		/// <summary>
		/// Gets the number of events in a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the number of events. </returns>
		public int HistoryEventsSize
		{
			get
			{
				return linphone_chat_room_get_history_events_size(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_room_get_history_size(IntPtr thiz);

		/// <summary>
		/// Gets the number of messages in a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the number of messages. </returns>
		public int HistorySize
		{
			get
			{
				return linphone_chat_room_get_history_size(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_is_empty(IntPtr thiz);

		/// <summary>
		/// Returns whether or not a <see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// has at least one <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see> or
		/// not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if there are no <see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see>, false otherwise. </returns>
		public bool IsEmpty
		{
			get
			{
				return linphone_chat_room_is_empty(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_is_read_only(IntPtr thiz);

		/// <summary>
		/// Return whether or not a message can be sent using this chat room. 
		/// <para>
		/// A chat room may be read only until it&apos;s created, or when it&apos;s a group
		/// you have left. 
		/// </para>
		/// </summary>
		/// <returns>true if a chat message can&apos;t be sent in it, false otherwise.
		/// </returns>
		public bool IsReadOnly
		{
			get
			{
				return linphone_chat_room_is_read_only(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_is_remote_composing(IntPtr thiz);

		/// <summary>
		/// Tells whether the remote is currently composing a message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the remote is currently composing a message, false otherwise.
		/// </returns>
		public bool IsRemoteComposing
		{
			get
			{
				return linphone_chat_room_is_remote_composing(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_last_message_in_history(IntPtr thiz);

		/// <summary>
		/// Gets the last chat message sent or received in this chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the latest <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see>
		/// or null if no message.    </returns>
		public Linphone.ChatMessage LastMessageInHistory
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_last_message_in_history(nativePtr);
				Linphone.ChatMessage obj = fromNativePtr<Linphone.ChatMessage>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_chat_room_get_last_update_time(IntPtr thiz);

		/// <summary>
		/// Return the last updated time for the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the last updated time </returns>
		public long LastUpdateTime
		{
			get
			{
				return linphone_chat_room_get_last_update_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_local_address(IntPtr thiz);

		/// <summary>
		/// Get the local address associated to this chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The local address.    </returns>
		public Linphone.Address LocalAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_local_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_me(IntPtr thiz);

		/// <summary>
		/// Get the participant representing myself in the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The participant representing myself in the conference or null if me is
		/// not set.    </returns>
		public Linphone.Participant Me
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_me(nativePtr);
				Linphone.Participant obj = fromNativePtr<Linphone.Participant>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_get_muted(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_set_muted(IntPtr thiz, char muted);

		/// <summary>
		/// Gets if a chat room has been flagged as muted (not by default). 
		/// <para>
		/// A muted chat room isn&apos;t used to compute unread messages total count. 
		/// </para>
		/// </summary>
		/// <returns>true if the chat room is muted, false otherwise. </returns>
		public bool Muted
		{
			get
			{
				return linphone_chat_room_get_muted(nativePtr) != 0;
			}
			set
			{
				linphone_chat_room_set_muted(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_room_get_nb_participants(IntPtr thiz);

		/// <summary>
		/// Get the number of participants in the chat room (that is without ourselves). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The number of participants in the chat room </returns>
		public int NbParticipants
		{
			get
			{
				return linphone_chat_room_get_nb_participants(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_participants(IntPtr thiz);

		/// <summary>
		/// Get the list of participants of a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A   of the participants       </returns>
		public IEnumerable<Linphone.Participant> Participants
		{
			get
			{
				return MarshalBctbxList<Linphone.Participant>(linphone_chat_room_get_participants(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_peer_address(IntPtr thiz);

		/// <summary>
		/// Get the peer address associated to this chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The peer address.    </returns>
		public Linphone.Address PeerAddress
		{
			get
			{
				IntPtr ptr = linphone_chat_room_get_peer_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomSecurityLevel linphone_chat_room_get_security_level(IntPtr thiz);

		/// <summary>
		/// Get the security level of a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current <see cref="Linphone.ChatRoomSecurityLevel">
		/// Linphone.ChatRoomSecurityLevel</see> of the chat room </returns>
		public Linphone.ChatRoomSecurityLevel SecurityLevel
		{
			get
			{
				return linphone_chat_room_get_security_level(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomState linphone_chat_room_get_state(IntPtr thiz);

		/// <summary>
		/// Get the state of the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current <see cref="Linphone.ChatRoomState">
		/// Linphone.ChatRoomState</see> of the chat room </returns>
		public Linphone.ChatRoomState State
		{
			get
			{
				return linphone_chat_room_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_subject(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_set_subject(IntPtr thiz, string subject);

		/// <summary>
		/// Get the subject of a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The subject of the chat room.    </returns>
		public string Subject
		{
			get
			{
				IntPtr stringPtr = linphone_chat_room_get_subject(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_chat_room_set_subject(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_unread_history(IntPtr thiz);

		/// <summary>
		/// Gets all unread messages for this chat room, sorted from oldest to most recent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of unread chat messages.      </returns>
		public IEnumerable<Linphone.ChatMessage> UnreadHistory
		{
			get
			{
				return MarshalBctbxList<Linphone.ChatMessage>(linphone_chat_room_get_unread_history(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_room_get_unread_messages_count(IntPtr thiz);

		/// <summary>
		/// Gets the number of unread messages in the chatroom. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the number of unread messages. </returns>
		public int UnreadMessagesCount
		{
			get
			{
				return linphone_chat_room_get_unread_messages_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_add_participant(IntPtr thiz, IntPtr addr);

		/// <summary>
		/// Add a participant to a chat room. 
		/// <para>
		/// This may fail if this type of chat room does not handle participants. Use <see cref="Linphone.ChatRoom.CanHandleParticipants()">
		/// Linphone.ChatRoom.CanHandleParticipants()</see> to know if this chat room
		/// handles participants. 
		/// </para>
		/// </summary>
		/// <param name="addr">The address of the participant to add to the chat room   
		/// </param>
		public void AddParticipant(Linphone.Address addr)
		{
			linphone_chat_room_add_participant(nativePtr, addr != null ? addr.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(addr);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_add_participants(IntPtr thiz, IntPtr addresses);

		/// <summary>
		/// Add several participants to a chat room at once. 
		/// <para>
		/// This may fail if this type of chat room does not handle participants. Use <see cref="Linphone.ChatRoom.CanHandleParticipants()">
		/// Linphone.ChatRoom.CanHandleParticipants()</see> to know if this chat room
		/// handles participants. 
		/// </para>
		/// </summary>
		/// <param name="addresses">The participants to add.      </param>
		/// <returns>true if everything is OK, false otherwise </returns>
		public bool AddParticipants(IEnumerable<Linphone.Address> addresses)
		{
			bool returnVal = linphone_chat_room_add_participants(nativePtr, ObjectArrayToBctbxList<Linphone.Address>(addresses)) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_allow_cpim(IntPtr thiz);

		/// <summary>
		/// Allow cpim on a basic chat room   . 
		/// <para>
		/// </para>
		/// </summary>
		public void AllowCpim()
		{
			linphone_chat_room_allow_cpim(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_allow_multipart(IntPtr thiz);

		/// <summary>
		/// Allow multipart on a basic chat room   . 
		/// <para>
		/// </para>
		/// </summary>
		public void AllowMultipart()
		{
			linphone_chat_room_allow_multipart(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_can_handle_participants(IntPtr thiz);

		/// <summary>
		/// Tells whether a chat room is able to handle participants. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the chat room can handle participants, false otherwise
		/// </returns>
		public bool CanHandleParticipants()
		{
			bool returnVal = linphone_chat_room_can_handle_participants(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_compose(IntPtr thiz);

		/// <summary>
		/// Notifies the destination of the chat message being composed that the user is
		/// typing a new message. 
		/// <para>
		/// </para>
		/// </summary>
		public void Compose()
		{
			linphone_chat_room_compose(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_create_empty_message(IntPtr thiz);

		/// <summary>
		/// Creates an empty message attached to the given chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a new <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see>   
		/// </returns>
		public Linphone.ChatMessage CreateEmptyMessage()
		{
			IntPtr ptr = linphone_chat_room_create_empty_message(nativePtr);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_create_file_transfer_message(IntPtr thiz, IntPtr initialContent);

		/// <summary>
		/// Creates a message attached to the given chat room with a particular content. 
		/// <para>
		/// Use <see cref="Linphone.ChatMessage.Send()">Linphone.ChatMessage.Send()</see>
		/// to initiate the transfer 
		/// </para>
		/// </summary>
		/// <param name="initialContent"><see cref="Linphone.Content">
		/// Linphone.Content</see> initial content.    </param>
		/// <returns>a new <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see>   
		/// </returns>
		public Linphone.ChatMessage CreateFileTransferMessage(Linphone.Content initialContent)
		{
			IntPtr ptr = linphone_chat_room_create_file_transfer_message(nativePtr, initialContent != null ? initialContent.nativePtr : IntPtr.Zero);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, false);
			
			GC.KeepAlive(initialContent);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_create_forward_message(IntPtr thiz, IntPtr message);

		/// <summary>
		/// Creates a forward message attached to the given chat room with a particular
		/// message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message"><see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> message to be forwarded.    </param>
		/// <returns>a new <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see>   
		/// </returns>
		public Linphone.ChatMessage CreateForwardMessage(Linphone.ChatMessage message)
		{
			IntPtr ptr = linphone_chat_room_create_forward_message(nativePtr, message != null ? message.nativePtr : IntPtr.Zero);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, false);
			
			GC.KeepAlive(message);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_create_message(IntPtr thiz, string message);

		/// <summary>
		/// Creates a message attached to the given chat room with a plain text content
		/// filled with the given message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">text message, null if absent.    </param>
		/// <returns>a new <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see>   
		/// </returns>
		/// deprecated : 01/07/2020. Use <see cref="Linphone.ChatRoom.CreateMessageFromUtf8()">
		/// Linphone.ChatRoom.CreateMessageFromUtf8()</see> instead. 
		public Linphone.ChatMessage CreateMessage(string message)
		{
			IntPtr ptr = linphone_chat_room_create_message(nativePtr, message);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_create_message_from_utf8(IntPtr thiz, string message);

		/// <summary>
		/// Creates a message attached to the given chat room with a plain text content
		/// filled with the given message. 
		/// <para>
		/// Introduced in 01/07/2020 
		/// </para>
		/// </summary>
		/// <param name="message">text message in UTF8, null if absent.    </param>
		/// <returns>a new <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see>   
		/// </returns>
		public Linphone.ChatMessage CreateMessageFromUtf8(string message)
		{
			IntPtr ptr = linphone_chat_room_create_message_from_utf8(nativePtr, message);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_create_reply_message(IntPtr thiz, IntPtr message);

		/// <summary>
		/// Creates a reply message attached to the given chat room with a particular
		/// message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message"><see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> message to reply to.    </param>
		/// <returns>a new <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see>   
		/// </returns>
		public Linphone.ChatMessage CreateReplyMessage(Linphone.ChatMessage message)
		{
			IntPtr ptr = linphone_chat_room_create_reply_message(nativePtr, message != null ? message.nativePtr : IntPtr.Zero);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, false);
			
			GC.KeepAlive(message);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_create_voice_recording_message(IntPtr thiz, IntPtr recorder);

		/// <summary>
		/// Creates a chat message with a voice recording attached to the given chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : If the recorder isn&apos;t in Closed state, it will return
		/// an empty message! </remarks> 
		/// <param name="recorder">the <see cref="Linphone.Recorder">
		/// Linphone.Recorder</see> object used to record the voice message.    </param>
		/// <returns>a new <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see>   
		/// </returns>
		public Linphone.ChatMessage CreateVoiceRecordingMessage(Linphone.Recorder recorder)
		{
			IntPtr ptr = linphone_chat_room_create_voice_recording_message(nativePtr, recorder != null ? recorder.nativePtr : IntPtr.Zero);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, false);
			
			GC.KeepAlive(recorder);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_delete_history(IntPtr thiz);

		/// <summary>
		/// Delete all messages from the history. 
		/// <para>
		/// </para>
		/// </summary>
		public void DeleteHistory()
		{
			linphone_chat_room_delete_history(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_delete_message(IntPtr thiz, IntPtr message);

		/// <summary>
		/// Delete a message from the chat room history. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The <see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> object to remove.    </param>
		public void DeleteMessage(Linphone.ChatMessage message)
		{
			linphone_chat_room_delete_message(nativePtr, message != null ? message.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(message);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_ephemeral_supported_by_all_participants(IntPtr thiz);

		/// <summary>
		/// Uses linphone spec to check if all participants support ephemeral messages. 
		/// <para>
		/// It doesn&apos;t prevent to send ephemeral messages in the room but those who
		/// don&apos;t support it won&apos;t delete messages after lifetime has expired.
		/// </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.ChatRoom.EphemeralEnabled()">
		/// Linphone.ChatRoom.EphemeralEnabled()</see> </remarks>
		/// <returns>true if all participants in the chat room support ephemeral messages,
		/// false otherwise </returns>
		public bool EphemeralSupportedByAllParticipants()
		{
			bool returnVal = linphone_chat_room_ephemeral_supported_by_all_participants(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_find_message(IntPtr thiz, string messageId);

		/// <summary>
		/// Gets the chat message sent or received in this chat room that matches the
		/// message_id. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="messageId">The id of the message to find    </param>
		/// <returns>the <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see> if
		/// found or null.    </returns>
		public Linphone.ChatMessage FindMessage(string messageId)
		{
			IntPtr ptr = linphone_chat_room_find_message(nativePtr, messageId);
			Linphone.ChatMessage returnVal = fromNativePtr<Linphone.ChatMessage>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_find_participant(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Find a participant of a chat room from its address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address">The <see cref="Linphone.Address">Linphone.Address</see>
		/// to search in the list of participants of the chat room    </param>
		/// <returns>The participant if found, null otherwise.    </returns>
		public Linphone.Participant FindParticipant(Linphone.Address address)
		{
			IntPtr ptr = linphone_chat_room_find_participant(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			Linphone.Participant returnVal = fromNativePtr<Linphone.Participant>(ptr, true);
			
			GC.KeepAlive(address);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_history(IntPtr thiz, int nbMessage);

		/// <summary>
		/// Gets nb_message most recent messages from chat_room chat room, sorted from
		/// oldest to most recent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="nbMessage">Number of message to retrieve. 0 means everything.
		/// </param>
		/// <returns>A list of chat messages.      </returns>
		public IEnumerable<Linphone.ChatMessage> GetHistory(int nbMessage)
		{
			IEnumerable<Linphone.ChatMessage> returnVal = MarshalBctbxList<Linphone.ChatMessage>(linphone_chat_room_get_history(nativePtr, nbMessage), false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_history_events(IntPtr thiz, int nbEvents);

		/// <summary>
		/// Gets nb_events most recent events from chat_room chat room, sorted from oldest
		/// to most recent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="nbEvents">Number of events to retrieve. 0 means everything.
		/// </param>
		/// <returns>The list of the most recent events.      </returns>
		public IEnumerable<Linphone.EventLog> GetHistoryEvents(int nbEvents)
		{
			IEnumerable<Linphone.EventLog> returnVal = MarshalBctbxList<Linphone.EventLog>(linphone_chat_room_get_history_events(nativePtr, nbEvents), false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_history_message_events(IntPtr thiz, int nbEvents);

		/// <summary>
		/// Gets nb_events most recent chat message events from chat_room chat room, sorted
		/// from oldest to most recent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="nbEvents">Number of events to retrieve. 0 means everything.
		/// </param>
		/// <returns>A list      </returns>
		public IEnumerable<Linphone.EventLog> GetHistoryMessageEvents(int nbEvents)
		{
			IEnumerable<Linphone.EventLog> returnVal = MarshalBctbxList<Linphone.EventLog>(linphone_chat_room_get_history_message_events(nativePtr, nbEvents), false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_history_range(IntPtr thiz, int begin, int end);

		/// <summary>
		/// Gets the partial list of messages in the given range, sorted from oldest to
		/// most recent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="begin">The first message of the range to be retrieved. History
		/// most recent message has index 0. </param>
		/// <param name="end">The last message of the range to be retrieved. History oldest
		/// message has index of history size - 1 (use <see cref="Linphone.ChatRoom.HistorySize">
		/// Linphone.ChatRoom.HistorySize</see> to retrieve history size) </param>
		/// <returns>A list of chat messages.      </returns>
		public IEnumerable<Linphone.ChatMessage> GetHistoryRange(int begin, int end)
		{
			IEnumerable<Linphone.ChatMessage> returnVal = MarshalBctbxList<Linphone.ChatMessage>(linphone_chat_room_get_history_range(nativePtr, begin, end), false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_history_range_events(IntPtr thiz, int begin, int end);

		/// <summary>
		/// Gets the partial list of events in the given range, sorted from oldest to most
		/// recent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="begin">The first event of the range to be retrieved. History most
		/// recent event has index 0. </param>
		/// <param name="end">The last event of the range to be retrieved. History oldest
		/// event has index of history size - 1 </param>
		/// <returns>The list of the found events.      </returns>
		public IEnumerable<Linphone.EventLog> GetHistoryRangeEvents(int begin, int end)
		{
			IEnumerable<Linphone.EventLog> returnVal = MarshalBctbxList<Linphone.EventLog>(linphone_chat_room_get_history_range_events(nativePtr, begin, end), false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_get_history_range_message_events(IntPtr thiz, int begin, int end);

		/// <summary>
		/// Gets the partial list of chat message events in the given range, sorted from
		/// oldest to most recent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="begin">The first event of the range to be retrieved. History most
		/// recent event has index 0. </param>
		/// <param name="end">The last event of the range to be retrieved. History oldest
		/// event has index of history size - 1 </param>
		/// <returns>The list of chat message events.      </returns>
		public IEnumerable<Linphone.EventLog> GetHistoryRangeMessageEvents(int begin, int end)
		{
			IEnumerable<Linphone.EventLog> returnVal = MarshalBctbxList<Linphone.EventLog>(linphone_chat_room_get_history_range_message_events(nativePtr, begin, end), false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_has_been_left(IntPtr thiz);

		/// <summary>
		/// Return whether or not the chat room has been left. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the chat room has been left, false otherwise. </returns>
		/// deprecated : 16/03/2022 use <see cref="Linphone.ChatRoom.IsReadOnly()">
		/// Linphone.ChatRoom.IsReadOnly()</see> instead. 
		public bool HasBeenLeft()
		{
			bool returnVal = linphone_chat_room_has_been_left(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_has_capability(IntPtr thiz, int mask);

		/// <summary>
		/// Check if a chat room has given capabilities. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="mask">a LinphoneChatRoomCapabilitiesMask mask </param>
		/// <returns>true if the mask matches, false otherwise </returns>
		public bool HasCapability(int mask)
		{
			bool returnVal = linphone_chat_room_has_capability(nativePtr, mask) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_leave(IntPtr thiz);

		/// <summary>
		/// Leave a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		public void Leave()
		{
			linphone_chat_room_leave(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_mark_as_read(IntPtr thiz);

		/// <summary>
		/// Mark all messages of the conversation as read. 
		/// <para>
		/// </para>
		/// </summary>
		public void MarkAsRead()
		{
			linphone_chat_room_mark_as_read(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_notify_participant_device_registration(IntPtr thiz, IntPtr participantDevice);

		/// <summary>
		/// Notify the chatroom that a participant device has just registered. 
		/// <para>
		/// This function is meaningful only for server implementation of chatroom, and
		/// shall not by used by client applications. 
		/// </para>
		/// </summary>
		/// <param name="participantDevice">list of the participant devices to be used by
		/// the group chat room    </param>
		public void NotifyParticipantDeviceRegistration(Linphone.Address participantDevice)
		{
			linphone_chat_room_notify_participant_device_registration(nativePtr, participantDevice != null ? participantDevice.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(participantDevice);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_receive_chat_message(IntPtr thiz, IntPtr message);

		/// <summary>
		/// Used to receive a chat message when using async mechanism with IM
		/// enchat_roomyption engine. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message"><see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see> object    </param>
		public void ReceiveChatMessage(Linphone.ChatMessage message)
		{
			linphone_chat_room_receive_chat_message(nativePtr, message != null ? message.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(message);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_remove_participant(IntPtr thiz, IntPtr participant);

		/// <summary>
		/// Remove a participant of a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participant">The participant to remove from the chat room   
		/// </param>
		public void RemoveParticipant(Linphone.Participant participant)
		{
			linphone_chat_room_remove_participant(nativePtr, participant != null ? participant.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(participant);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_remove_participants(IntPtr thiz, IntPtr participants);

		/// <summary>
		/// Remove several participants of a chat room at once. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participants">The participants to remove.      </param>
		public void RemoveParticipants(IEnumerable<Linphone.Participant> participants)
		{
			linphone_chat_room_remove_participants(nativePtr, ObjectArrayToBctbxList<Linphone.Participant>(participants));
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_set_participant_admin_status(IntPtr thiz, IntPtr participant, char isAdmin);

		/// <summary>
		/// Change the admin status of a participant of a chat room (you need to be an
		/// admin yourself to do this). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participant">The Participant for which to change the admin status 
		///   </param>
		/// <param name="isAdmin">A boolean value telling whether the participant should
		/// now be an admin or not </param>
		public void SetParticipantAdminStatus(Linphone.Participant participant, bool isAdmin)
		{
			linphone_chat_room_set_participant_admin_status(nativePtr, participant != null ? participant.nativePtr : IntPtr.Zero, isAdmin ? (char)1 : (char)0);
			
			
			GC.KeepAlive(participant);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_set_participant_devices(IntPtr thiz, IntPtr participantAddress, IntPtr deviceIdentities);

		/// <summary>
		/// Set the list of participant devices in the form of SIP URIs with GRUUs for a
		/// given participant. 
		/// <para>
		/// This function is meaningful only for server implementation of chatroom, and
		/// shall not by used by client applications. 
		/// </para>
		/// </summary>
		/// <param name="participantAddress">The participant address    </param>
		/// <param name="deviceIdentities">List of the participant devices to be used by
		/// the group chat room      </param>
		public void SetParticipantDevices(Linphone.Address participantAddress, IEnumerable<Linphone.ParticipantDeviceIdentity> deviceIdentities)
		{
			linphone_chat_room_set_participant_devices(nativePtr, participantAddress != null ? participantAddress.nativePtr : IntPtr.Zero, ObjectArrayToBctbxList<Linphone.ParticipantDeviceIdentity>(deviceIdentities));
			
			
			GC.KeepAlive(participantAddress);
			
		}
	}
	/// <summary>
	/// Object defining parameters for a <see cref="Linphone.ChatRoom">
	/// Linphone.ChatRoom</see>. 
	/// <para>
	/// Can be created with <see cref="Linphone.Core.CreateDefaultChatRoomParams()">
	/// Linphone.Core.CreateDefaultChatRoomParams()</see>. You can use <see cref="Linphone.ChatRoomParams.IsValid()">
	/// Linphone.ChatRoomParams.IsValid()</see> to check if your configuration is valid
	/// or not.
	/// If the <see cref="Linphone.ChatRoom">Linphone.ChatRoom</see> backend is <see cref="Linphone.ChatRoomBackend.Basic">
	/// Linphone.ChatRoomBackend.Basic</see>, then no other parameter is required, but
	/// <see cref="Linphone.ChatMessage">Linphone.ChatMessage</see> sent and received
	/// won&apos;t benefit from all features a <see cref="Linphone.ChatRoomBackend.FlexisipChat">
	/// Linphone.ChatRoomBackend.FlexisipChat</see> can offer like conversation with
	/// multiple participants and a subject, end-to-end encryption, ephemeral messages,
	/// etc... but this type is the only one that can interoperate with other SIP
	/// clients or with non-flexisip SIP proxies. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ChatRoomParams : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomBackend linphone_chat_room_params_get_backend(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_set_backend(IntPtr thiz, int backend);

		/// <summary>
		/// Get the backend implementation of the chat room associated with the given
		/// parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.ChatRoomBackend">
		/// Linphone.ChatRoomBackend</see> </returns>
		public Linphone.ChatRoomBackend Backend
		{
			get
			{
				return linphone_chat_room_params_get_backend(nativePtr);
			}
			set
			{
				linphone_chat_room_params_set_backend(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomEncryptionBackend linphone_chat_room_params_get_encryption_backend(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_set_encryption_backend(IntPtr thiz, int backend);

		/// <summary>
		/// Get the encryption implementation of the chat room associated with the given
		/// parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.ChatRoomEncryptionBackend">
		/// Linphone.ChatRoomEncryptionBackend</see> </returns>
		public Linphone.ChatRoomEncryptionBackend EncryptionBackend
		{
			get
			{
				return linphone_chat_room_params_get_encryption_backend(nativePtr);
			}
			set
			{
				linphone_chat_room_params_set_encryption_backend(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_params_encryption_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_enable_encryption(IntPtr thiz, char encrypted);

		/// <summary>
		/// Get the encryption status of the chat room associated with the given
		/// parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if encryption is enabled, false otherwise </returns>
		public bool EncryptionEnabled
		{
			get
			{
				return linphone_chat_room_params_encryption_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_chat_room_params_enable_encryption(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_chat_room_params_get_ephemeral_lifetime(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_set_ephemeral_lifetime(IntPtr thiz, int time);

		/// <summary>
		/// Get lifetime (in seconds) for all new ephemeral messages in the chat room. 
		/// <para>
		/// After the message is read, it will be deleted after &quot;time&quot; seconds.
		/// </para>
		/// </summary>
		/// <remarks>See : linphone_chat_room_params_ephemeral_enabled() </remarks>
		/// <returns>the ephemeral lifetime (in seconds) </returns>
		public int EphemeralLifetime
		{
			get
			{
				return linphone_chat_room_params_get_ephemeral_lifetime(nativePtr);
			}
			set
			{
				linphone_chat_room_params_set_ephemeral_lifetime(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomEphemeralMode linphone_chat_room_params_get_ephemeral_mode(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_set_ephemeral_mode(IntPtr thiz, int mode);

		/// <summary>
		/// Get the ephemeral message mode of the chat room associated with the given
		/// parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the ephemeral message mode <see cref="Linphone.ChatRoomEphemeralMode">
		/// Linphone.ChatRoomEphemeralMode</see> </returns>
		public Linphone.ChatRoomEphemeralMode EphemeralMode
		{
			get
			{
				return linphone_chat_room_params_get_ephemeral_mode(nativePtr);
			}
			set
			{
				linphone_chat_room_params_set_ephemeral_mode(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_params_group_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_enable_group(IntPtr thiz, char group);

		/// <summary>
		/// Get the group chat status of the chat room associated with the given
		/// parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if group chat is enabled, false if one-to-one </returns>
		public bool GroupEnabled
		{
			get
			{
				return linphone_chat_room_params_group_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_chat_room_params_enable_group(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_params_is_valid(IntPtr thiz);

		/// <summary>
		/// Returns whether the given parameters are valid or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the given parameters are valid, false otherwise </returns>
		public bool IsValid
		{
			get
			{
				return linphone_chat_room_params_is_valid(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_chat_room_params_rtt_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_enable_rtt(IntPtr thiz, char rtt);

		/// <summary>
		/// Get the real time text status of the chat room associated with the given
		/// parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if real time text is enabled, false otherwise </returns>
		public bool RttEnabled
		{
			get
			{
				return linphone_chat_room_params_rtt_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_chat_room_params_enable_rtt(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_chat_room_params_get_subject(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_chat_room_params_set_subject(IntPtr thiz, string subject);

		/// <summary>
		/// Get the subject of the chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The subject.    </returns>
		public string Subject
		{
			get
			{
				IntPtr stringPtr = linphone_chat_room_params_get_subject(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_chat_room_params_set_subject(nativePtr, value);
				
			}
		}
	}
	/// <summary>
	/// A conference is the object that allow to make calls when there are 2 or more
	/// participants. 
	/// <para>
	/// To create (or find) a <see cref="Linphone.Conference">
	/// Linphone.Conference</see>, you first need a <see cref="Linphone.ConferenceParams">
	/// Linphone.ConferenceParams</see> object. <see cref="Linphone.Core.CreateConferenceWithParams()">
	/// Linphone.Core.CreateConferenceWithParams()</see> allows you to create a
	/// conference. A conference is uniquely identified by a conference address,
	/// meaning you can have more than one conference between two accounts. As of now,
	/// each <see cref="Linphone.Core">Linphone.Core</see> can host only 1 conference
	/// but it can be part of many conferences as a remote participant. To find a
	/// conference among those a core is part of, you can call <see cref="Linphone.Core.SearchConference()">
	/// Linphone.Core.SearchConference()</see>. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Conference : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_conference_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private ConferenceListener listener;

		public ConferenceListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_conference_cbs(linphone_factory_get());
					listener = fromNativePtr<ConferenceListener>(nativeListener, false, true);
					linphone_conference_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_conference_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_active_speaker_participant_device(IntPtr thiz);

		/// <summary>
		/// Get the currently active speaker participant device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.ParticipantDevice">
		/// Linphone.ParticipantDevice</see> currently displayed as active speaker.   
		/// </returns>
		public Linphone.ParticipantDevice ActiveSpeakerParticipantDevice
		{
			get
			{
				IntPtr ptr = linphone_conference_get_active_speaker_participant_device(nativePtr);
				Linphone.ParticipantDevice obj = fromNativePtr<Linphone.ParticipantDevice>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_call(IntPtr thiz);

		/// <summary>
		/// Gets the call that is controlling a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Call">Linphone.Call</see> controlling the
		/// conference or null if none or local conference    </returns>
		public Linphone.Call Call
		{
			get
			{
				IntPtr ptr = linphone_conference_get_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_conference_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_set_conference_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Get the conference address of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The conference address of the conference.    </returns>
		public Linphone.Address ConferenceAddress
		{
			get
			{
				IntPtr ptr = linphone_conference_get_conference_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				linphone_conference_set_conference_address(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_core(IntPtr thiz);

		/// <summary>
		/// Returns core for a <see cref="Linphone.Conference">Linphone.Conference</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>back pointer to <see cref="Linphone.Core">Linphone.Core</see> object. 
		///   Returns back pointer to <see cref="Linphone.Core">Linphone.Core</see> object.
		/// </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_conference_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_current_params(IntPtr thiz);

		/// <summary>
		/// Get current parameters of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.ConferenceParams">
		/// Linphone.ConferenceParams</see> .    </returns>
		public Linphone.ConferenceParams CurrentParams
		{
			get
			{
				IntPtr ptr = linphone_conference_get_current_params(nativePtr);
				Linphone.ConferenceParams obj = fromNativePtr<Linphone.ConferenceParams>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_get_duration(IntPtr thiz);

		/// <summary>
		/// Get the conference duration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>conference duration.    </returns>
		public int Duration
		{
			get
			{
				return linphone_conference_get_duration(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_ID(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_set_ID(IntPtr thiz, string conferenceId);

		/// <summary>
		/// Get the conference id as string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the conference id    </returns>
		/// deprecated : 10/07/2020 Use <see cref="Linphone.Conference.ConferenceAddress">
		/// Linphone.Conference.ConferenceAddress</see> instead. 
		public string Id
		{
			get
			{
				IntPtr stringPtr = linphone_conference_get_ID(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_conference_set_ID(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_input_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_set_input_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the current input device for this conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.AudioDevice">Linphone.AudioDevice</see> used
		/// by this conference as input or null if there is currently no soundcard
		/// configured (depending on the state of the conference)    </returns>
		public Linphone.AudioDevice InputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_conference_get_input_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_conference_set_input_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_conference_get_input_volume(IntPtr thiz);

		/// <summary>
		/// Retrieves the volume of a specific participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The volume of the participant expressed in dbm0. </returns>
		public float InputVolume
		{
			get
			{
				return linphone_conference_get_input_volume(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_is_in(IntPtr thiz);

		/// <summary>
		/// For a local conference, it returns whether the local participant is enabled For
		/// a remote conference, it return whether the remote participant has left the
		/// conference without bein removed from it. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the local participant is in a conference, false otherwise.
		/// </returns>
		public bool IsIn
		{
			get
			{
				return linphone_conference_is_in(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_is_recording(IntPtr thiz);

		/// <summary>
		/// Gets whether the conference is currently being recorded. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if conference is being recorded, false otherwise. </returns>
		public bool IsRecording
		{
			get
			{
				return linphone_conference_is_recording(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_me(IntPtr thiz);

		/// <summary>
		/// For a local audio video conference, this function returns the participant
		/// hosting the conference For a remote audio video conference, this function
		/// returns the local participant of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Participant">Linphone.Participant</see> .   
		/// </returns>
		public Linphone.Participant Me
		{
			get
			{
				IntPtr ptr = linphone_conference_get_me(nativePtr);
				Linphone.Participant obj = fromNativePtr<Linphone.Participant>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_get_microphone_muted(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_set_microphone_muted(IntPtr thiz, char muted);

		/// <summary>
		/// Retrieves the volume of a specific participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the microphone is muted, false otherwise </returns>
		public bool MicrophoneMuted
		{
			get
			{
				return linphone_conference_get_microphone_muted(nativePtr) != 0;
			}
			set
			{
				linphone_conference_set_microphone_muted(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_output_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_set_output_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the current output device for this conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.AudioDevice">Linphone.AudioDevice</see> used
		/// by this conference as output or null if there is currently no soundcard
		/// configured (depending on the state of the conference)    </returns>
		public Linphone.AudioDevice OutputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_conference_get_output_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_conference_set_output_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_get_participant_count(IntPtr thiz);

		/// <summary>
		/// Get number of participants without me. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the number of participants excluding me in a <see cref="Linphone.Conference">
		/// Linphone.Conference</see> </returns>
		public int ParticipantCount
		{
			get
			{
				return linphone_conference_get_participant_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_participant_device_list(IntPtr thiz);

		/// <summary>
		/// Get list of all participant devices of a conference including me if it is in. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The list of participant devices of the conference.         </returns>
		public IEnumerable<Linphone.ParticipantDevice> ParticipantDeviceList
		{
			get
			{
				return MarshalBctbxList<Linphone.ParticipantDevice>(linphone_conference_get_participant_device_list(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_participant_list(IntPtr thiz);

		/// <summary>
		/// Get list of all participants of a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : The returned list does not include me. </remarks> 
		/// <returns>The list of participants of the conference.         </returns>
		public IEnumerable<Linphone.Participant> ParticipantList
		{
			get
			{
				return MarshalBctbxList<Linphone.Participant>(linphone_conference_get_participant_list(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_participants(IntPtr thiz);

		/// <summary>
		/// Get URIs of all participants of one conference The returned bctbx_list_t
		/// contains URIs of all participants. 
		/// <para>
		/// That list must be freed after use and each URI must be unref with
		/// linphone_address_unref </para>
		/// </summary>
		/// <remarks>Warning : The returned list does not include me. </remarks> 
		/// <returns>The list of the participants&apos; address active in the conference.  
		///       </returns>
		/// deprecated : 10/07/2020 Use <see cref="Linphone.Conference.ParticipantList">
		/// Linphone.Conference.ParticipantList</see> instead. 
		public IEnumerable<Linphone.Address> Participants
		{
			get
			{
				return MarshalBctbxList<Linphone.Address>(linphone_conference_get_participants(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_conference_get_start_time(IntPtr thiz);

		/// <summary>
		/// Get the conference start time. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>conference start time.    </returns>
		public long StartTime
		{
			get
			{
				return linphone_conference_get_start_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConferenceState linphone_conference_get_state(IntPtr thiz);

		/// <summary>
		/// Get the current state of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.ConferenceState">
		/// Linphone.ConferenceState</see> of the conference. </returns>
		public Linphone.ConferenceState State
		{
			get
			{
				return linphone_conference_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_subject(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_set_subject(IntPtr thiz, string subject);

		/// <summary>
		/// Get the conference subject. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>conference subject.    </returns>
		public string Subject
		{
			get
			{
				IntPtr stringPtr = linphone_conference_get_subject(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_conference_set_subject(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_get_username(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_set_username(IntPtr thiz, string username);

		/// <summary>
		/// Get the conference username. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>conference subject.    </returns>
		public string Username
		{
			get
			{
				IntPtr stringPtr = linphone_conference_get_username(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_conference_set_username(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_add_participant(IntPtr thiz, IntPtr call);

		/// <summary>
		/// Join an existing call to the conference. 
		/// <para>
		/// If the conference is in the state LinphoneConferenceStateCreationPending, then
		/// the conference will start on the input and output audio devices used for the
		/// currently active call, if any 
		/// </para>
		/// </summary>
		/// <param name="call">a <see cref="Linphone.Call">Linphone.Call</see> that has to
		/// be added to the conference.    </param>
		/// <remarks>Warning : This function guarantees that the local endpoint is added to
		/// the conference only if one of calls added is in state StreamsRunning. It is
		/// highly recommended to call linphone_confererence_enter() to guarantee that the
		/// local endpoint is added to the conference. </remarks> 
		public void AddParticipant(Linphone.Call call)
		{
			int exception_result = linphone_conference_add_participant(nativePtr, call != null ? call.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddParticipant returned value" + exception_result);
			
			GC.KeepAlive(call);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_add_participant_2(IntPtr thiz, IntPtr uri);

		/// <summary>
		/// Join a participant to the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri">a <see cref="Linphone.Address">Linphone.Address</see> that
		/// has to be added to the conference.    </param>
		/// <remarks>Warning : This function guarantees that the local endpoint is added to
		/// the conference only if there is a call state StreamsRunning towards one of the
		/// addresses. It is highly recommended to call linphone_confererence_enter() to
		/// guarantee that the local endpoint is added to the conference. </remarks> 
		public void AddParticipant(Linphone.Address uri)
		{
			int exception_result = linphone_conference_add_participant_2(nativePtr, uri != null ? uri.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddParticipant returned value" + exception_result);
			
			GC.KeepAlive(uri);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_add_participants(IntPtr thiz, IntPtr calls);

		/// <summary>
		/// Add participants to the conference, by supplying a list of <see cref="Linphone.Call">
		/// Linphone.Call</see>. 
		/// <para>
		/// If the conference is in the state LinphoneConferenceStateCreationPending, then
		/// the conference will start on the input and output audio devices used for the
		/// currently active call, if any 
		/// </para>
		/// </summary>
		/// <param name="calls">A list of calls to add to the conference.      </param>
		public void AddParticipants(IEnumerable<Linphone.Call> calls)
		{
			int exception_result = linphone_conference_add_participants(nativePtr, ObjectArrayToBctbxList<Linphone.Call>(calls));
			if (exception_result != 0) throw new LinphoneException("AddParticipants returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_add_participants_2(IntPtr thiz, IntPtr addresses);

		/// <summary>
		/// Add participants to the conference, by supplying a list of <see cref="Linphone.Address">
		/// Linphone.Address</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="addresses">A list of calls to add to the conference.      </param>
		public void AddParticipants(IEnumerable<Linphone.Address> addresses)
		{
			int exception_result = linphone_conference_add_participants_2(nativePtr, ObjectArrayToBctbxList<Linphone.Address>(addresses));
			if (exception_result != 0) throw new LinphoneException("AddParticipants returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_enter(IntPtr thiz);

		/// <summary>
		/// For a local conference, the local participant joins the conference For a remote
		/// conference, the participant rejoins the conference after leaving it earlier on. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if succeeded. Negative number if failed </returns>
		public int Enter()
		{
			int returnVal = linphone_conference_enter(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_find_participant(IntPtr thiz, IntPtr uri);

		/// <summary>
		/// Find a participant from a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri">SIP URI of the participant to search.    </param>
		/// <returns>a pointer to the participant found or nullptr.    </returns>
		public Linphone.Participant FindParticipant(Linphone.Address uri)
		{
			IntPtr ptr = linphone_conference_find_participant(nativePtr, uri != null ? uri.nativePtr : IntPtr.Zero);
			Linphone.Participant returnVal = fromNativePtr<Linphone.Participant>(ptr, true);
			
			GC.KeepAlive(uri);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_get_participant_device_volume(IntPtr thiz, IntPtr device);

		/// <summary>
		/// Retrieves the volume of a specific participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="device">The Participant    </param>
		/// <returns>The volume of the participant expressed in dbm0. </returns>
		public int GetParticipantDeviceVolume(Linphone.ParticipantDevice device)
		{
			int returnVal = linphone_conference_get_participant_device_volume(nativePtr, device != null ? device.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(device);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_invite_participants(IntPtr thiz, IntPtr addresses, IntPtr parameters);

		/// <summary>
		/// Invite participants to the conference, by supplying a list of <see cref="Linphone.Address">
		/// Linphone.Address</see> If the conference is in the state
		/// LinphoneConferenceStateCreationPending, then the conference will start on the
		/// input and output audio devices used for the currently active call, if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="addresses">A list of SIP addresses to invite.      </param>
		/// <param name="parameters"><see cref="Linphone.CallParams">
		/// Linphone.CallParams</see> to use for inviting the participants.    </param>
		public void InviteParticipants(IEnumerable<Linphone.Address> addresses, Linphone.CallParams parameters)
		{
			int exception_result = linphone_conference_invite_participants(nativePtr, ObjectArrayToBctbxList<Linphone.Address>(addresses), parameters != null ? parameters.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("InviteParticipants returned value" + exception_result);
			
			GC.KeepAlive(parameters);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_is_me(IntPtr thiz, IntPtr uri);

		/// <summary>
		/// For a local audio video conference, this function compares the address provided
		/// as argument with that of participant hosting the conference For a remote audio
		/// video conference, this function compares the address provided as argument with
		/// that of the local participant of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri">A <see cref="Linphone.Address">Linphone.Address</see> object 
		///   </param>
		/// <returns>true if the participant is me, false otherwise. </returns>
		public bool IsMe(Linphone.Address uri)
		{
			bool returnVal = linphone_conference_is_me(nativePtr, uri != null ? uri.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			GC.KeepAlive(uri);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_leave(IntPtr thiz);

		/// <summary>
		/// For a local conference, the local participant leaves the conference For a
		/// remote conference, the participant leaves the conference after joining it
		/// earlier on. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if succeeded. Negative number if failed </returns>
		public int Leave()
		{
			int returnVal = linphone_conference_leave(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_remove_participant(IntPtr thiz, IntPtr uri);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri">URI of the participant to remove    </param>
		/// <remarks>Warning : The passed participant uri must be one of those returned by
		/// <see cref="Linphone.Conference.Participants">
		/// Linphone.Conference.Participants</see> </remarks> 
		/// <returns>0 if succeeded, -1 if failed </returns>
		/// deprecated : 10/07/2020 Use <see cref="Linphone.Conference.RemoveParticipant()">
		/// Linphone.Conference.RemoveParticipant()</see> instead. 
		public void RemoveParticipant(Linphone.Address uri)
		{
			int exception_result = linphone_conference_remove_participant(nativePtr, uri != null ? uri.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("RemoveParticipant returned value" + exception_result);
			
			GC.KeepAlive(uri);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_remove_participant_2(IntPtr thiz, IntPtr participant);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participant">participant to remove    </param>
		/// <remarks>Warning : The passed participant must be one of those returned by <see cref="Linphone.Conference.ParticipantList">
		/// Linphone.Conference.ParticipantList</see> </remarks> 
		/// <remarks>Warning : This method may destroy the conference if the only remaining
		/// participant had an existing call to the local participant before the conference
		/// was created </remarks> 
		/// <returns>0 if succeeded, -1 if failed </returns>
		public void RemoveParticipant(Linphone.Participant participant)
		{
			int exception_result = linphone_conference_remove_participant_2(nativePtr, participant != null ? participant.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("RemoveParticipant returned value" + exception_result);
			
			GC.KeepAlive(participant);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_remove_participant_3(IntPtr thiz, IntPtr call);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">call to remove    </param>
		/// <returns>0 if succeeded, -1 if failed </returns>
		/// deprecated : 10/07/2020 Use <see cref="Linphone.Conference.RemoveParticipant()">
		/// Linphone.Conference.RemoveParticipant()</see> instead. 
		public void RemoveParticipant(Linphone.Call call)
		{
			int exception_result = linphone_conference_remove_participant_3(nativePtr, call != null ? call.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("RemoveParticipant returned value" + exception_result);
			
			GC.KeepAlive(call);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_set_local_participant_stream_capability(IntPtr thiz, int direction, int type);

		/// <summary>
		/// Set stream capability on me device of a local conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="direction">the direction of stream of type stream_type </param>
		/// <param name="type">The <see cref="Linphone.StreamType">
		/// Linphone.StreamType</see> </param>
		public void SetLocalParticipantStreamCapability(Linphone.MediaDirection direction, Linphone.StreamType type)
		{
			linphone_conference_set_local_participant_stream_capability(nativePtr, (int)direction, (int)type);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_set_participant_admin_status(IntPtr thiz, IntPtr participant, char isAdmin);

		/// <summary>
		/// Change the admin status of a participant of a conference (you need to be an
		/// admin yourself to do this). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participant">The Participant for which to change the admin status 
		///   </param>
		/// <param name="isAdmin">A boolean value telling whether the participant should
		/// now be an admin or not </param>
		public void SetParticipantAdminStatus(Linphone.Participant participant, bool isAdmin)
		{
			linphone_conference_set_participant_admin_status(nativePtr, participant != null ? participant.nativePtr : IntPtr.Zero, isAdmin ? (char)1 : (char)0);
			
			
			GC.KeepAlive(participant);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_start_recording(IntPtr thiz, string path);

		/// <summary>
		/// Starts recording the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="path">Where to record the conference    </param>
		/// <returns>0 if succeeded. Negative number in case of failure. </returns>
		public int StartRecording(string path)
		{
			int returnVal = linphone_conference_start_recording(nativePtr, path);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_stop_recording(IntPtr thiz);

		/// <summary>
		/// Stops the conference recording. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if succeeded. Negative number in case of failure. </returns>
		public int StopRecording()
		{
			int returnVal = linphone_conference_stop_recording(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_terminate(IntPtr thiz);

		/// <summary>
		/// Terminates conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if the termination is successful, -1 otherwise. </returns>
		public int Terminate()
		{
			int returnVal = linphone_conference_terminate(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_conference_update_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Update parameters of the conference. 
		/// <para>
		/// This is typically used enable or disable the video stream in the conference. 
		/// </para>
		/// </summary>
		/// <param name="parameters">the new parameters to apply.    </param>
		public int UpdateParams(Linphone.ConferenceParams parameters)
		{
			int returnVal = linphone_conference_update_params(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(parameters);
			return returnVal;
		}
	}
	/// <summary>
	/// Object defining all information related to a conference. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ConferenceInfo : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_conference_info_get_date_time(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_info_set_date_time(IntPtr thiz, long datetime);

		/// <summary>
		/// Retrieve the date and time of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The date and time of the conference. </returns>
		public long DateTime
		{
			get
			{
				return linphone_conference_info_get_date_time(nativePtr);
			}
			set
			{
				linphone_conference_info_set_date_time(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_info_get_description(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_info_set_description(IntPtr thiz, string description);

		/// <summary>
		/// Retrieve the description of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The description of the conference.    </returns>
		public string Description
		{
			get
			{
				IntPtr stringPtr = linphone_conference_info_get_description(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_conference_info_set_description(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_conference_info_get_duration(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_info_set_duration(IntPtr thiz, uint duration);

		/// <summary>
		/// Retrieve the duration (in minutes) of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The duration of the conference. </returns>
		public uint Duration
		{
			get
			{
				return linphone_conference_info_get_duration(nativePtr);
			}
			set
			{
				linphone_conference_info_set_duration(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_info_get_icalendar_string(IntPtr thiz);

		/// <summary>
		/// Retrieve the conference as an Icalendar string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The conference as an Icalendar string. The returned char* must be
		/// freed by the caller.       </returns>
		public string IcalendarString
		{
			get
			{
				IntPtr stringPtr = linphone_conference_info_get_icalendar_string(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_info_get_organizer(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_info_set_organizer(IntPtr thiz, IntPtr organizer);

		/// <summary>
		/// Retrieve the organizer of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Address">Linphone.Address</see> of the
		/// conference&apos;s organizer.    </returns>
		public Linphone.Address Organizer
		{
			get
			{
				IntPtr ptr = linphone_conference_info_get_organizer(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				linphone_conference_info_set_organizer(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_info_get_participant_infos(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_info_set_participant_infos(IntPtr thiz, IntPtr participantInfos);

		/// <summary>
		/// Retrieve the list of participants as list of participant infos. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The list of participant informations.      </returns>
		public IEnumerable<Linphone.ParticipantInfo> ParticipantInfos
		{
			get
			{
				return MarshalBctbxList<Linphone.ParticipantInfo>(linphone_conference_info_get_participant_infos(nativePtr), true);
			}
			set
			{
				linphone_conference_info_set_participant_infos(nativePtr, ObjectArrayToBctbxList<Linphone.ParticipantInfo>(value));
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_info_get_participants(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_info_set_participants(IntPtr thiz, IntPtr participants);

		/// <summary>
		/// Retrieve the list of participants as list of addresses. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The list of participants.      </returns>
		/// deprecated : 24/08/2023 use linphone_conference_info_get_participant_infos
		/// instead 
		public IEnumerable<Linphone.Address> Participants
		{
			get
			{
				return MarshalBctbxList<Linphone.Address>(linphone_conference_info_get_participants(nativePtr), true);
			}
			set
			{
				linphone_conference_info_set_participants(nativePtr, ObjectArrayToBctbxList<Linphone.Address>(value));
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConferenceSecurityLevel linphone_conference_info_get_security_level(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_info_set_security_level(IntPtr thiz, int securityLevel);

		/// <summary>
		/// Retrieve the desired security level of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The desired security level of the conference. </returns>
		public Linphone.ConferenceSecurityLevel SecurityLevel
		{
			get
			{
				return linphone_conference_info_get_security_level(nativePtr);
			}
			set
			{
				linphone_conference_info_set_security_level(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConferenceInfoState linphone_conference_info_get_state(IntPtr thiz);

		/// <summary>
		/// Retrieve the state of the conference info. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.ConferenceInfoState">
		/// Linphone.ConferenceInfoState</see> object.    </returns>
		public Linphone.ConferenceInfoState State
		{
			get
			{
				return linphone_conference_info_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_info_get_subject(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_info_set_subject(IntPtr thiz, string subject);

		/// <summary>
		/// Retrieve the subject of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The subject of the conference.    </returns>
		public string Subject
		{
			get
			{
				IntPtr stringPtr = linphone_conference_info_get_subject(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_conference_info_set_subject(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_info_get_uri(IntPtr thiz);

		/// <summary>
		/// Retrieve the URI of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The URI of the conference (<see cref="Linphone.Address">
		/// Linphone.Address</see>).    </returns>
		public Linphone.Address Uri
		{
			get
			{
				IntPtr ptr = linphone_conference_info_get_uri(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_info_add_participant(IntPtr thiz, IntPtr participant);

		/// <summary>
		/// Add a participant to the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participant">The participant (<see cref="Linphone.Address">
		/// Linphone.Address</see>) to add.    </param>
		public void AddParticipant(Linphone.Address participant)
		{
			linphone_conference_info_add_participant(nativePtr, participant != null ? participant.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(participant);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_info_add_participant_2(IntPtr thiz, IntPtr participantInfo);

		/// <summary>
		/// Add a participant to the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participantInfo">The participant information (<see cref="Linphone.ParticipantInfo">
		/// Linphone.ParticipantInfo</see>) to add. This method can be called to set
		/// attributes such as the role to the organizer of the conference    </param>
		public void AddParticipant(Linphone.ParticipantInfo participantInfo)
		{
			linphone_conference_info_add_participant_2(nativePtr, participantInfo != null ? participantInfo.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(participantInfo);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_info_add_participant_infos(IntPtr thiz, IntPtr participantInfos);

		/// <summary>
		/// Add a list of participants. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participantInfos">The list of participant informations to add.    
		///  </param>
		public void AddParticipantInfos(IEnumerable<Linphone.ParticipantInfo> participantInfos)
		{
			linphone_conference_info_add_participant_infos(nativePtr, ObjectArrayToBctbxList<Linphone.ParticipantInfo>(participantInfos));
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_info_clone(IntPtr thiz);

		/// <summary>
		/// Clone an object <see cref="Linphone.ConferenceInfo">
		/// Linphone.ConferenceInfo</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the cloned <see cref="Linphone.ConferenceInfo">
		/// Linphone.ConferenceInfo</see> object.    </returns>
		public Linphone.ConferenceInfo Clone()
		{
			IntPtr ptr = linphone_conference_info_clone(nativePtr);
			Linphone.ConferenceInfo returnVal = fromNativePtr<Linphone.ConferenceInfo>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_info_find_participant(IntPtr thiz, IntPtr participant);

		/// <summary>
		/// Find a participant information in the conference information. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participant">The participant (<see cref="Linphone.Address">
		/// Linphone.Address</see>) to search.    </param>
		/// <returns>The participant information (<see cref="Linphone.ParticipantInfo">
		/// Linphone.ParticipantInfo</see>).    </returns>
		public Linphone.ParticipantInfo FindParticipant(Linphone.Address participant)
		{
			IntPtr ptr = linphone_conference_info_find_participant(nativePtr, participant != null ? participant.nativePtr : IntPtr.Zero);
			Linphone.ParticipantInfo returnVal = fromNativePtr<Linphone.ParticipantInfo>(ptr, true);
			
			GC.KeepAlive(participant);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_info_remove_participant(IntPtr thiz, IntPtr participant);

		/// <summary>
		/// Remove a participant from the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participant">The participant (<see cref="Linphone.Address">
		/// Linphone.Address</see>) to remove.    </param>
		public void RemoveParticipant(Linphone.Address participant)
		{
			linphone_conference_info_remove_participant(nativePtr, participant != null ? participant.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(participant);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_info_update_participant(IntPtr thiz, IntPtr participantInfo);

		/// <summary>
		/// Update the participant information in the conference informations. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participantInfo">The participant information (<see cref="Linphone.ParticipantInfo">
		/// Linphone.ParticipantInfo</see>) to update. This method can be called to change
		/// attributes such as the role to the organizer of the conference    </param>
		public void UpdateParticipant(Linphone.ParticipantInfo participantInfo)
		{
			linphone_conference_info_update_participant(nativePtr, participantInfo != null ? participantInfo.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(participantInfo);
			
		}
	}
	/// <summary>
	/// Object defining parameters for a <see cref="Linphone.Conference">
	/// Linphone.Conference</see>. 
	/// <para>
	/// Can be created by calling function <see cref="Linphone.Core.CreateConferenceParams()">
	/// Linphone.Core.CreateConferenceParams()</see>. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ConferenceParams : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_params_get_account(IntPtr thiz);

		/// <summary>
		/// Returns the account for the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a pointer to the account or null if it is not set.    </returns>
		public Linphone.Account Account
		{
			get
			{
				IntPtr ptr = linphone_conference_params_get_account(nativePtr);
				Linphone.Account obj = fromNativePtr<Linphone.Account>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_params_audio_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_enable_audio(IntPtr thiz, char enable);

		/// <summary>
		/// Check whether audio capabilities are enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the conference supports audio capabilities, false otherwise
		/// </returns>
		public bool AudioEnabled
		{
			get
			{
				return linphone_conference_params_audio_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_conference_params_enable_audio(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_params_chat_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_enable_chat(IntPtr thiz, char enable);

		/// <summary>
		/// Check whether chat capabilities are enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the conference supports chat capabilities, false otherwise
		/// </returns>
		public bool ChatEnabled
		{
			get
			{
				return linphone_conference_params_chat_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_conference_params_enable_chat(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_params_get_conference_factory_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_set_conference_factory_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Get the conference factory address of the conference that has been set. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the factory address conference description.    </returns>
		public Linphone.Address ConferenceFactoryAddress
		{
			get
			{
				IntPtr ptr = linphone_conference_params_get_conference_factory_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				linphone_conference_params_set_conference_factory_address(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_params_get_description(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_set_description(IntPtr thiz, string description);

		/// <summary>
		/// Get conference description. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the conference description.    </returns>
		public string Description
		{
			get
			{
				IntPtr stringPtr = linphone_conference_params_get_description(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_conference_params_set_description(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_conference_params_get_end_time(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_set_end_time(IntPtr thiz, long end);

		/// <summary>
		/// Get the end time of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>end time of a conference as time_t type or 0 for open end of a
		/// conference. For UNIX based systems it is the number of seconds since 00:00hours
		/// of the 1st of January 1970 </returns>
		public long EndTime
		{
			get
			{
				return linphone_conference_params_get_end_time(nativePtr);
			}
			set
			{
				linphone_conference_params_set_end_time(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_set_hidden(IntPtr thiz, char hidden);

		/// <summary>
		/// Set the conference as hidden. 
		/// <para>
		/// This means that the contact address will not have any conference releated
		/// attribute such as isfocus, the conference ID and the admin status. 
		/// </para>
		/// </summary>
		/// <param name="hidden">Boolean that states whether the conference is hidden or
		/// not </param>
		public bool Hidden
		{
			set
			{
				linphone_conference_params_set_hidden(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_params_is_audio_enabled(IntPtr thiz);

		/// <summary>
		/// Check whether audio capabilities are enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the conference supports audio capabilities, false otherwise
		/// </returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.ConferenceParams.AudioEnabled()">
		/// Linphone.ConferenceParams.AudioEnabled()</see> instead. 
		public bool IsAudioEnabled
		{
			get
			{
				return linphone_conference_params_is_audio_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_params_is_chat_enabled(IntPtr thiz);

		/// <summary>
		/// Check whether chat capabilities are enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the conference supports chat capabilities, false otherwise
		/// </returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.ConferenceParams.ChatEnabled()">
		/// Linphone.ConferenceParams.ChatEnabled()</see> instead. 
		public bool IsChatEnabled
		{
			get
			{
				return linphone_conference_params_is_chat_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_params_is_hidden(IntPtr thiz);

		/// <summary>
		/// Get the value of the hidden flag. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>whether the conference is hidden or not </returns>
		public bool IsHidden
		{
			get
			{
				return linphone_conference_params_is_hidden(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_params_is_local_participant_enabled(IntPtr thiz);

		/// <summary>
		/// Returns whether local participant has to enter the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if local participant is by default part of the conference, false
		/// otherwise </returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.ConferenceParams.LocalParticipantEnabled()">
		/// Linphone.ConferenceParams.LocalParticipantEnabled()</see> instead. 
		public bool IsLocalParticipantEnabled
		{
			get
			{
				return linphone_conference_params_is_local_participant_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_params_is_one_participant_conference_enabled(IntPtr thiz);

		/// <summary>
		/// Returns whether conference can have only one participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the conference can have only one participant, false otherwise
		/// </returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.ConferenceParams.OneParticipantConferenceEnabled()">
		/// Linphone.ConferenceParams.OneParticipantConferenceEnabled()</see> instead. 
		public bool IsOneParticipantConferenceEnabled
		{
			get
			{
				return linphone_conference_params_is_one_participant_conference_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_params_is_video_enabled(IntPtr thiz);

		/// <summary>
		/// Check whether video capabilities are enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the conference supports video capabilities, false otherwise
		/// </returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.ConferenceParams.VideoEnabled()">
		/// Linphone.ConferenceParams.VideoEnabled()</see> instead. 
		public bool IsVideoEnabled
		{
			get
			{
				return linphone_conference_params_is_video_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_params_local_participant_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_enable_local_participant(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether local participant has to enter the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if local participant is by default part of the conference, false
		/// otherwise </returns>
		public bool LocalParticipantEnabled
		{
			get
			{
				return linphone_conference_params_local_participant_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_conference_params_enable_local_participant(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_params_one_participant_conference_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_enable_one_participant_conference(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether conference can have only one participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the conference can have only one participant, false otherwise
		/// </returns>
		public bool OneParticipantConferenceEnabled
		{
			get
			{
				return linphone_conference_params_one_participant_conference_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_conference_params_enable_one_participant_conference(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConferenceParticipantListType linphone_conference_params_get_participant_list_type(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_set_participant_list_type(IntPtr thiz, int type);

		/// <summary>
		/// Get the participant list type. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>participant list type <see cref="Linphone.ConferenceParticipantListType">
		/// Linphone.ConferenceParticipantListType</see>. </returns>
		public Linphone.ConferenceParticipantListType ParticipantListType
		{
			get
			{
				return linphone_conference_params_get_participant_list_type(nativePtr);
			}
			set
			{
				linphone_conference_params_set_participant_list_type(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_params_get_proxy_cfg(IntPtr thiz);

		/// <summary>
		/// Returns the proxy configuration for the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a pointer to the proxy configuration or null if it is not set.   
		/// </returns>
		/// deprecated : 11/01/2022 Use <see cref="Linphone.ConferenceParams.Account">
		/// Linphone.ConferenceParams.Account</see> instead. 
		public Linphone.ProxyConfig ProxyCfg
		{
			get
			{
				IntPtr ptr = linphone_conference_params_get_proxy_cfg(nativePtr);
				Linphone.ProxyConfig obj = fromNativePtr<Linphone.ProxyConfig>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConferenceSecurityLevel linphone_conference_params_get_security_level(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_set_security_level(IntPtr thiz, int securityLevel);

		/// <summary>
		/// Retrieve the desired security level of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The desired security level of the conference. </returns>
		public Linphone.ConferenceSecurityLevel SecurityLevel
		{
			get
			{
				return linphone_conference_params_get_security_level(nativePtr);
			}
			set
			{
				linphone_conference_params_set_security_level(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_conference_params_get_start_time(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_set_start_time(IntPtr thiz, long start);

		/// <summary>
		/// Get the start time of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>start time of a conference as time_t type or 0 for immediate start of
		/// a conference. For UNIX based systems it is the number of seconds since
		/// 00:00hours of the 1st of January 1970 </returns>
		public long StartTime
		{
			get
			{
				return linphone_conference_params_get_start_time(nativePtr);
			}
			set
			{
				linphone_conference_params_set_start_time(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_params_get_subject(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_set_subject(IntPtr thiz, string subject);

		/// <summary>
		/// Get the conference subject. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>conference subject.    </returns>
		public string Subject
		{
			get
			{
				IntPtr stringPtr = linphone_conference_params_get_subject(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_conference_params_set_subject(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_conference_params_video_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_params_enable_video(IntPtr thiz, char enable);

		/// <summary>
		/// Check whether video capabilities are enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the conference supports video capabilities, false otherwise
		/// </returns>
		public bool VideoEnabled
		{
			get
			{
				return linphone_conference_params_video_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_conference_params_enable_video(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_params_clone(IntPtr thiz);

		/// <summary>
		/// Clone a <see cref="Linphone.ConferenceParams">Linphone.ConferenceParams</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>An allocated <see cref="Linphone.ConferenceParams">
		/// Linphone.ConferenceParams</see> with the same parameters than params   
		/// </returns>
		public Linphone.ConferenceParams Clone()
		{
			IntPtr ptr = linphone_conference_params_clone(nativePtr);
			Linphone.ConferenceParams returnVal = fromNativePtr<Linphone.ConferenceParams>(ptr, false);
			
						return returnVal;
		}
	}
	/// <summary>
	/// Object used to create remote conferences and send ICS to notify participants. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ConferenceScheduler : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_conference_scheduler_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_scheduler_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_scheduler_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private ConferenceSchedulerListener listener;

		public ConferenceSchedulerListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_conference_scheduler_cbs(linphone_factory_get());
					listener = fromNativePtr<ConferenceSchedulerListener>(nativeListener, false, true);
					linphone_conference_scheduler_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_conference_scheduler_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_scheduler_get_account(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_scheduler_set_account(IntPtr thiz, IntPtr account);

		/// <summary>
		/// Get the <see cref="Linphone.Account">Linphone.Account</see> that is used for
		/// the conference scheduler. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The selected <see cref="Linphone.Account">Linphone.Account</see> for
		/// the call, or null if none has been selected.    </returns>
		public Linphone.Account Account
		{
			get
			{
				IntPtr ptr = linphone_conference_scheduler_get_account(nativePtr);
				Linphone.Account obj = fromNativePtr<Linphone.Account>(ptr, true);
				return obj;
			}
			set
			{
				linphone_conference_scheduler_set_account(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_scheduler_get_core(IntPtr thiz);

		/// <summary>
		/// Gets the <see cref="Linphone.Core">Linphone.Core</see> from a <see cref="Linphone.ConferenceScheduler">
		/// Linphone.ConferenceScheduler</see> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Core">Linphone.Core</see> object.    </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_conference_scheduler_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_conference_scheduler_get_info(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_scheduler_set_info(IntPtr thiz, IntPtr conferenceInfo);

		/// <summary>
		/// Returns the <see cref="Linphone.ConferenceInfo">Linphone.ConferenceInfo</see>
		/// currently set in this scheduler. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the currently configured <see cref="Linphone.ConferenceInfo">
		/// Linphone.ConferenceInfo</see> or null if none is set.    </returns>
		public Linphone.ConferenceInfo Info
		{
			get
			{
				IntPtr ptr = linphone_conference_scheduler_get_info(nativePtr);
				Linphone.ConferenceInfo obj = fromNativePtr<Linphone.ConferenceInfo>(ptr, true);
				return obj;
			}
			set
			{
				linphone_conference_scheduler_set_info(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_scheduler_cancel_conference(IntPtr thiz, IntPtr conferenceInfo);

		/// <summary>
		/// Cancel the conference linked to the <see cref="Linphone.ConferenceInfo">
		/// Linphone.ConferenceInfo</see> provided as argument. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conferenceInfo">the <see cref="Linphone.ConferenceInfo">
		/// Linphone.ConferenceInfo</see> object to linked to the conference to cancel.   
		/// </param>
		public void CancelConference(Linphone.ConferenceInfo conferenceInfo)
		{
			linphone_conference_scheduler_cancel_conference(nativePtr, conferenceInfo != null ? conferenceInfo.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(conferenceInfo);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_conference_scheduler_send_invitations(IntPtr thiz, IntPtr chatRoomParams);

		/// <summary>
		/// Sends an invitation to the scheduled conference to each participant by chat,
		/// using given chat rooms params to use/create the chat room in which to send it. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoomParams">the <see cref="Linphone.ChatRoomParams">
		/// Linphone.ChatRoomParams</see> object to use to use/create the <see cref="Linphone.ChatRoom">
		/// Linphone.ChatRoom</see> that will be used to send the invite.    </param>
		public void SendInvitations(Linphone.ChatRoomParams chatRoomParams)
		{
			linphone_conference_scheduler_send_invitations(nativePtr, chatRoomParams != null ? chatRoomParams.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(chatRoomParams);
			
		}
	}
	/// <summary>
	/// This object is used to manipulate a configuration file. 
	/// <para>
	/// The format of the configuration file is a .ini like format:
	/// Various types can be used: strings and lists of strings, integers, floats,
	/// booleans (written as 0 or 1) and range of integers.
	/// Usually a <see cref="Linphone.Core">Linphone.Core</see> is initialized using
	/// two <see cref="Linphone.Config">Linphone.Config</see>, one default (where
	/// configuration changes through API calls will be saved) and one named
	/// &apos;factory&apos; which is read-only and overwrites any setting that may
	/// exists in the default one.
	/// It is also possible to use only one (either default or factory) or even none. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Config : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_new_from_buffer(string buffer);

		/// <summary>
		/// Instantiates a <see cref="Linphone.Config">Linphone.Config</see> object from a
		/// user provided buffer. 
		/// <para>
		/// The caller of this constructor owns a reference. linphone_config_unref must be
		/// called when this object is no longer needed.
		/// </para>
		/// </summary>
		/// <param name="buffer">the buffer from which the <see cref="Linphone.Config">
		/// Linphone.Config</see> will be retrieved. We expect the buffer to be
		/// null-terminated.    </param>
		/// <remarks>See : <see cref="Linphone.Config.NewWithFactory()">
		/// Linphone.Config.NewWithFactory()</see> </remarks>
		/// <remarks>See : linphone_config_new </remarks>
		/// <returns>a <see cref="Linphone.Config">Linphone.Config</see> object   
		/// </returns>
		public static Linphone.Config NewFromBuffer(string buffer)
		{
			IntPtr ptr = linphone_config_new_from_buffer(buffer);
			Linphone.Config returnVal = fromNativePtr<Linphone.Config>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_new_with_factory(string configFilename, string factoryConfigFilename);

		/// <summary>
		/// Instantiates a <see cref="Linphone.Config">Linphone.Config</see> object from a
		/// user config file and a factory config file. 
		/// <para>
		/// The caller of this constructor owns a reference. linphone_config_unref must be
		/// called when this object is no longer needed.
		/// </para>
		/// </summary>
		/// <param name="configFilename">the filename of the user config file to read to
		/// fill the instantiated <see cref="Linphone.Config">Linphone.Config</see>   
		/// </param>
		/// <param name="factoryConfigFilename">the filename of the factory config file to
		/// read to fill the instantiated <see cref="Linphone.Config">Linphone.Config</see>
		///    </param>
		/// <remarks>See : linphone_config_new </remarks>
		/// <returns>a <see cref="Linphone.Config">Linphone.Config</see> object   </returns>
		/// The user config file is read first to fill the <see cref="Linphone.Config">
		/// Linphone.Config</see> and then the factory config file is read. Therefore the
		/// configuration parameters defined in the user config file will be overwritten by
		/// the parameters defined in the factory config file. 
		public static Linphone.Config NewWithFactory(string configFilename, string factoryConfigFilename)
		{
			IntPtr ptr = linphone_config_new_with_factory(configFilename, factoryConfigFilename);
			Linphone.Config returnVal = fromNativePtr<Linphone.Config>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_is_readonly(IntPtr thiz);

		/// <summary>
		/// Indicates whether the LinphoneConfig object is readonly, in other words it has
		/// no file backend or file is opened without write permission. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a boolean. </returns>
		public bool IsReadonly
		{
			get
			{
				return linphone_config_is_readonly(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_get_sections_names_list(IntPtr thiz);

		/// <summary>
		/// Returns the list of sections&apos; names in the LinphoneConfig. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of strings.      </returns>
		public IEnumerable<string> SectionsNamesList
		{
			get
			{
				return MarshalStringArray(linphone_config_get_sections_names_list(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_clean_entry(IntPtr thiz, string section, string key);

		/// <summary>
		/// Removes entries for key,value in a section. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">the section for which to clean the key entry    </param>
		/// <param name="key">the key to clean    </param>
		public void CleanEntry(string section, string key)
		{
			linphone_config_clean_entry(nativePtr, section, key);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_clean_section(IntPtr thiz, string section);

		/// <summary>
		/// Removes every pair of key,value in a section and remove the section. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">the section to clean    </param>
		public void CleanSection(string section)
		{
			linphone_config_clean_section(nativePtr, section);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_dump(IntPtr thiz);

		/// <summary>
		/// Dumps the <see cref="Linphone.Config">Linphone.Config</see> as INI into a
		/// buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The buffer that contains the config dump       </returns>
		public string Dump()
		{
			IntPtr stringPtr = linphone_config_dump(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_dump_as_xml(IntPtr thiz);

		/// <summary>
		/// Dumps the <see cref="Linphone.Config">Linphone.Config</see> as XML into a
		/// buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The buffer that contains the XML dump       </returns>
		public string DumpAsXml()
		{
			IntPtr stringPtr = linphone_config_dump_as_xml(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_get_bool(IntPtr thiz, string section, string key, char defaultValue);

		/// <summary>
		/// Retrieves a configuration item as a boolean, given its section, key, and
		/// default value. 
		/// <para>
		/// The default boolean value is returned if the config item isn&apos;t found. 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// <returns>the found value or default_value if not found. </returns>
		public bool GetBool(string section, string key, bool defaultValue)
		{
			bool returnVal = linphone_config_get_bool(nativePtr, section, key, defaultValue ? (char)1 : (char)0) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_config_get_default_float(IntPtr thiz, string section, string key, float defaultValue);

		/// <summary>
		/// Retrieves a default configuration item as a float, given its section, key, and
		/// default value. 
		/// <para>
		/// The default float value is returned if the config item isn&apos;t found. 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the default value   
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// <returns>the found default value or default_value if not found. </returns>
		public float GetDefaultFloat(string section, string key, float defaultValue)
		{
			float returnVal = linphone_config_get_default_float(nativePtr, section, key, defaultValue);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_get_default_int(IntPtr thiz, string section, string key, int defaultValue);

		/// <summary>
		/// Retrieves a default configuration item as an integer, given its section, key,
		/// and default value. 
		/// <para>
		/// The default integer value is returned if the config item isn&apos;t found. 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the default value   
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// <returns>the found default value or default_value if not found. </returns>
		public int GetDefaultInt(string section, string key, int defaultValue)
		{
			int returnVal = linphone_config_get_default_int(nativePtr, section, key, defaultValue);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_get_default_int64(IntPtr thiz, string section, string key, int defaultValue);

		/// <summary>
		/// Retrieves a default configuration item as a 64 bit integer, given its section,
		/// key, and default value. 
		/// <para>
		/// The default integer value is returned if the config item isn&apos;t found. 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the default value   
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// <returns>the found default value or default_value if not found. </returns>
		public int GetDefaultInt64(string section, string key, int defaultValue)
		{
			int returnVal = linphone_config_get_default_int64(nativePtr, section, key, defaultValue);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_get_default_string(IntPtr thiz, string section, string key, string defaultValue);

		/// <summary>
		/// Retrieves a default configuration item as a string, given its section, key, and
		/// default value. 
		/// <para>
		/// The default value string is returned if the config item isn&apos;t found. 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the default value   
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// <returns>the found default value or default_value if not found. </returns>
		public string GetDefaultString(string section, string key, string defaultValue)
		{
			IntPtr stringPtr = linphone_config_get_default_string(nativePtr, section, key, defaultValue);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_config_get_float(IntPtr thiz, string section, string key, float defaultValue);

		/// <summary>
		/// Retrieves a configuration item as a float, given its section, key, and default
		/// value. 
		/// <para>
		/// The default float value is returned if the config item isn&apos;t found. 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// <returns>the found value or default_value if not found. </returns>
		public float GetFloat(string section, string key, float defaultValue)
		{
			float returnVal = linphone_config_get_float(nativePtr, section, key, defaultValue);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_get_int(IntPtr thiz, string section, string key, int defaultValue);

		/// <summary>
		/// Retrieves a configuration item as an integer, given its section, key, and
		/// default value. 
		/// <para>
		/// The default integer value is returned if the config item isn&apos;t found. 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// <returns>the found value or default_value if not found. </returns>
		public int GetInt(string section, string key, int defaultValue)
		{
			int returnVal = linphone_config_get_int(nativePtr, section, key, defaultValue);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_get_int64(IntPtr thiz, string section, string key, int defaultValue);

		/// <summary>
		/// Retrieves a configuration item as a 64 bit integer, given its section, key, and
		/// default value. 
		/// <para>
		/// The default integer value is returned if the config item isn&apos;t found. 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="defaultValue">The default value to return if not found </param>
		/// <returns>the found value or default_value if not found. </returns>
		public int GetInt64(string section, string key, int defaultValue)
		{
			int returnVal = linphone_config_get_int64(nativePtr, section, key, defaultValue);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_get_keys_names_list(IntPtr thiz, string section);

		/// <summary>
		/// Returns the list of keys&apos; names for a section in the LinphoneConfig. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section name    </param>
		/// <returns>A list of strings.      </returns>
		public IEnumerable<string> GetKeysNamesList(string section)
		{
			IEnumerable<string> returnVal = MarshalStringArray(linphone_config_get_keys_names_list(nativePtr, section));
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_get_overwrite_flag_for_entry(IntPtr thiz, string section, string key);

		/// <summary>
		/// Retrieves the overwrite flag for a config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the overwrite flag   
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve the overwrite
		/// flag from.    </param>
		/// <returns>true if overwrite flag is set, false otherwise. </returns>
		public bool GetOverwriteFlagForEntry(string section, string key)
		{
			bool returnVal = linphone_config_get_overwrite_flag_for_entry(nativePtr, section, key) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_get_overwrite_flag_for_section(IntPtr thiz, string section);

		/// <summary>
		/// Retrieves the overwrite flag for a config section. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the overwrite flag   
		/// </param>
		/// <returns>true if overwrite flag is set, false otherwise. </returns>
		public bool GetOverwriteFlagForSection(string section)
		{
			bool returnVal = linphone_config_get_overwrite_flag_for_section(nativePtr, section) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_get_range(IntPtr thiz, string section, string key, int min, int max, int defaultMin, int defaultMax);

		/// <summary>
		/// Retrieves a configuration item as a range, given its section, key, and default
		/// min and max values. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="min">The min value found or default_min    </param>
		/// <param name="max">The max value found or default_max    </param>
		/// <param name="defaultMin">the default min value to return if not found </param>
		/// <param name="defaultMax">the default max value to return if not found. </param>
		/// <returns>true if the value is successfully parsed as a range, false otherwise.
		/// If false is returned, min and max are filled respectively with default_min and
		/// default_max values. </returns>
		public bool GetRange(string section, string key, int min, int max, int defaultMin, int defaultMax)
		{
			bool returnVal = linphone_config_get_range(nativePtr, section, key, min, max, defaultMin, defaultMax) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_get_section_param_string(IntPtr thiz, string section, string key, string defaultValue);

		/// <summary>
		/// Retrieves a section parameter item as a string, given its section and key. 
		/// <para>
		/// The default value string is returned if the config item isn&apos;t found. 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the default value   
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="defaultValue">The default value to return if not found.    </param>
		/// <returns>the found default value or default_value if not found.    </returns>
		public string GetSectionParamString(string section, string key, string defaultValue)
		{
			IntPtr stringPtr = linphone_config_get_section_param_string(nativePtr, section, key, defaultValue);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_get_skip_flag_for_entry(IntPtr thiz, string section, string key);

		/// <summary>
		/// Retrieves the skip flag for a config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the skip flag   
		/// </param>
		/// <param name="key">The name of the configuration item to retrieve the skip flag
		/// from </param>
		/// <returns>true if skip flag is set, false otherwise. </returns>
		public bool GetSkipFlagForEntry(string section, string key)
		{
			bool returnVal = linphone_config_get_skip_flag_for_entry(nativePtr, section, key) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_get_skip_flag_for_section(IntPtr thiz, string section);

		/// <summary>
		/// Retrieves the skip flag for a config section. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve the skip flag   
		/// </param>
		/// <returns>true if skip flag is set, false otherwise. </returns>
		public bool GetSkipFlagForSection(string section)
		{
			bool returnVal = linphone_config_get_skip_flag_for_section(nativePtr, section) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_get_string(IntPtr thiz, string section, string key, string defaultString);

		/// <summary>
		/// Retrieves a configuration item as a string, given its section, key, and default
		/// value. 
		/// <para>
		/// The default value string is returned if the config item isn&apos;t found. 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="defaultString">The default value to return if not found.   
		/// </param>
		/// <returns>the found value or the default one if not found.    </returns>
		public string GetString(string section, string key, string defaultString)
		{
			IntPtr stringPtr = linphone_config_get_string(nativePtr, section, key, defaultString);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_get_string_list(IntPtr thiz, string section, string key, IntPtr defaultList);

		/// <summary>
		/// Retrieves a configuration item as a list of strings, given its section, key,
		/// and default value. 
		/// <para>
		/// The default value is returned if the config item is not found. 
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="defaultList">The list to return when the key doesn&apos;t exist.  
		///    </param>
		/// <returns>A list of strings.      </returns>
		public IEnumerable<string> GetStringList(string section, string key, IEnumerable<string> defaultList)
		{
			IEnumerable<string> returnVal = MarshalStringArray(linphone_config_get_string_list(nativePtr, section, key, StringArrayToBctbxList(defaultList)));
			CleanStringArrayPtrs();
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_has_entry(IntPtr thiz, string section, string key);

		/// <summary>
		/// Returns if a given section with a given key is present in the configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">to check if the given entry exists    </param>
		/// <param name="key">to check if it exists    </param>
		/// <returns>1 if it exists, 0 otherwise </returns>
		public int HasEntry(string section, string key)
		{
			int returnVal = linphone_config_has_entry(nativePtr, section, key);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_has_section(IntPtr thiz, string section);

		/// <summary>
		/// Returns if a given section is present in the configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">the section to check if exists    </param>
		/// <returns>1 if it exists, 0 otherwise </returns>
		public int HasSection(string section)
		{
			int returnVal = linphone_config_has_section(nativePtr, section);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_config_load_from_xml_file(IntPtr thiz, string filename);

		/// <summary>
		/// Reads a xml config file and fill the <see cref="Linphone.Config">
		/// Linphone.Config</see> with the read config dynamic values. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filename">The filename of the config file to read to fill the <see cref="Linphone.Config">
		/// Linphone.Config</see>    </param>
		public string LoadFromXmlFile(string filename)
		{
			IntPtr stringPtr = linphone_config_load_from_xml_file(nativePtr, filename);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_load_from_xml_string(IntPtr thiz, string buffer);

		/// <summary>
		/// Reads a xml config string and fill the <see cref="Linphone.Config">
		/// Linphone.Config</see> with the read config dynamic values. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="buffer">The string of the config file to fill the <see cref="Linphone.Config">
		/// Linphone.Config</see>    </param>
		/// <returns>0 in case of success </returns>
		public void LoadFromXmlString(string buffer)
		{
			int exception_result = linphone_config_load_from_xml_string(nativePtr, buffer);
			if (exception_result != 0) throw new LinphoneException("LoadFromXmlString returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_read_file(IntPtr thiz, string filename);

		/// <summary>
		/// Reads a user config file and fill the <see cref="Linphone.Config">
		/// Linphone.Config</see> with the read config values. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filename">The filename of the config file to read to fill the <see cref="Linphone.Config">
		/// Linphone.Config</see>    </param>
		public void ReadFile(string filename)
		{
			int exception_result = linphone_config_read_file(nativePtr, filename);
			if (exception_result != 0) throw new LinphoneException("ReadFile returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_config_relative_file_exists(IntPtr thiz, string filename);

		/// <summary>
		/// Check if given file name exists relatively to the current location. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filename">The file name to check if exists    </param>
		/// <returns>true if file exists relative to the to the current location </returns>
		public bool RelativeFileExists(string filename)
		{
			bool returnVal = linphone_config_relative_file_exists(nativePtr, filename) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_reload(IntPtr thiz);

		/// <summary>
		/// Reload the config from the file. 
		/// <para>
		/// </para>
		/// </summary>
		public void Reload()
		{
			linphone_config_reload(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_bool(IntPtr thiz, string section, string key, char val);

		/// <summary>
		/// Sets a boolean config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="val">the value to set </param>
		public void SetBool(string section, string key, bool val)
		{
			linphone_config_set_bool(nativePtr, section, key, val ? (char)1 : (char)0);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_float(IntPtr thiz, string section, string key, float val);

		/// <summary>
		/// Sets a float config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="val">the value to set </param>
		public void SetFloat(string section, string key, float val)
		{
			linphone_config_set_float(nativePtr, section, key, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_int(IntPtr thiz, string section, string key, int val);

		/// <summary>
		/// Sets an integer config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="val">the value to set </param>
		public void SetInt(string section, string key, int val)
		{
			linphone_config_set_int(nativePtr, section, key, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_int64(IntPtr thiz, string section, string key, int val);

		/// <summary>
		/// Sets a 64 bits integer config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="val">the value to set </param>
		public void SetInt64(string section, string key, int val)
		{
			linphone_config_set_int64(nativePtr, section, key, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_int_hex(IntPtr thiz, string section, string key, int val);

		/// <summary>
		/// Sets an integer config item, but store it as hexadecimal. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="val">the value to set </param>
		public void SetIntHex(string section, string key, int val)
		{
			linphone_config_set_int_hex(nativePtr, section, key, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_overwrite_flag_for_entry(IntPtr thiz, string section, string key, char val);

		/// <summary>
		/// Sets the overwrite flag for a config item (used when dumping config as xml) 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to set the overwrite flag   
		/// </param>
		/// <param name="key">The name of the configuration item to set the overwrite flag
		/// from    </param>
		/// <param name="val">The overwrite flag value to set </param>
		public void SetOverwriteFlagForEntry(string section, string key, bool val)
		{
			linphone_config_set_overwrite_flag_for_entry(nativePtr, section, key, val ? (char)1 : (char)0);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_overwrite_flag_for_section(IntPtr thiz, string section, char val);

		/// <summary>
		/// Sets the overwrite flag for a config section (used when dumping config as xml) 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to set the overwrite flag   
		/// </param>
		/// <param name="val">The overwrite flag value to set </param>
		public void SetOverwriteFlagForSection(string section, bool val)
		{
			linphone_config_set_overwrite_flag_for_section(nativePtr, section, val ? (char)1 : (char)0);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_range(IntPtr thiz, string section, string key, int minValue, int maxValue);

		/// <summary>
		/// Sets a range config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="minValue">the min value to set </param>
		/// <param name="maxValue">the max value to set </param>
		public void SetRange(string section, string key, int minValue, int maxValue)
		{
			linphone_config_set_range(nativePtr, section, key, minValue, maxValue);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_skip_flag_for_entry(IntPtr thiz, string section, string key, char val);

		/// <summary>
		/// Sets the skip flag for a config item (used when dumping config as xml) 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to set the skip flag    </param>
		/// <param name="key">The name of the configuration item to set the skip flag from 
		///   </param>
		/// <param name="val">The skip flag value to set </param>
		public void SetSkipFlagForEntry(string section, string key, bool val)
		{
			linphone_config_set_skip_flag_for_entry(nativePtr, section, key, val ? (char)1 : (char)0);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_skip_flag_for_section(IntPtr thiz, string section, char val);

		/// <summary>
		/// Sets the skip flag for a config section (used when dumping config as xml) 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to set the skip flag    </param>
		/// <param name="val">The skip flag value to set </param>
		public void SetSkipFlagForSection(string section, bool val)
		{
			linphone_config_set_skip_flag_for_section(nativePtr, section, val ? (char)1 : (char)0);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_string(IntPtr thiz, string section, string key, string val);

		/// <summary>
		/// Sets a string config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The section from which to retrieve a configuration item  
		///  </param>
		/// <param name="key">The name of the configuration item to retrieve    </param>
		/// <param name="val">The value to set    </param>
		public void SetString(string section, string key, string val)
		{
			linphone_config_set_string(nativePtr, section, key, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_set_string_list(IntPtr thiz, string section, string key, IntPtr val);

		/// <summary>
		/// Sets a string list config item. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="section">The name of the section to put the configuration item
		/// into    </param>
		/// <param name="key">The name of the configuration item to set    </param>
		/// <param name="val">The value to set.      </param>
		public void SetStringList(string section, string key, IEnumerable<string> val)
		{
			linphone_config_set_string_list(nativePtr, section, key, StringArrayToBctbxList(val));
			
			CleanStringArrayPtrs();
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_config_sync(IntPtr thiz);

		/// <summary>
		/// Writes the config file to disk. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, -1 otherwise </returns>
		public void Sync()
		{
			int exception_result = linphone_config_sync(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Sync returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_config_write_relative_file(IntPtr thiz, string filename, string data);

		/// <summary>
		/// Write a string in a file placed relatively with the Linphone configuration
		/// file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filename">Name of the file where to write data. The name is
		/// relative to the place of the config file    </param>
		/// <param name="data">String to write    </param>
		public void WriteRelativeFile(string filename, string data)
		{
			linphone_config_write_relative_file(nativePtr, filename, data);
			
			
						
		}
	}
	/// <summary>
	/// This object holds data that can be embedded in a signaling message. 
	/// <para>
	/// Use <see cref="Linphone.Core.CreateContent()">
	/// Linphone.Core.CreateContent()</see> to create it, and then you should set at
	/// least it&apos;s type and subtype and fill the buffer with your data.
	/// A <see cref="Linphone.Content">Linphone.Content</see> can be multipart (contain
	/// other contents), have file information (name, path, size), be encrypted, have
	/// custom headers, etc...
	/// It is mainly used to send information through a <see cref="Linphone.ChatMessage">
	/// Linphone.ChatMessage</see>. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Content : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_content_get_buffer(IntPtr thiz);

		/// <summary>
		/// Get the content data buffer, usually a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The content data buffer.    </returns>
		public uint Buffer
		{
			get
			{
				return linphone_content_get_buffer(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_disposition(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_disposition(IntPtr thiz, string disposition);

		/// <summary>
		/// Get the disposition of the Content, for example &quot;recipient-list&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The disposition of the Content.    </returns>
		public string Disposition
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_disposition(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_disposition(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_encoding(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_encoding(IntPtr thiz, string encoding);

		/// <summary>
		/// Get the encoding of the data buffer, for example &quot;gzip&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The encoding of the data buffer.    </returns>
		public string Encoding
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_encoding(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_encoding(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_content_get_file_duration(IntPtr thiz);

		/// <summary>
		/// Gets the file duration in seconds, if information is available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The duration of the file in seconds or -1 if information isn&apos;t
		/// available. </returns>
		public int FileDuration
		{
			get
			{
				return linphone_content_get_file_duration(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_file_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_file_path(IntPtr thiz, string filePath);

		/// <summary>
		/// Get the file transfer filepath set for this content (replace
		/// linphone_chat_message_get_file_transfer_filepath). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The file path set for this content if it has been set, null otherwise.
		///    </returns>
		public string FilePath
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_file_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_file_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_content_get_file_size(IntPtr thiz);

		/// <summary>
		/// Get the file size if content is either a FileContent or a FileTransferContent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The represented file size. </returns>
		public long FileSize
		{
			get
			{
				return linphone_content_get_file_size(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_content_is_file(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this content contains a file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if this content contains a file, false otherwise. </returns>
		public bool IsFile
		{
			get
			{
				return linphone_content_is_file(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_content_is_file_encrypted(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this content contains an encrypted file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>True is this content contains a file and this file is encrypted, false
		/// otherwise. </returns>
		public bool IsFileEncrypted
		{
			get
			{
				return linphone_content_is_file_encrypted(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_content_is_file_transfer(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this content is a file transfer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if this content is a file transfer, false otherwise. </returns>
		public bool IsFileTransfer
		{
			get
			{
				return linphone_content_is_file_transfer(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_content_is_icalendar(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this content contains an icalendar by checking it&apos;s
		/// content type. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if this content type is
		/// &apos;text/calendar;conference-event=yes&apos;, false otherwise. </returns>
		public bool IsIcalendar
		{
			get
			{
				return linphone_content_is_icalendar(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_content_is_multipart(IntPtr thiz);

		/// <summary>
		/// Tell whether a content is a multipart content. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether the content is multipart or not.
		/// </returns>
		public bool IsMultipart
		{
			get
			{
				return linphone_content_is_multipart(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_content_is_text(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this content contains text. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if this content contains plain text, false otherwise. </returns>
		public bool IsText
		{
			get
			{
				return linphone_content_is_text(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_content_is_voice_recording(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this content contains a voice recording by checking
		/// it&apos;s content type. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if this content type is
		/// &apos;audio/wav;voice-recording=yes&apos;, false otherwise. </returns>
		public bool IsVoiceRecording
		{
			get
			{
				return linphone_content_is_voice_recording(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_key(IntPtr thiz);

		/// <summary>
		/// Get the key associated with a RCS file transfer message if encrypted. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The key to encrypt/decrypt the file associated to this content.   
		/// </returns>
		public string Key
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_key(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_content_get_key_size(IntPtr thiz);

		/// <summary>
		/// Get the size of key associated with a RCS file transfer message if encrypted. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The key size in bytes </returns>
		public long KeySize
		{
			get
			{
				return linphone_content_get_key_size(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_name(IntPtr thiz, string name);

		/// <summary>
		/// Get the name associated with a RCS file transfer message. 
		/// <para>
		/// It is used to store the original filename of the file to be downloaded from
		/// server. 
		/// </para>
		/// </summary>
		/// <returns>The name of the content.    </returns>
		public string Name
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_parts(IntPtr thiz);

		/// <summary>
		/// Get all the parts from a multipart content. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A   object holding the part if found, null otherwise.       </returns>
		public IEnumerable<Linphone.Content> Parts
		{
			get
			{
				return MarshalBctbxList<Linphone.Content>(linphone_content_get_parts(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_plain_file_path(IntPtr thiz);

		/// <summary>
		/// Generates a temporary plain copy of the file and returns its paths The caller
		/// is responsible to then delete this temporary copy and the returned string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The file path set for this content if it has been set, null otherwise.
		///    </returns>
		/// deprecated : 2022-01-07. Use <see cref="Linphone.Content.ExportPlainFile()">
		/// Linphone.Content.ExportPlainFile()</see> instead. 
		public string PlainFilePath
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_plain_file_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_content_get_size(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_size(IntPtr thiz, long size);

		/// <summary>
		/// Get the content data buffer size, excluding null character despite null
		/// character is always set for convenience. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The content data buffer size. </returns>
		public long Size
		{
			get
			{
				return linphone_content_get_size(nativePtr);
			}
			set
			{
				linphone_content_set_size(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_string_buffer(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_string_buffer(IntPtr thiz, string buffer);

		/// <summary>
		/// Get the string content data buffer. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The string content data buffer.    </returns>
		/// deprecated : 2020-07-01. Use <see cref="Linphone.Content.Utf8Text">
		/// Linphone.Content.Utf8Text</see> instead. 
		public string StringBuffer
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_string_buffer(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_string_buffer(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_subtype(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_subtype(IntPtr thiz, string subtype);

		/// <summary>
		/// Get the mime subtype of the content data. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The mime subtype of the content data, for example &quot;html&quot;.   
		/// </returns>
		public string Subtype
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_subtype(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_subtype(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_type(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_type(IntPtr thiz, string type);

		/// <summary>
		/// Get the mime type of the content data. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The mime type of the content data, for example
		/// &quot;application&quot;.    </returns>
		public string Type
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_type(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_type(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_utf8_text(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_utf8_text(IntPtr thiz, string buffer);

		/// <summary>
		/// Get the string content data buffer. 
		/// <para>
		/// Introduced in 01/07/2020 
		/// </para>
		/// </summary>
		/// <returns>The string content data buffer in UTF8.    </returns>
		public string Utf8Text
		{
			get
			{
				IntPtr stringPtr = linphone_content_get_utf8_text(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_content_set_utf8_text(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_add_content_type_parameter(IntPtr thiz, string name, string val);

		/// <summary>
		/// Adds a parameter to the ContentType header. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the name of the parameter to add.    </param>
		/// <param name="val">the value of the parameter to add.    </param>
		public void AddContentTypeParameter(string name, string val)
		{
			linphone_content_add_content_type_parameter(nativePtr, name, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_add_custom_header(IntPtr thiz, string headerName, string headerValue);

		/// <summary>
		/// Adds a custom header in a content. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">The name of the header to add.    </param>
		/// <param name="headerValue">The value of the header to add.    </param>
		public void AddCustomHeader(string headerName, string headerValue)
		{
			linphone_content_add_custom_header(nativePtr, headerName, headerValue);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_export_plain_file(IntPtr thiz);

		/// <summary>
		/// Generates a temporary plain copy of the file and returns its paths The caller
		/// is responsible to then delete this temporary copy and the returned string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The file path set for this content if it has been set, null otherwise.
		///    </returns>
		public string ExportPlainFile()
		{
			IntPtr stringPtr = linphone_content_export_plain_file(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_find_part_by_header(IntPtr thiz, string headerName, string headerValue);

		/// <summary>
		/// Find a part from a multipart content looking for a part header with a specified
		/// value. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">The name of the header to look for.    </param>
		/// <param name="headerValue">The value of the header to look for.    </param>
		/// <returns>A <see cref="Linphone.Content">Linphone.Content</see> object object
		/// the part if found, null otherwise.    </returns>
		public Linphone.Content FindPartByHeader(string headerName, string headerValue)
		{
			IntPtr ptr = linphone_content_find_part_by_header(nativePtr, headerName, headerValue);
			Linphone.Content returnVal = fromNativePtr<Linphone.Content>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_custom_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Get a custom header value of a content. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">The name of the header to get the value from.   
		/// </param>
		/// <returns>The value of the header if found, null otherwise.    </returns>
		public string GetCustomHeader(string headerName)
		{
			IntPtr stringPtr = linphone_content_get_custom_header(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_content_get_part(IntPtr thiz, int index);

		/// <summary>
		/// Get a part from a multipart content according to its index. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the part to get. </param>
		/// <returns>A <see cref="Linphone.Content">Linphone.Content</see> object holding
		/// the part if found, null otherwise.    </returns>
		public Linphone.Content GetPart(int index)
		{
			IntPtr ptr = linphone_content_get_part(nativePtr, index);
			Linphone.Content returnVal = fromNativePtr<Linphone.Content>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_buffer(IntPtr thiz, uint buffer, long size);

		/// <summary>
		/// Set the content data buffer, usually a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="buffer">The content data buffer.    </param>
		/// <param name="size">The size of the content data buffer. </param>
		public void SetBuffer(uint buffer, long size)
		{
			linphone_content_set_buffer(nativePtr, buffer, size);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_content_set_key(IntPtr thiz, string key, long keyLength);

		/// <summary>
		/// Set the key associated with a RCS file transfer message if encrypted. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key to be used to encrypt/decrypt file associated to this
		/// content.    </param>
		/// <param name="keyLength">The lengh of the key. </param>
		public void SetKey(string key, long keyLength)
		{
			linphone_content_set_key(nativePtr, key, keyLength);
			
			
						
		}
	}
	/// <summary>
	/// Main object to instanciate and on which to keep a reference. 
	/// <para>
	/// This object is the first object to instanciante, and will allow you to perform
	/// all kind of tasks. To create it, use either <see cref="Linphone.Factory.CreateCore()">
	/// Linphone.Factory.CreateCore()</see> or <see cref="Linphone.Factory.CreateCoreWithConfig()">
	/// Linphone.Factory.CreateCoreWithConfig()</see>, see <see cref="Linphone.Config">
	/// Linphone.Config</see> for more information about factory and default config. On
	/// some platforms like Android or iOS you will need to give it the Context of your
	/// application.
	/// Once the <see cref="Linphone.Core">Linphone.Core</see> is in state <see cref="Linphone.GlobalState.Ready">
	/// Linphone.GlobalState.Ready</see>, use <see cref="Linphone.Core.Start()">
	/// Linphone.Core.Start()</see>. It will then go to state <see cref="Linphone.GlobalState.On">
	/// Linphone.GlobalState.On</see> and from that you can start using it for calls
	/// and chat messages. It is recommended to add a <see cref="Linphone.CoreListener">
	/// Linphone.CoreListener</see> listener using <see cref="Linphone.Core.AddListener()">
	/// Linphone.Core.AddListener()</see> to monitor different events.
	/// To be able to receive events from the network, you must schedule a call <see cref="Linphone.Core.Iterate()">
	/// Linphone.Core.Iterate()</see> often, like every 20ms. On Android &amp; iOS <see cref="Linphone.Core.IsAutoIterateEnabled()">
	/// Linphone.Core.IsAutoIterateEnabled()</see> is enabled by default so you
	/// don&apos;t have to worry about that unless you disable it using <see cref="Linphone.Core.EnableAutoIterate()">
	/// Linphone.Core.EnableAutoIterate()</see> or by setting in the [misc] section of
	/// your configuration auto_iterate=0. </para>
	/// </summary>
	/// <remarks>Warning : Our API isn&apos;t thread-safe but also isn&apos;t blocking,
	/// so it is strongly recommend to always call our methods from the main
	/// thread.</remarks> 
	/// Once you don&apos;t need it anymore, call <see cref="Linphone.Core.Stop()">
	/// Linphone.Core.Stop()</see> and release the reference on it so it can gracefully
	/// shutdown. 
	[StructLayout(LayoutKind.Sequential)]
	public class Core : LinphoneObject
	{
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_ms_factory(IntPtr thiz);

		public MediastreamerFactory MsFactory {
			get
			{
				IntPtr ptr = linphone_core_get_ms_factory(nativePtr);
				MediastreamerFactory factory = new MediastreamerFactory();
				factory.nativePtr = ptr;
				return factory;
			}
		}

		/// Get the native window handle of the video window.
		public string NativeVideoWindowIdString
		{
			get
			{
				return Marshal.PtrToStringUni(linphone_core_get_native_video_window_id(nativePtr));
			}
			set
			{
				IntPtr string_ptr_to_remove = linphone_core_get_native_video_window_id(nativePtr);
				IntPtr string_ptr = Marshal.StringToHGlobalUni(value);
				linphone_core_set_native_video_window_id(nativePtr, string_ptr);
				if(string_ptr_to_remove != IntPtr.Zero)
					Marshal.FreeHGlobal(string_ptr_to_remove);
			}
		}

		/// Get the native window handle of the video preview window.
		public string NativePreviewWindowIdString
		{
			get
			{
				return Marshal.PtrToStringUni(linphone_core_get_native_preview_window_id(nativePtr));
			}
			set
			{
				IntPtr string_ptr_to_remove = linphone_core_get_native_preview_window_id(nativePtr);
				IntPtr string_ptr = Marshal.StringToHGlobalUni(value);
				linphone_core_set_native_preview_window_id(nativePtr, string_ptr);
				if(string_ptr_to_remove != IntPtr.Zero)
					Marshal.FreeHGlobal(string_ptr_to_remove);
			}
		}

		[StructLayout(LayoutKind.Sequential)]
		public struct MSOglContextInfo
		{
			public System.IntPtr window;
			public System.UInt32 width;
			public System.UInt32 height;
			public System.IntPtr getProcAddress;
		};

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_native_video_window_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_native_video_window_id(IntPtr thiz, IntPtr windowId);

		/// <summary>
		/// Get the native window handle of the video window. On Windows UWP/WindowsStore, this is a SwapChainPanel. eg: LinphoneManager.Instance.Core.NativeVideoWindowId = panel; The rendering is automatically done by Linphone.
		/// </summary>
#if WINDOWS_UWP
		public Windows.UI.Xaml.Controls.SwapChainPanel NativeVideoWindowId
		{
			get
			{
				return (Windows.UI.Xaml.Controls.SwapChainPanel)Marshal.GetObjectForIUnknown(((MSOglContextInfo)Marshal.PtrToStructure<MSOglContextInfo>(linphone_core_get_native_video_window_id(nativePtr)) ).window);
			}
			set
			{
				MSOglContextInfo c;
				if (value != null)
					c.window = Marshal.GetIUnknownForObject(value);
				else
					c.window = IntPtr.Zero;
				c.getProcAddress = IntPtr.Zero;
				c.width = 0;
				c.height = 0;
				IntPtr pnt = Marshal.AllocHGlobal(Marshal.SizeOf(c));
				Marshal.StructureToPtr(c, pnt, false);
				IntPtr oldData = linphone_core_get_native_video_window_id(nativePtr);
				linphone_core_set_native_video_window_id(nativePtr, pnt);
				if (oldData != IntPtr.Zero){
					IntPtr window = ((MSOglContextInfo)Marshal.PtrToStructure<MSOglContextInfo>(oldData) ).window;
					if(window != IntPtr.Zero)
						Marshal.Release( window );
					Marshal.FreeHGlobal(oldData);
				}
			}
		}
#else
		public IntPtr NativeVideoWindowId
		{
			get
			{
				return linphone_core_get_native_video_window_id(nativePtr);
			}
			set
			{
				linphone_core_set_native_video_window_id(nativePtr, value);
			}
		}
#endif
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_native_preview_window_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_native_preview_window_id(IntPtr thiz, IntPtr windowId);

		/// <summary>
		/// Get the native window handle of the video preview window. On Windows UWP/WindowsStore, this is a SwapChainPanel. eg: LinphoneManager.Instance.Core.NativePreviewWindowId = panel; The rendering is automatically done by Linphone.
		/// </summary>
		///
#if WINDOWS_UWP
		public Windows.UI.Xaml.Controls.SwapChainPanel NativePreviewWindowId
		{
			get
			{
				return(Windows.UI.Xaml.Controls.SwapChainPanel) Marshal.GetObjectForIUnknown(((MSOglContextInfo)Marshal.PtrToStructure<MSOglContextInfo>(linphone_core_get_native_preview_window_id(nativePtr)) ).window);
			}
			set
			{
				MSOglContextInfo c;
				if (value != null)
					c.window = Marshal.GetIUnknownForObject(value);
				else
					c.window = IntPtr.Zero;
				c.getProcAddress = IntPtr.Zero;
				c.width = 0;
				c.height = 0;
				IntPtr pnt = Marshal.AllocHGlobal(Marshal.SizeOf(c));
				Marshal.StructureToPtr(c, pnt, false);
				IntPtr oldData = linphone_core_get_native_preview_window_id(nativePtr);
				linphone_core_set_native_preview_window_id(nativePtr, pnt);
				if (oldData != IntPtr.Zero){
					IntPtr window = ((MSOglContextInfo)Marshal.PtrToStructure<MSOglContextInfo>(oldData) ).window;
					if(window != IntPtr.Zero)
						Marshal.Release( window );
					Marshal.FreeHGlobal(oldData);
				}
			}
		}
#else
		public IntPtr NativePreviewWindowId
		{
			get
			{
				return linphone_core_get_native_preview_window_id(nativePtr);
			}
			set
			{
				linphone_core_set_native_preview_window_id(nativePtr, value);
			}
		}
#endif


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_core_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private CoreListener listener;

		public CoreListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_core_cbs(linphone_factory_get());
					listener = fromNativePtr<CoreListener>(nativeListener, false, true);
					linphone_core_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_core_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_compress_log_collection();

		/// <summary>
		/// Compress the log collection in a single file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path of the compressed log collection file (to be freed calling
		/// ms_free()).       </returns>
		public static string CompressLogCollection()
		{
			IntPtr stringPtr = linphone_core_compress_log_collection();
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_log_collection(int state);

		/// <summary>
		/// Enable the linphone core log collection to upload logs on a server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="state"><see cref="Linphone.LogCollectionState">
		/// Linphone.LogCollectionState</see> value telling whether to enable log
		/// collection or not. </param>
		public static void EnableLogCollection(Linphone.LogCollectionState state)
		{
			linphone_core_enable_log_collection((int)state);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_core_get_log_collection_max_file_size();

		/// <summary>
		/// Get the max file size in bytes of the files used for log collection. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The max file size in bytes of the files used for log collection.   
		/// </returns>
		static public long LogCollectionMaxFileSize
		{
			get
			{
				return linphone_core_get_log_collection_max_file_size();
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_log_collection_path();

		/// <summary>
		/// Get the path where the log files will be written for log collection. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path where the log files will be written.    </returns>
		static public string LogCollectionPath
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_log_collection_path();
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_log_collection_prefix();

		/// <summary>
		/// Get the prefix of the filenames that will be used for log collection. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The prefix of the filenames used for log collection.    </returns>
		static public string LogCollectionPrefix
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_log_collection_prefix();
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_post_quantum_available();

		/// <summary>
		/// Are PostQuantum algoritms available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if Post Quantum algorithms are available false otherwise
		/// </returns>
		static public bool PostQuantumAvailable
		{
			get
			{
				return linphone_core_get_post_quantum_available() != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_version();

		/// <summary>
		/// Returns liblinphone&apos;s version as a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the current version of the <see cref="Linphone.Core">
		/// Linphone.Core</see>    </returns>
		static public string Version
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_version();
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.LogCollectionState linphone_core_log_collection_enabled();

		/// <summary>
		/// Tells whether the linphone core log collection is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.LogCollectionState">
		/// Linphone.LogCollectionState</see> of the <see cref="Linphone.Core">
		/// Linphone.Core</see> log collection. </returns>
		public static Linphone.LogCollectionState LogCollectionEnabled()
		{
			Linphone.LogCollectionState returnVal = linphone_core_log_collection_enabled();
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_reset_log_collection();

		/// <summary>
		/// Reset the log collection by removing the log files. 
		/// <para>
		/// </para>
		/// </summary>
		public static void ResetLogCollection()
		{
			linphone_core_reset_log_collection();
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_serialize_logs();

		/// <summary>
		/// Enable logs serialization (output logs from either the thread that creates the
		/// linphone core or the thread that calls <see cref="Linphone.Core.Iterate()">
		/// Linphone.Core.Iterate()</see>). 
		/// <para>
		/// Must be called before creating the linphone core. 
		/// </para>
		/// </summary>
		public static void SerializeLogs()
		{
			linphone_core_serialize_logs();
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_log_collection_max_file_size(long size);

		/// <summary>
		/// Set the max file size in bytes of the files used for log collection. 
		/// <para>
		/// Warning: this function should only not be used to change size dynamically but
		/// instead only before calling <see cref="Linphone.Core.EnableLogCollection()">
		/// Linphone.Core.EnableLogCollection()</see>. If you increase max size on runtime,
		/// logs chronological order COULD be broken. 
		/// </para>
		/// </summary>
		/// <param name="size">The max file size in bytes of the files used for log
		/// collection. </param>
		public static void SetLogCollectionMaxFileSize(long size)
		{
			linphone_core_set_log_collection_max_file_size(size);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_log_collection_path(string path);

		/// <summary>
		/// Set the path of a directory where the log files will be written for log
		/// collection. 
		/// <para>
		/// When log collection is enabled, the function will close the file with the
		/// current prefix in the old path and it will open the new file with current
		/// prefix in the new path. If you need to change the path and the file at the same
		/// time, then you should deactivate log collection with <see cref="Linphone.Core.EnableLogCollection()">
		/// Linphone.Core.EnableLogCollection()</see> before doing modifications. 
		/// </para>
		/// </summary>
		/// <param name="path">The path where the log files will be written.    </param>
		public static void SetLogCollectionPath(string path)
		{
			linphone_core_set_log_collection_path(path);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_log_collection_prefix(string prefix);

		/// <summary>
		/// Set the prefix of the filenames that will be used for log collection. 
		/// <para>
		/// When log collection is enabled, the function will close the old file and it
		/// will open the new one in the current path. If you need to change the path and
		/// the file at the same time, then you should deactivate log collection with <see cref="Linphone.Core.EnableLogCollection()">
		/// Linphone.Core.EnableLogCollection()</see> before doing modifications. 
		/// </para>
		/// </summary>
		/// <param name="prefix">The prefix to use for the filenames for log collection.   
		/// </param>
		public static void SetLogCollectionPrefix(string prefix)
		{
			linphone_core_set_log_collection_prefix(prefix);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_tunnel_available();

		/// <summary>
		/// True if tunnel support was compiled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if library was built with tunnel, false otherwise </returns>
		public static bool TunnelAvailable()
		{
			bool returnVal = linphone_core_tunnel_available() == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_upnp_available();

		/// <summary>
		/// Return the availability of uPnP. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if uPnP is available otherwise return false. </returns>
		public static bool UpnpAvailable()
		{
			bool returnVal = linphone_core_upnp_available() == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_vcard_supported();

		/// <summary>
		/// Tells whether VCARD support is builtin. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if VCARD is supported, false otherwise. </returns>
		public static bool VcardSupported()
		{
			bool returnVal = linphone_core_vcard_supported() == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AccountCreatorBackend linphone_core_get_account_creator_backend(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_account_creator_backend(IntPtr thiz, int backend);

		/// <summary>
		/// Get the <see cref="Linphone.AccountCreator">Linphone.AccountCreator</see>
		/// backend set for the <see cref="Linphone.Core">Linphone.Core</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.AccountCreatorBackend">
		/// Linphone.AccountCreatorBackend</see> </returns>
		public Linphone.AccountCreatorBackend AccountCreatorBackend
		{
			get
			{
				return linphone_core_get_account_creator_backend(nativePtr);
			}
			set
			{
				linphone_core_set_account_creator_backend(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_account_creator_url(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_account_creator_url(IntPtr thiz, string url);

		/// <summary>
		/// Get the <see cref="Linphone.AccountCreator">Linphone.AccountCreator</see> url
		/// on the <see cref="Linphone.Core">Linphone.Core</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>url The URL to reach.    </returns>
		public string AccountCreatorUrl
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_account_creator_url(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_account_creator_url(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_account_list(IntPtr thiz);

		/// <summary>
		/// Returns an unmodifiable list of entered accounts. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>     </returns>
		public IEnumerable<Linphone.Account> AccountList
		{
			get
			{
				return MarshalBctbxList<Linphone.Account>(linphone_core_get_account_list(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_adaptive_rate_algorithm(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_adaptive_rate_algorithm(IntPtr thiz, string algorithm);

		/// <summary>
		/// Returns which adaptive rate algorithm is currently configured for future calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.Core.AdaptiveRateAlgorithm">
		/// Linphone.Core.AdaptiveRateAlgorithm</see> </remarks>
		/// <returns>the adaptive rate algorithm. Currently two values are supported:
		/// &apos;advanced&apos;, which is the default value, or &apos;basic&apos;.   
		/// </returns>
		public string AdaptiveRateAlgorithm
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_adaptive_rate_algorithm(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_adaptive_rate_algorithm(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_adaptive_rate_control_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_adaptive_rate_control(IntPtr thiz, char enabled);

		/// <summary>
		/// Returns whether adaptive rate control is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.Core.EnableAdaptiveRateControl()">
		/// Linphone.Core.EnableAdaptiveRateControl()</see></remarks>
		/// <returns>true if adaptive rate control is enabled, false otherwise </returns>
		public bool AdaptiveRateControlEnabled
		{
			get
			{
				return linphone_core_adaptive_rate_control_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_adaptive_rate_control(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_agc_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_agc(IntPtr thiz, char val);

		/// <summary>
		/// Tells whether the experimental software Automatic Gain Control is activated. 
		/// <para>
		/// This algorithm is very experimental, not usable in its current state. 
		/// </para>
		/// </summary>
		/// <returns>true if the AGC is enabled, false otherwise. </returns>
		public bool AgcEnabled
		{
			get
			{
				return linphone_core_agc_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_agc(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_alerts_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_alerts(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether alert reporting is enabled. 
		/// <para>
		/// See <see cref="Linphone.Alert">Linphone.Alert</see> for more details. 
		/// </para>
		/// </summary>
		/// <returns>whether alert reporting is enabled. </returns>
		public bool AlertsEnabled
		{
			get
			{
				return linphone_core_alerts_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_alerts(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_audio_adaptive_jittcomp_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_audio_adaptive_jittcomp(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether the audio adaptive jitter compensation is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the audio adaptive jitter compensation is enabled, false
		/// otherwise. </returns>
		public bool AudioAdaptiveJittcompEnabled
		{
			get
			{
				return linphone_core_audio_adaptive_jittcomp_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_audio_adaptive_jittcomp(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_audio_devices(IntPtr thiz);

		/// <summary>
		/// Returns a list of audio devices, with only the first device for each type To
		/// have the list of all audio devices, use <see cref="Linphone.Core.ExtendedAudioDevices">
		/// Linphone.Core.ExtendedAudioDevices</see> 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>  A list with the first <see cref="Linphone.AudioDevice">
		/// Linphone.AudioDevice</see> of each type       </returns>
		public IEnumerable<Linphone.AudioDevice> AudioDevices
		{
			get
			{
				return MarshalBctbxList<Linphone.AudioDevice>(linphone_core_get_audio_devices(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_audio_dscp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_audio_dscp(IntPtr thiz, int dscp);

		/// <summary>
		/// Get the DSCP field for outgoing audio streams. 
		/// <para>
		/// The DSCP defines the quality of service in IP packets. 
		/// </para>
		/// </summary>
		/// <returns>The current DSCP value </returns>
		public int AudioDscp
		{
			get
			{
				return linphone_core_get_audio_dscp(nativePtr);
			}
			set
			{
				linphone_core_set_audio_dscp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_audio_jittcomp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_audio_jittcomp(IntPtr thiz, int milliseconds);

		/// <summary>
		/// Returns the nominal audio jitter buffer size in milliseconds. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The nominal audio jitter buffer size in milliseconds </returns>
		public int AudioJittcomp
		{
			get
			{
				return linphone_core_get_audio_jittcomp(nativePtr);
			}
			set
			{
				linphone_core_set_audio_jittcomp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_audio_multicast_addr(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_audio_multicast_addr(IntPtr thiz, string ip);

		/// <summary>
		/// Use to get multicast address to be used for audio stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>an ipv4/6 multicast address or default value.    </returns>
		public string AudioMulticastAddr
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_audio_multicast_addr(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_audio_multicast_addr(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("AudioMulticastAddr setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_audio_multicast_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_audio_multicast(IntPtr thiz, char yesno);

		/// <summary>
		/// Use to get multicast state of audio stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if subsequent calls will propose multicast ip set by <see cref="Linphone.Core.AudioMulticastAddr">
		/// Linphone.Core.AudioMulticastAddr</see> </returns>
		public bool AudioMulticastEnabled
		{
			get
			{
				return linphone_core_audio_multicast_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_audio_multicast(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_audio_multicast_ttl(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_audio_multicast_ttl(IntPtr thiz, int ttl);

		/// <summary>
		/// Use to get multicast ttl to be used for audio stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a time to leave value </returns>
		public int AudioMulticastTtl
		{
			get
			{
				return linphone_core_get_audio_multicast_ttl(nativePtr);
			}
			set
			{
				int exception_result = linphone_core_set_audio_multicast_ttl(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("AudioMulticastTtl setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_audio_payload_types(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_audio_payload_types(IntPtr thiz, IntPtr payloadTypes);

		/// <summary>
		/// Return the list of the available audio payload types. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A freshly allocated list of the available payload types.        
		/// </returns>
		public IEnumerable<Linphone.PayloadType> AudioPayloadTypes
		{
			get
			{
				return MarshalBctbxList<Linphone.PayloadType>(linphone_core_get_audio_payload_types(nativePtr), true);
			}
			set
			{
				linphone_core_set_audio_payload_types(nativePtr, ObjectArrayToBctbxList<Linphone.PayloadType>(value));
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_audio_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_audio_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the UDP port used for audio streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The UDP port used for audio streaming </returns>
		public int AudioPort
		{
			get
			{
				return linphone_core_get_audio_port(nativePtr);
			}
			set
			{
				linphone_core_set_audio_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_audio_ports_range(IntPtr thiz);

		/// <summary>
		/// Get the audio port range from which is randomly chosen the UDP port used for
		/// audio streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Range">Linphone.Range</see> object      
		/// </returns>
		public Linphone.Range AudioPortsRange
		{
			get
			{
				IntPtr ptr = linphone_core_get_audio_ports_range(nativePtr);
				Linphone.Range obj = fromNativePtr<Linphone.Range>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_auth_info_list(IntPtr thiz);

		/// <summary>
		/// Returns an unmodifiable list of currently entered <see cref="Linphone.AuthInfo">
		/// Linphone.AuthInfo</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of <see cref="Linphone.AuthInfo">Linphone.AuthInfo</see>.     
		/// </returns>
		public IEnumerable<Linphone.AuthInfo> AuthInfoList
		{
			get
			{
				return MarshalBctbxList<Linphone.AuthInfo>(linphone_core_get_auth_info_list(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_auto_download_icalendars_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_auto_download_icalendars(IntPtr thiz, char autoDownloadIcalendars);

		/// <summary>
		/// Gets if the auto download for incoming icalendars is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if icalendars will be automatically downloaded, false otherwise.
		/// </returns>
		public bool AutoDownloadIcalendarsEnabled
		{
			get
			{
				return linphone_core_auto_download_icalendars_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_auto_download_icalendars(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_auto_download_voice_recordings_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_auto_download_voice_recordings(IntPtr thiz, char autoDownloadVoiceRecordings);

		/// <summary>
		/// Gets if the auto download for incoming voice recordings is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if voice recordings will be automatically downloaded, false
		/// otherwise. </returns>
		public bool AutoDownloadVoiceRecordingsEnabled
		{
			get
			{
				return linphone_core_auto_download_voice_recordings_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_auto_download_voice_recordings(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_auto_iterate_background_schedule(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_auto_iterate_background_schedule(IntPtr thiz, int schedule);

		/// <summary>
		/// Gets the timer used to schedule the call to core.iterate() method when in
		/// background (Android only). 
		/// <para>
		/// This is only used when <see cref="Linphone.Core.AutoIterateEnabled()">
		/// Linphone.Core.AutoIterateEnabled()</see> returns true. 
		/// </para>
		/// </summary>
		/// <returns>The timing in milliseconds used to schedule the call while in
		/// background (default is 500ms). </returns>
		public int AutoIterateBackgroundSchedule
		{
			get
			{
				return linphone_core_get_auto_iterate_background_schedule(nativePtr);
			}
			set
			{
				linphone_core_set_auto_iterate_background_schedule(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_auto_iterate_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_auto_iterate(IntPtr thiz, char enable);

		/// <summary>
		/// Gets whether auto iterate is enabled or not (Android &amp; iOS only). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if <see cref="Linphone.Core.Iterate()">
		/// Linphone.Core.Iterate()</see> is scheduled automatically, false otherwise
		/// </returns>
		public bool AutoIterateEnabled
		{
			get
			{
				return linphone_core_auto_iterate_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_auto_iterate(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_auto_iterate_foreground_schedule(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_auto_iterate_foreground_schedule(IntPtr thiz, int schedule);

		/// <summary>
		/// Gets the timer used to schedule the call to core.iterate() method when in
		/// foreground (Android only). 
		/// <para>
		/// This is only used when <see cref="Linphone.Core.AutoIterateEnabled()">
		/// Linphone.Core.AutoIterateEnabled()</see> returns true. 
		/// </para>
		/// </summary>
		/// <returns>The timing in milliseconds used to schedule the call while in
		/// foreground (default is 20ms). </returns>
		public int AutoIterateForegroundSchedule
		{
			get
			{
				return linphone_core_get_auto_iterate_foreground_schedule(nativePtr);
			}
			set
			{
				linphone_core_set_auto_iterate_foreground_schedule(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_auto_send_ringing_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_auto_send_ringing(IntPtr thiz, char enable);

		/// <summary>
		/// Gets if the automatic sending of 180 Ringing is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the automatic sending of 180 Ringing is enabled, false
		/// otherwise. </returns>
		public bool AutoSendRingingEnabled
		{
			get
			{
				return linphone_core_auto_send_ringing_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_auto_send_ringing(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_automatic_http_proxy_detection_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_automatic_http_proxy_detection(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether automatic http proxy is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if automatic http proxy is enabled or false. </returns>
		public bool AutomaticHttpProxyDetectionEnabled
		{
			get
			{
				return linphone_core_automatic_http_proxy_detection_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_automatic_http_proxy_detection(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AVPFMode linphone_core_get_avpf_mode(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_avpf_mode(IntPtr thiz, int mode);

		/// <summary>
		/// Return AVPF enablement. 
		/// <para>
		/// See <see cref="Linphone.Core.AvpfMode">Linphone.Core.AvpfMode</see> . 
		/// </para>
		/// </summary>
		/// <returns>The current <see cref="Linphone.AVPFMode">Linphone.AVPFMode</see> mode
		/// </returns>
		public Linphone.AVPFMode AvpfMode
		{
			get
			{
				return linphone_core_get_avpf_mode(nativePtr);
			}
			set
			{
				linphone_core_set_avpf_mode(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_avpf_rr_interval(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_avpf_rr_interval(IntPtr thiz, int interval);

		/// <summary>
		/// Return the avpf report interval in seconds. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current AVPF report interval in seconds </returns>
		public int AvpfRrInterval
		{
			get
			{
				return linphone_core_get_avpf_rr_interval(nativePtr);
			}
			set
			{
				linphone_core_set_avpf_rr_interval(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_call_logs(IntPtr thiz);

		/// <summary>
		/// Get the list of call logs (past calls). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of <see cref="Linphone.CallLog">Linphone.CallLog</see>.     
		/// </returns>
		public IEnumerable<Linphone.CallLog> CallLogs
		{
			get
			{
				return MarshalBctbxList<Linphone.CallLog>(linphone_core_get_call_logs(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_call_logs_database_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_call_logs_database_path(IntPtr thiz, string path);

		/// <summary>
		/// Gets the database filename where call logs will be stored. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>filesystem path.    </returns>
		/// deprecated : 07/12/2021: Use only for migration purposes 
		public string CallLogsDatabasePath
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_call_logs_database_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_call_logs_database_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_call_tone_indications_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_call_tone_indications(IntPtr thiz, char yesno);

		/// <summary>
		/// Check whether tone indications of calls are enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if call tone indications are enabled </returns>
		public bool CallToneIndicationsEnabled
		{
			get
			{
				return linphone_core_call_tone_indications_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_call_tone_indications(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_callkit_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_callkit(IntPtr thiz, char enabled);

		/// <summary>
		/// Special function to check if the callkit is enabled, False by default. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if callkit is enabled, false otherwise. </returns>
		public bool CallkitEnabled
		{
			get
			{
				return linphone_core_callkit_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_callkit(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_calls(IntPtr thiz);

		/// <summary>
		/// Gets the current list of calls. 
		/// <para>
		/// Note that this list is read-only and might be changed by the core after a
		/// function call to <see cref="Linphone.Core.Iterate()">
		/// Linphone.Core.Iterate()</see>. Similarly the <see cref="Linphone.Call">
		/// Linphone.Call</see> objects inside it might be destroyed without prior notice.
		/// To hold references to <see cref="Linphone.Call">Linphone.Call</see> object into
		/// your program, you must use linphone_call_ref. 
		/// </para>
		/// </summary>
		/// <returns>A list of <see cref="Linphone.Call">Linphone.Call</see>      </returns>
		public IEnumerable<Linphone.Call> Calls
		{
			get
			{
				return MarshalBctbxList<Linphone.Call>(linphone_core_get_calls(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_calls_nb(IntPtr thiz);

		/// <summary>
		/// Get the number of Call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current number of calls </returns>
		public int CallsNb
		{
			get
			{
				return linphone_core_get_calls_nb(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_camera_sensor_rotation(IntPtr thiz);

		/// <summary>
		/// Get the camera sensor rotation. 
		/// <para>
		/// This is needed on some mobile platforms to get the number of degrees the camera
		/// sensor is rotated relative to the screen. 
		/// </para>
		/// </summary>
		/// <returns>The camera sensor rotation in degrees (0 to 360) or -1 if it could not
		/// be retrieved </returns>
		public int CameraSensorRotation
		{
			get
			{
				return linphone_core_get_camera_sensor_rotation(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_capability_negociation_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_capability_negociation(IntPtr thiz, char enable);

		/// <summary>
		/// Check if the capability negotiation (RFC5939) is supported or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if capability negotiation is supported; false otherwise.
		/// </returns>
		public bool CapabilityNegociationEnabled
		{
			get
			{
				return linphone_core_capability_negociation_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_capability_negociation(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_capability_negotiation_reinvite_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_capability_negotiation_reinvite(IntPtr thiz, char enable);

		/// <summary>
		/// Check if the capability negotiation (RFC5939) reINVITE is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if capability negotiation reINVITE is enabled; false otherwise.
		/// </returns>
		public bool CapabilityNegotiationReinviteEnabled
		{
			get
			{
				return linphone_core_capability_negotiation_reinvite_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_capability_negotiation_reinvite(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_capture_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_capture_device(IntPtr thiz, string devid);

		/// <summary>
		/// Gets the name of the currently assigned sound device for capture. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The name of the currently assigned sound device for capture.   
		/// </returns>
		public string CaptureDevice
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_capture_device(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_capture_device(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("CaptureDevice setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_cfg_lines_merging_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_cfg_lines_merging(IntPtr thiz, char merge);

		/// <summary>
		/// Check if cfg lines are going to the merged if the capability negotiation
		/// (RFC5939) is supported or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if acfg and pcfg lines with consecutive indexes are going to be
		/// merged; false otherwise. </returns>
		public bool CfgLinesMergingEnabled
		{
			get
			{
				return linphone_core_cfg_lines_merging_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_cfg_lines_merging(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_chat_enabled(IntPtr thiz);

		/// <summary>
		/// Returns whether chat is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if chat is enabled, false otherwise </returns>
		public bool ChatEnabled
		{
			get
			{
				return linphone_core_chat_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_chat_messages_aggregation_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_chat_messages_aggregation_enabled(IntPtr thiz, char enabled);

		/// <summary>
		/// Returns whether chat messages grouping is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if received chat messages will be notified as a bundle, false
		/// otherwise. </returns>
		public bool ChatMessagesAggregationEnabled
		{
			get
			{
				return linphone_core_get_chat_messages_aggregation_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_chat_messages_aggregation_enabled(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_chat_rooms(IntPtr thiz);

		/// <summary>
		/// Returns a list of chat rooms. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>List of chat rooms.      </returns>
		public IEnumerable<Linphone.ChatRoom> ChatRooms
		{
			get
			{
				return MarshalBctbxList<Linphone.ChatRoom>(linphone_core_get_chat_rooms(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_conference(IntPtr thiz);

		/// <summary>
		/// Get a pointer on the internal conference object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer on <see cref="Linphone.Conference">Linphone.Conference</see>
		/// or null if no conference are going on.    </returns>
		/// deprecated : 10/08/2023 Use <see cref="Linphone.Core.SearchConference()">
		/// Linphone.Core.SearchConference()</see> instead. 
		public Linphone.Conference Conference
		{
			get
			{
				IntPtr ptr = linphone_core_get_conference(nativePtr);
				Linphone.Conference obj = fromNativePtr<Linphone.Conference>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_conference_ics_in_message_body_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_conference_ics_in_message_body(IntPtr thiz, char enable);

		/// <summary>
		/// Gets wether conference invitations will be sent in the chat message body or as
		/// a file attachment. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if ICS will be sent in the message body (by default), false if it
		/// will be sent as a file attachment. </returns>
		public bool ConferenceIcsInMessageBodyEnabled
		{
			get
			{
				return linphone_core_conference_ics_in_message_body_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_conference_ics_in_message_body(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_conference_information_list(IntPtr thiz);

		/// <summary>
		/// Retrieve the list of conference information on DB. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The list of conference infos  .       </returns>
		public IEnumerable<Linphone.ConferenceInfo> ConferenceInformationList
		{
			get
			{
				return MarshalBctbxList<Linphone.ConferenceInfo>(linphone_core_get_conference_information_list(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_core_get_conference_local_input_volume(IntPtr thiz);

		/// <summary>
		/// Get the set input volume of the local participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A value inside [0.0 ; 1.0] </returns>
		public float ConferenceLocalInputVolume
		{
			get
			{
				return linphone_core_get_conference_local_input_volume(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConferenceParticipantListType linphone_core_get_conference_participant_list_type(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_conference_participant_list_type(IntPtr thiz, int type);

		/// <summary>
		/// Tells whether the default conference participant list is open or closed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.ConferenceParticipantListType">
		/// Linphone.ConferenceParticipantListType</see> participant list type </returns>
		public Linphone.ConferenceParticipantListType ConferenceParticipantListType
		{
			get
			{
				return linphone_core_get_conference_participant_list_type(nativePtr);
			}
			set
			{
				linphone_core_set_conference_participant_list_type(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_conference_server_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_conference_server(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether the conference server feature is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether the conference server feature is
		/// enabled or not </returns>
		public bool ConferenceServerEnabled
		{
			get
			{
				return linphone_core_conference_server_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_conference_server(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_conference_size(IntPtr thiz);

		/// <summary>
		/// Get the number of participants including me, if it in, in the running
		/// conference. 
		/// <para>
		/// The local participant is included in the count only if it is in the conference. 
		/// </para>
		/// </summary>
		/// <returns>The number of participants including me, if it in. </returns>
		/// deprecated : 16/04/2021 Use <see cref="Linphone.Conference.ParticipantCount">
		/// Linphone.Conference.ParticipantCount</see> instead. 
		public int ConferenceSize
		{
			get
			{
				return linphone_core_get_conference_size(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_config(IntPtr thiz);

		/// <summary>
		/// Returns the config object used to manage the storage (config) file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Config">Linphone.Config</see> object.   
		/// </returns>
		public Linphone.Config Config
		{
			get
			{
				IntPtr ptr = linphone_core_get_config(nativePtr);
				Linphone.Config obj = fromNativePtr<Linphone.Config>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConsolidatedPresence linphone_core_get_consolidated_presence(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_consolidated_presence(IntPtr thiz, int presence);

		/// <summary>
		/// Get my consolidated presence. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>My <see cref="Linphone.ConsolidatedPresence">
		/// Linphone.ConsolidatedPresence</see> presence </returns>
		public Linphone.ConsolidatedPresence ConsolidatedPresence
		{
			get
			{
				return linphone_core_get_consolidated_presence(nativePtr);
			}
			set
			{
				linphone_core_set_consolidated_presence(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_current_call(IntPtr thiz);

		/// <summary>
		/// Gets the current call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current call or null if no call is running.    </returns>
		public Linphone.Call CurrentCall
		{
			get
			{
				IntPtr ptr = linphone_core_get_current_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_current_call_remote_address(IntPtr thiz);

		/// <summary>
		/// Get the remote address of the current call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The remote address of the current call or null if there is no current
		/// call.    </returns>
		public Linphone.Address CurrentCallRemoteAddress
		{
			get
			{
				IntPtr ptr = linphone_core_get_current_call_remote_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_current_preview_video_definition(IntPtr thiz);

		/// <summary>
		/// Get the effective video definition provided by the camera for the captured
		/// video. 
		/// <para>
		/// When preview is disabled or not yet started this function returns a 0x0 video
		/// definition. 
		/// </para>
		/// </summary>
		/// <returns>The captured <see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see>.   </returns>
		/// <remarks>See : <see cref="Linphone.Core.PreviewVideoDefinition">
		/// Linphone.Core.PreviewVideoDefinition</see> </remarks>
		public Linphone.VideoDefinition CurrentPreviewVideoDefinition
		{
			get
			{
				IntPtr ptr = linphone_core_get_current_preview_video_definition(nativePtr);
				Linphone.VideoDefinition obj = fromNativePtr<Linphone.VideoDefinition>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_default_account(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_default_account(IntPtr thiz, IntPtr account);

		/// <summary>
		/// Returns the default account, that is the one used to determine the current
		/// identity. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The default account.    </returns>
		public Linphone.Account DefaultAccount
		{
			get
			{
				IntPtr ptr = linphone_core_get_default_account(nativePtr);
				Linphone.Account obj = fromNativePtr<Linphone.Account>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_default_account(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConferenceLayout linphone_core_get_default_conference_layout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_default_conference_layout(IntPtr thiz, int val);

		/// <summary>
		/// Gets the default conference layout. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>conference layout </returns>
		public Linphone.ConferenceLayout DefaultConferenceLayout
		{
			get
			{
				return linphone_core_get_default_conference_layout(nativePtr);
			}
			set
			{
				linphone_core_set_default_conference_layout(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_default_ephemeral_lifetime(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_default_ephemeral_lifetime(IntPtr thiz, int val);

		/// <summary>
		/// Gets the default lifetime of ephemeral messages in seconds. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>lifetime of ephemeral messages in seconds </returns>
		public int DefaultEphemeralLifetime
		{
			get
			{
				return linphone_core_get_default_ephemeral_lifetime(nativePtr);
			}
			set
			{
				linphone_core_set_default_ephemeral_lifetime(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_default_friend_list(IntPtr thiz);

		/// <summary>
		/// Retrieves the first list of <see cref="Linphone.Friend">Linphone.Friend</see>
		/// from the core. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the first <see cref="Linphone.FriendList">Linphone.FriendList</see>
		/// object or null.    </returns>
		public Linphone.FriendList DefaultFriendList
		{
			get
			{
				IntPtr ptr = linphone_core_get_default_friend_list(nativePtr);
				Linphone.FriendList obj = fromNativePtr<Linphone.FriendList>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_default_input_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_default_input_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the default input audio device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The default input audio device    </returns>
		public Linphone.AudioDevice DefaultInputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_core_get_default_input_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_default_input_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_default_output_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_default_output_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the default output audio device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The default output audio device    </returns>
		public Linphone.AudioDevice DefaultOutputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_core_get_default_output_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_default_output_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_default_proxy_config(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_default_proxy_config(IntPtr thiz, IntPtr config);

		/// <summary>
		/// Returns the default proxy configuration, that is the one used to determine the
		/// current identity. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The default proxy configuration.    </returns>
		public Linphone.ProxyConfig DefaultProxyConfig
		{
			get
			{
				IntPtr ptr = linphone_core_get_default_proxy_config(nativePtr);
				Linphone.ProxyConfig obj = fromNativePtr<Linphone.ProxyConfig>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_default_proxy_config(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_default_video_display_filter(IntPtr thiz);

		/// <summary>
		/// Get the name of the default mediastreamer2 filter used for rendering video on
		/// the current platform. 
		/// <para>
		/// This is for advanced users of the library, mainly to expose mediastreamer video
		/// filter name and status. 
		/// </para>
		/// </summary>
		/// <returns>The default video display filter.    </returns>
		public string DefaultVideoDisplayFilter
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_default_video_display_filter(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_delayed_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_delayed_timeout(IntPtr thiz, int seconds);

		/// <summary>
		/// Gets the delayed timeout See <see cref="Linphone.Core.DelayedTimeout">
		/// Linphone.Core.DelayedTimeout</see> for details. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current delayed timeout in seconds </returns>
		public int DelayedTimeout
		{
			get
			{
				return linphone_core_get_delayed_timeout(nativePtr);
			}
			set
			{
				linphone_core_set_delayed_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_device_rotation(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_device_rotation(IntPtr thiz, int rotation);

		/// <summary>
		/// Gets the current device orientation. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current device orientation</returns>
		/// <remarks>See : <see cref="Linphone.Core.DeviceRotation">
		/// Linphone.Core.DeviceRotation</see> </remarks>
		public int DeviceRotation
		{
			get
			{
				return linphone_core_get_device_rotation(nativePtr);
			}
			set
			{
				linphone_core_set_device_rotation(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_digest_authentication_policy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_digest_authentication_policy(IntPtr thiz, IntPtr policy);

		/// <summary>
		/// Get the current digest authentication policy applicable for SIP and HTTP. 
		/// <para>
		/// Get the current digest authentication policy applicable for SIP and HTTP. 
		/// </para>
		/// </summary>
		/// <returns>The current digest authentication policy.    </returns>
		public Linphone.DigestAuthenticationPolicy DigestAuthenticationPolicy
		{
			get
			{
				IntPtr ptr = linphone_core_get_digest_authentication_policy(nativePtr);
				Linphone.DigestAuthenticationPolicy obj = fromNativePtr<Linphone.DigestAuthenticationPolicy>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_digest_authentication_policy(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_disable_record_on_mute(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_disable_record_on_mute(IntPtr thiz, char disable);

		/// <summary>
		/// Get whether the microphone will be completely deactivated when muted. 
		/// <para>
		/// Please refer to <see cref="Linphone.Core.DisableRecordOnMute">
		/// Linphone.Core.DisableRecordOnMute</see>.
		/// </para>
		/// </summary>
		/// <returns>True if you wish to entirely stop the audio recording when muting the
		/// microphone. </returns>
		public bool DisableRecordOnMute
		{
			get
			{
				return linphone_core_get_disable_record_on_mute(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_disable_record_on_mute(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_dns_search_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_dns_search(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether DNS search (use of local domain if the fully qualified name did
		/// return results) is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if DNS search is enabled, false if disabled. </returns>
		public bool DnsSearchEnabled
		{
			get
			{
				return linphone_core_dns_search_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_dns_search(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_dns_servers(IntPtr thiz, IntPtr servers);

		/// <summary>
		/// Forces liblinphone to use the supplied list of dns servers, instead of
		/// system&apos;s ones. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="servers">A list of strings containing the IP addresses of DNS
		/// servers to be used.   Setting to null restores default behaviour, which is to
		/// use the DNS server list provided by the system. The list is copied internally. 
		///   </param>
		public IEnumerable<string> DnsServers
		{
			set
			{
				linphone_core_set_dns_servers(nativePtr, StringArrayToBctbxList(value));
				CleanStringArrayPtrs();
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_dns_servers_app(IntPtr thiz, IntPtr servers);

		/// <summary>
		/// Forces liblinphone to use the supplied list of dns servers, instead of
		/// system&apos;s ones and set dns_set_by_app at true or false according to value
		/// of servers list. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="servers">A list of strings containing the IP addresses of DNS
		/// servers to be used.   Setting to null restores default behaviour, which is to
		/// use the DNS server list provided by the system. The list is copied internally. 
		///   </param>
		public IEnumerable<string> DnsServersApp
		{
			set
			{
				linphone_core_set_dns_servers_app(nativePtr, StringArrayToBctbxList(value));
				CleanStringArrayPtrs();
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_dns_set_by_app(IntPtr thiz);

		/// <summary>
		/// Tells if the DNS was set by an application. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if DNS was set by app, false otherwise. </returns>
		public bool DnsSetByApp
		{
			get
			{
				return linphone_core_get_dns_set_by_app(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_dns_srv_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_dns_srv(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether DNS SRV resolution is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if DNS SRV resolution is enabled, false if disabled. </returns>
		public bool DnsSrvEnabled
		{
			get
			{
				return linphone_core_dns_srv_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_dns_srv(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_download_bandwidth(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_download_bandwidth(IntPtr thiz, int bandwidth);

		/// <summary>
		/// Retrieve the maximum available download bandwidth. 
		/// <para>
		/// This value was set by <see cref="Linphone.Core.DownloadBandwidth">
		/// Linphone.Core.DownloadBandwidth</see>. 
		/// </para>
		/// </summary>
		/// <returns>the download bandiwdth in kbits/s, 0 for infinite </returns>
		public int DownloadBandwidth
		{
			get
			{
				return linphone_core_get_download_bandwidth(nativePtr);
			}
			set
			{
				linphone_core_set_download_bandwidth(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_download_ptime(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_download_ptime(IntPtr thiz, int ptime);

		/// <summary>
		/// Get audio packetization time linphone expects to receive from peer. 
		/// <para>
		/// A value of zero means that ptime is not specified. 
		/// </para>
		/// </summary>
		/// <returns>the download packetization time set </returns>
		public int DownloadPtime
		{
			get
			{
				return linphone_core_get_download_ptime(nativePtr);
			}
			set
			{
				linphone_core_set_download_ptime(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_echo_cancellation_calibration(IntPtr thiz);

		/// <summary>
		/// Gets the currently stored calibration delay for the software echo cancellation. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the current calibration value, -1 if it failed, 0 if not done or not
		/// needed, a positive value if a software echo canceller is required after running
		/// <see cref="Linphone.Core.StartEchoCancellerCalibration()">
		/// Linphone.Core.StartEchoCancellerCalibration()</see>. </returns>
		public int EchoCancellationCalibration
		{
			get
			{
				return linphone_core_get_echo_cancellation_calibration(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_echo_cancellation_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_echo_cancellation(IntPtr thiz, char enable);

		/// <summary>
		/// Returns true if echo cancellation is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether echo cancellation is enabled or
		/// disabled </returns>
		public bool EchoCancellationEnabled
		{
			get
			{
				return linphone_core_echo_cancellation_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_echo_cancellation(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_echo_canceller_filter_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_echo_canceller_filter_name(IntPtr thiz, string filtername);

		/// <summary>
		/// Get the name of the mediastreamer2 filter used for echo cancelling. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The name of the mediastreamer2 filter used for echo cancelling.   
		/// </returns>
		public string EchoCancellerFilterName
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_echo_canceller_filter_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_echo_canceller_filter_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_echo_limiter_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_echo_limiter(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether echo limiter is enabled. 
		/// <para>
		/// Enables or disable echo limiter. &quot;Echo limiter&quot; refers to an
		/// algorithm that creates half-duplex conversation in order to suppress echo. It
		/// is experimental and shall be used only in rare cases where echo cancellation
		/// cannot perform because of non-linear speaker/mic coupling. You shall not
		/// expected good audio quality with the echo limiter. 
		/// </para>
		/// </summary>
		/// <returns>true if the echo limiter is enabled, false otherwise. </returns>
		public bool EchoLimiterEnabled
		{
			get
			{
				return linphone_core_echo_limiter_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_echo_limiter(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_enable_sip_update(IntPtr thiz, int val);

		/// <summary>
		/// Enable or disable the UPDATE method support. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="val">Enable or disable it </param>
		public int EnableSipUpdate
		{
			set
			{
				linphone_core_set_enable_sip_update(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_expected_bandwidth(IntPtr thiz, int bandwidth);

		/// <summary>
		/// Sets expected available upload bandwidth This is IP bandwidth, in kbit/s. 
		/// <para>
		/// This information is used by liblinphone together with remote side available
		/// bandwidth signaled in SDP messages to properly configure audio &amp; video
		/// codec&apos;s output bitrate.
		/// </para>
		/// </summary>
		/// <param name="bandwidth">the bandwidth in kbits/s, 0 for infinite </param>
		public int ExpectedBandwidth
		{
			set
			{
				linphone_core_set_expected_bandwidth(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_extended_audio_devices(IntPtr thiz);

		/// <summary>
		/// Returns the list of all audio devices. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>  A list of all <see cref="Linphone.AudioDevice">
		/// Linphone.AudioDevice</see>       </returns>
		public IEnumerable<Linphone.AudioDevice> ExtendedAudioDevices
		{
			get
			{
				return MarshalBctbxList<Linphone.AudioDevice>(linphone_core_get_extended_audio_devices(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_file_transfer_server(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_file_transfer_server(IntPtr thiz, string serverUrl);

		/// <summary>
		/// Get the globaly set http file transfer server to be used for content type
		/// application/vnd.gsma.rcs-ft-http+xml. 
		/// <para>
		/// Url may be like: &quot;https://file.linphone.org/upload.php&quot;. 
		/// </para>
		/// </summary>
		/// <returns>URL of the file server.    </returns>
		public string FileTransferServer
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_file_transfer_server(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_file_transfer_server(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_forced_ice_relay_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_forced_ice_relay(IntPtr thiz, char enable);

		/// <summary>
		/// Indicates whether the ICE relay path is forcibly selected. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a boolean value indicating whether forced relay is enabled.</returns>
		/// <remarks>See : <see cref="Linphone.Core.EnableForcedIceRelay()">
		/// Linphone.Core.EnableForcedIceRelay()</see>. </remarks>
		public bool ForcedIceRelayEnabled
		{
			get
			{
				return linphone_core_forced_ice_relay_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_forced_ice_relay(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_friend_list_subscription_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_friend_list_subscription(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether or not friend lists subscription are enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>whether or not the feature is enabled </returns>
		public bool FriendListSubscriptionEnabled
		{
			get
			{
				return linphone_core_friend_list_subscription_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_friend_list_subscription(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_friends_database_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_friends_database_path(IntPtr thiz, string path);

		/// <summary>
		/// Gets the database filename where friends will be stored. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>filesystem path.    </returns>
		public string FriendsDatabasePath
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_friends_database_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_friends_database_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_friends_lists(IntPtr thiz);

		/// <summary>
		/// Retrieves the list of <see cref="Linphone.FriendList">Linphone.FriendList</see>
		/// from the core. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of <see cref="Linphone.FriendList">Linphone.FriendList</see>.  
		///    </returns>
		public IEnumerable<Linphone.FriendList> FriendsLists
		{
			get
			{
				return MarshalBctbxList<Linphone.FriendList>(linphone_core_get_friends_lists(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_future_conference_information_list(IntPtr thiz);

		/// <summary>
		/// Retrieve the list of future conference information on DB. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The list of future conference infos  .       </returns>
		public IEnumerable<Linphone.ConferenceInfo> FutureConferenceInformationList
		{
			get
			{
				return MarshalBctbxList<Linphone.ConferenceInfo>(linphone_core_get_future_conference_information_list(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_generic_comfort_noise_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_generic_comfort_noise(IntPtr thiz, char enabled);

		/// <summary>
		/// Returns enablement of RFC3389 generic comfort noise algorithm. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if generic comfort noise is enabled, false otherwise. </returns>
		public bool GenericComfortNoiseEnabled
		{
			get
			{
				return linphone_core_generic_comfort_noise_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_generic_comfort_noise(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.GlobalState linphone_core_get_global_state(IntPtr thiz);

		/// <summary>
		/// Returns the global state of core. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.GlobalState">Linphone.GlobalState</see> enum.   
		/// </returns>
		public Linphone.GlobalState GlobalState
		{
			get
			{
				return linphone_core_get_global_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_guess_hostname(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_guess_hostname(IntPtr thiz, char enable);

		/// <summary>
		/// Returns true if hostname part of primary contact is guessed automatically. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if guess hostname enabled, false otherwise. </returns>
		public bool GuessHostname
		{
			get
			{
				return linphone_core_get_guess_hostname(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_guess_hostname(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_http_proxy_host(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_http_proxy_host(IntPtr thiz, string host);

		/// <summary>
		/// Get http proxy address to be used for signaling. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>hostname of IP adress of the http proxy (can be null to disable).   
		/// </returns>
		public string HttpProxyHost
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_http_proxy_host(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_http_proxy_host(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_http_proxy_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_http_proxy_port(IntPtr thiz, int port);

		/// <summary>
		/// Get http proxy port to be used for signaling. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>port of the http proxy. </returns>
		public int HttpProxyPort
		{
			get
			{
				return linphone_core_get_http_proxy_port(nativePtr);
			}
			set
			{
				linphone_core_set_http_proxy_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_identity(IntPtr thiz);

		/// <summary>
		/// Gets the default identity SIP address. 
		/// <para>
		/// This is an helper function. If no default proxy is set, this will return the
		/// primary contact ( see <see cref="Linphone.Core.PrimaryContact">
		/// Linphone.Core.PrimaryContact</see> ). If a default proxy is set it returns the
		/// registered identity on the proxy. 
		/// </para>
		/// </summary>
		/// <returns>The default identity SIP address.    </returns>
		public string Identity
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_identity(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_im_notif_policy(IntPtr thiz);

		/// <summary>
		/// Get the <see cref="Linphone.ImNotifPolicy">Linphone.ImNotifPolicy</see> object
		/// controlling the instant messaging notifications. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.ImNotifPolicy">Linphone.ImNotifPolicy</see>
		/// object.    </returns>
		public Linphone.ImNotifPolicy ImNotifPolicy
		{
			get
			{
				IntPtr ptr = linphone_core_get_im_notif_policy(nativePtr);
				Linphone.ImNotifPolicy obj = fromNativePtr<Linphone.ImNotifPolicy>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_in_call_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_in_call_timeout(IntPtr thiz, int seconds);

		/// <summary>
		/// Gets the in call timeout See <see cref="Linphone.Core.InCallTimeout">
		/// Linphone.Core.InCallTimeout</see> for details. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current in call timeout in seconds </returns>
		public int InCallTimeout
		{
			get
			{
				return linphone_core_get_in_call_timeout(nativePtr);
			}
			set
			{
				linphone_core_set_in_call_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_inc_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_inc_timeout(IntPtr thiz, int seconds);

		/// <summary>
		/// Returns the incoming call timeout See <see cref="Linphone.Core.IncTimeout">
		/// Linphone.Core.IncTimeout</see> for details. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current incoming call timeout in seconds </returns>
		public int IncTimeout
		{
			get
			{
				return linphone_core_get_inc_timeout(nativePtr);
			}
			set
			{
				linphone_core_set_inc_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_input_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_input_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the input audio device for the current call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The input audio device for the current or first call, null if there is
		/// no call.    </returns>
		public Linphone.AudioDevice InputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_core_get_input_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_input_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_ipv6_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_ipv6(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether IPv6 is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether IPv6 is enabled or not</returns>
		/// <remarks>See : <see cref="Linphone.Core.EnableIpv6()">
		/// Linphone.Core.EnableIpv6()</see> for more details on how IPv6 is supported in
		/// liblinphone. </remarks>
		public bool Ipv6Enabled
		{
			get
			{
				return linphone_core_ipv6_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_ipv6(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_auto_download_icalendars_enabled(IntPtr thiz);

		/// <summary>
		/// Gets if the auto download for incoming icalendars is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if icalendars will be automatically downloaded, false
		/// otherwise.</returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.Core.AutoDownloadIcalendarsEnabled()">
		/// Linphone.Core.AutoDownloadIcalendarsEnabled()</see> instead. 
		public bool IsAutoDownloadIcalendarsEnabled
		{
			get
			{
				return linphone_core_is_auto_download_icalendars_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_auto_download_voice_recordings_enabled(IntPtr thiz);

		/// <summary>
		/// Gets if the auto download for incoming voice recordings is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if voice recordings will be automatically downloaded, false
		/// otherwise.</returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.Core.AutoDownloadVoiceRecordingsEnabled()">
		/// Linphone.Core.AutoDownloadVoiceRecordingsEnabled()</see> instead. 
		public bool IsAutoDownloadVoiceRecordingsEnabled
		{
			get
			{
				return linphone_core_is_auto_download_voice_recordings_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_auto_iterate_enabled(IntPtr thiz);

		/// <summary>
		/// Gets whether auto iterate is enabled or not (Android &amp; iOS only). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if <see cref="Linphone.Core.Iterate()">
		/// Linphone.Core.Iterate()</see> is scheduled automatically, false
		/// otherwise</returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.Core.AutoIterateEnabled()">
		/// Linphone.Core.AutoIterateEnabled()</see> instead. 
		public bool IsAutoIterateEnabled
		{
			get
			{
				return linphone_core_is_auto_iterate_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_echo_canceller_calibration_required(IntPtr thiz);

		/// <summary>
		/// Check whether the device is echo canceller calibration is required. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if it is required, false otherwise </returns>
		public bool IsEchoCancellerCalibrationRequired
		{
			get
			{
				return linphone_core_is_echo_canceller_calibration_required(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_friend_list_subscription_enabled(IntPtr thiz);

		/// <summary>
		/// Returns whether or not friend lists subscription are enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>whether or not the feature is enabled </returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.Core.FriendListSubscriptionEnabled()">
		/// Linphone.Core.FriendListSubscriptionEnabled()</see> instead. 
		public bool IsFriendListSubscriptionEnabled
		{
			get
			{
				return linphone_core_is_friend_list_subscription_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_in_background(IntPtr thiz);

		/// <summary>
		/// Gets whether the Core is considering itself in background or not. 
		/// <para>
		/// The Core foreground/background state depends on the last call made to <see cref="Linphone.Core.EnterBackground()">
		/// Linphone.Core.EnterBackground()</see> or <see cref="Linphone.Core.EnterForeground()">
		/// Linphone.Core.EnterForeground()</see>. 
		/// </para>
		/// </summary>
		/// <returns>true if the Core is in background, false otherwise. </returns>
		public bool IsInBackground
		{
			get
			{
				return linphone_core_is_in_background(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_in_conference(IntPtr thiz);

		/// <summary>
		/// Indicates whether the local participant is part of a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : That function automatically fails in the case of conferences
		/// using a conferencet server (focus). If you use such a conference, you should
		/// use <see cref="Linphone.Conference.RemoveParticipant()">
		/// Linphone.Conference.RemoveParticipant()</see> instead. </remarks> 
		/// <returns>true if the local participant is in a conference, false otherwise.
		/// </returns>
		/// deprecated : 09/03/2021 Use <see cref="Linphone.Conference.IsIn()">
		/// Linphone.Conference.IsIn()</see> instead. 
		public bool IsInConference
		{
			get
			{
				return linphone_core_is_in_conference(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_incoming_invite_pending(IntPtr thiz);

		/// <summary>
		/// Tells whether there is an incoming invite pending. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean telling whether an incoming invite is pending or not.
		/// </returns>
		public bool IsIncomingInvitePending
		{
			get
			{
				return linphone_core_is_incoming_invite_pending(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_media_encryption_mandatory(IntPtr thiz);

		/// <summary>
		/// Check if the configured media encryption is mandatory or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if media encryption is mandatory; false otherwise. </returns>
		public bool IsMediaEncryptionMandatory
		{
			get
			{
				return linphone_core_is_media_encryption_mandatory(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_native_ringing_enabled(IntPtr thiz);

		/// <summary>
		/// Returns whether the native ringing is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>True if we use the native ringing, false otherwise</returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.Core.NativeRingingEnabled()">
		/// Linphone.Core.NativeRingingEnabled()</see> instead. 
		public bool IsNativeRingingEnabled
		{
			get
			{
				return linphone_core_is_native_ringing_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_network_reachable(IntPtr thiz);

		/// <summary>
		/// return network state either as positioned by the application or by linphone
		/// itself. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if network is reachable, false otherwise </returns>
		public bool IsNetworkReachable
		{
			get
			{
				return linphone_core_is_network_reachable(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_push_notification_available(IntPtr thiz);

		/// <summary>
		/// Gets whether push notifications are available or not (Android &amp; iOS only). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if push notifications are available, false otherwise </returns>
		public bool IsPushNotificationAvailable
		{
			get
			{
				return linphone_core_is_push_notification_available(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_push_notification_enabled(IntPtr thiz);

		/// <summary>
		/// Gets whether push notifications are enabled or not (Android &amp; iOS only). 
		/// <para>
		/// If not, the app will have to handle all the push-related settings for each
		/// accounts 
		/// </para>
		/// </summary>
		/// <returns>true if push notifications are enabled, false otherwise</returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.Core.PushNotificationEnabled()">
		/// Linphone.Core.PushNotificationEnabled()</see> instead. 
		public bool IsPushNotificationEnabled
		{
			get
			{
				return linphone_core_is_push_notification_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_record_aware_enabled(IntPtr thiz);

		/// <summary>
		/// Gets if the record aware feature is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the record aware feature is enabled, false otherwise.
		/// </returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.Core.RecordAwareEnabled()">
		/// Linphone.Core.RecordAwareEnabled()</see> instead. 
		public bool IsRecordAwareEnabled
		{
			get
			{
				return linphone_core_is_record_aware_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_sender_name_hidden_in_forward_message(IntPtr thiz);

		/// <summary>
		/// Returns whether or not sender name is hidden in forward message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>whether or not the feature </returns>
		public bool IsSenderNameHiddenInForwardMessage
		{
			get
			{
				return linphone_core_is_sender_name_hidden_in_forward_message(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_verify_server_certificates(IntPtr thiz);

		/// <summary>
		/// Get whether the tls server certificate must be verified when connecting to a
		/// SIP/TLS server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>True if the tls server certificate must be verified </returns>
		public bool IsVerifyServerCertificates
		{
			get
			{
				return linphone_core_is_verify_server_certificates(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_verify_server_cn(IntPtr thiz);

		/// <summary>
		/// Get whether the tls server certificate common name must be verified when
		/// connecting to a SIP/TLS server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>True if the tls server certificate common name must be verified
		/// </returns>
		public bool IsVerifyServerCn
		{
			get
			{
				return linphone_core_is_verify_server_cn(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_vibration_on_incoming_call_enabled(IntPtr thiz);

		/// <summary>
		/// Gets whether the device will vibrate while an incoming call is ringing (Android
		/// only). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the device will vibrate (if possible), false
		/// otherwise</returns>
		/// deprecated : 16/12/2021 Use <see cref="Linphone.Core.VibrationOnIncomingCallEnabled()">
		/// Linphone.Core.VibrationOnIncomingCallEnabled()</see> instead. 
		public bool IsVibrationOnIncomingCallEnabled
		{
			get
			{
				return linphone_core_is_vibration_on_incoming_call_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_keep_alive_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_keep_alive(IntPtr thiz, char enable);

		/// <summary>
		/// Is signaling keep alive enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether signaling keep alive is enabled
		/// </returns>
		public bool KeepAliveEnabled
		{
			get
			{
				return linphone_core_keep_alive_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_keep_alive(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_label(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_label(IntPtr thiz, string label);

		/// <summary>
		/// Get the label assigned to the LinphoneCore. 
		/// <para>
		/// The default value is null (no label). 
		/// </para>
		/// </summary>
		/// <returns>the assigned label. </returns>
		public string Label
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_label(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_label(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_last_outgoing_call_log(IntPtr thiz);

		/// <summary>
		/// Get the latest outgoing call log. 
		/// <para>
		/// Conference calls are not returned by this function! Requires ENABLE_DB_STORAGE
		/// to work. 
		/// </para>
		/// </summary>
		/// <returns>The last outgoing call log if any.    </returns>
		public Linphone.CallLog LastOutgoingCallLog
		{
			get
			{
				IntPtr ptr = linphone_core_get_last_outgoing_call_log(nativePtr);
				Linphone.CallLog obj = fromNativePtr<Linphone.CallLog>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_ldap_list(IntPtr thiz);

		/// <summary>
		/// Returns a list of entered LDAPs. 
		/// <para>
		/// Items must be freed with linphone_ldap_unref 
		/// </para>
		/// </summary>
		/// <returns>        </returns>
		public IEnumerable<Linphone.Ldap> LdapList
		{
			get
			{
				return MarshalBctbxList<Linphone.Ldap>(linphone_core_get_ldap_list(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_lime_x3dh_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_lime_x3dh(IntPtr thiz, char enable);

		/// <summary>
		/// Tells wether LIME X3DH is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current lime state </returns>
		public bool LimeX3DhEnabled
		{
			get
			{
				return linphone_core_lime_x3dh_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_lime_x3dh(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_lime_x3dh_server_url(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_lime_x3dh_server_url(IntPtr thiz, string url);

		/// <summary>
		/// Get the x3dh server url. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The x3dh server url.   </returns>
		/// deprecated : 26/08/2022 Use <see cref="Linphone.AccountParams.LimeServerUrl">
		/// Linphone.AccountParams.LimeServerUrl</see> instead. 
		public string LimeX3DhServerUrl
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_lime_x3dh_server_url(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_lime_x3dh_server_url(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_linphone_specs_list(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_linphone_specs_list(IntPtr thiz, IntPtr specs);

		/// <summary>
		/// Get the list of linphone specs string values representing what functionalities
		/// the linphone client supports. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of supported specs. The list must be freed with
		/// bctbx_list_free() after usage.         </returns>
		public IEnumerable<string> LinphoneSpecsList
		{
			get
			{
				return MarshalStringArray(linphone_core_get_linphone_specs_list(nativePtr));
			}
			set
			{
				linphone_core_set_linphone_specs_list(nativePtr, StringArrayToBctbxList(value));
				CleanStringArrayPtrs();
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_loaded_plugins(IntPtr thiz);

		/// <summary>
		/// Return the list of loaded plugins. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the list of loaded plugins      </returns>
		public IEnumerable<string> LoadedPlugins
		{
			get
			{
				return MarshalStringArray(linphone_core_get_loaded_plugins(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_local_permission_enabled(IntPtr thiz);

		/// <summary>
		/// Special function to check if the local network permission has been granted by
		/// the user (useful for iOS). 
		/// <para>
		/// The test performed by this function may popup the local network permission
		/// dialog, for that reason it could be a good idea to check it twice to conclude
		/// that the user has deny the permission. 
		/// </para>
		/// </summary>
		/// <returns>true if local permission request is granted, false otherwise.
		/// </returns>
		public bool LocalPermissionEnabled
		{
			get
			{
				return linphone_core_local_permission_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_log_collection_upload_server_url(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_log_collection_upload_server_url(IntPtr thiz, string serverUrl);

		/// <summary>
		/// Gets the url of the server where to upload the collected log files. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The url of the server where to upload the collected log files.   
		/// </returns>
		public string LogCollectionUploadServerUrl
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_log_collection_upload_server_url(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_log_collection_upload_server_url(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_max_calls(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_max_calls(IntPtr thiz, int max);

		/// <summary>
		/// Get the maximum number of simultaneous calls Linphone core can manage at a
		/// time. 
		/// <para>
		/// All new call above this limit are declined with a busy answer 
		/// </para>
		/// </summary>
		/// <returns>max number of simultaneous calls </returns>
		public int MaxCalls
		{
			get
			{
				return linphone_core_get_max_calls(nativePtr);
			}
			set
			{
				linphone_core_set_max_calls(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_max_size_for_auto_download_incoming_files(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_max_size_for_auto_download_incoming_files(IntPtr thiz, int size);

		/// <summary>
		/// Gets the size under which incoming files in chat messages will be downloaded
		/// automatically. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The size in bytes, -1 if autodownload feature is disabled, 0 to
		/// download them all no matter the size </returns>
		public int MaxSizeForAutoDownloadIncomingFiles
		{
			get
			{
				return linphone_core_get_max_size_for_auto_download_incoming_files(nativePtr);
			}
			set
			{
				linphone_core_set_max_size_for_auto_download_incoming_files(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_media_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_media_device(IntPtr thiz, string devid);

		/// <summary>
		/// Gets the name of the currently assigned sound device for media. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The name of the currently assigned sound device for capture.   
		/// </returns>
		public string MediaDevice
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_media_device(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_media_device(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("MediaDevice setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.MediaEncryption linphone_core_get_media_encryption(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_media_encryption(IntPtr thiz, int menc);

		/// <summary>
		/// Get the media encryption policy being used for RTP packets. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.MediaEncryption">
		/// Linphone.MediaEncryption</see> policy being used. </returns>
		public Linphone.MediaEncryption MediaEncryption
		{
			get
			{
				return linphone_core_get_media_encryption(nativePtr);
			}
			set
			{
				int exception_result = linphone_core_set_media_encryption(nativePtr, (int)value);
				if (exception_result != 0) throw new LinphoneException("MediaEncryption setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_media_encryption_mandatory(IntPtr thiz, char mandatory);

		/// <summary>
		/// Define whether the configured media encryption is mandatory, if it is and the
		/// negotation cannot result in the desired media encryption then the call will
		/// fail. 
		/// <para>
		/// If not an INVITE will be resent with encryption disabled. 
		/// </para>
		/// </summary>
		/// <param name="mandatory">true to set it mandatory; false otherwise. </param>
		public bool MediaEncryptionMandatory
		{
			set
			{
				linphone_core_set_media_encryption_mandatory(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_media_network_reachable(IntPtr thiz, char reachable);

		/// <summary>
		/// This method is called by the application to notify the linphone core library
		/// when the media (RTP) network is reachable. 
		/// <para>
		/// This is for advanced usage, when SIP and RTP layers are required to use
		/// different interfaces. Most applications just need <see cref="Linphone.Core.NetworkReachable">
		/// Linphone.Core.NetworkReachable</see>.
		/// </para>
		/// </summary>
		/// <param name="reachable">true if network is reachable, false otherwise </param>
		public bool MediaNetworkReachable
		{
			set
			{
				linphone_core_set_media_network_reachable(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.MediaResourceMode linphone_core_get_media_resource_mode(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_media_resource_mode(IntPtr thiz, int mode);

		/// <summary>
		/// This function returns the media resource mode for this core. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The media resource mode </returns>
		public Linphone.MediaResourceMode MediaResourceMode
		{
			get
			{
				return linphone_core_get_media_resource_mode(nativePtr);
			}
			set
			{
				linphone_core_set_media_resource_mode(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_mic_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_mic(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether the microphone is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the microphone is enabled, false if disabled. </returns>
		public bool MicEnabled
		{
			get
			{
				return linphone_core_mic_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_mic(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_core_get_mic_gain_db(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_mic_gain_db(IntPtr thiz, float level);

		/// <summary>
		/// Get microphone gain in db. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current microphone gain </returns>
		public float MicGainDb
		{
			get
			{
				return linphone_core_get_mic_gain_db(nativePtr);
			}
			set
			{
				linphone_core_set_mic_gain_db(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_missed_calls_count(IntPtr thiz);

		/// <summary>
		/// Get the number of missed calls. 
		/// <para>
		/// Once checked, this counter can be reset with <see cref="Linphone.Core.ResetMissedCallsCount()">
		/// Linphone.Core.ResetMissedCallsCount()</see>. 
		/// </para>
		/// </summary>
		/// <returns>The number of missed calls. </returns>
		public int MissedCallsCount
		{
			get
			{
				return linphone_core_get_missed_calls_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_mtu(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_mtu(IntPtr thiz, int mtu);

		/// <summary>
		/// Returns the maximum transmission unit size in bytes. 
		/// <para>
		/// </para>
		/// </summary>
		public int Mtu
		{
			get
			{
				return linphone_core_get_mtu(nativePtr);
			}
			set
			{
				linphone_core_set_mtu(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_nat_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_nat_address(IntPtr thiz, string addr);

		/// <summary>
		/// Deprecated. 
		/// <para>
		/// Get the public IP address of NAT being used. 
		/// </para>
		/// </summary>
		/// <returns>The public IP address of NAT being used.    </returns>
		/// deprecated : 12/10/2022
		public string NatAddress
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_nat_address(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_nat_address(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_nat_policy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_nat_policy(IntPtr thiz, IntPtr policy);

		/// <summary>
		/// Get The policy that is used to pass through NATs/firewalls. 
		/// <para>
		/// It may be overridden by a NAT policy for a specific proxy config. 
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.NatPolicy">Linphone.NatPolicy</see> object in use.
		///   </returns>
		/// <remarks>See : <see cref="Linphone.AccountParams.NatPolicy">
		/// Linphone.AccountParams.NatPolicy</see> </remarks>
		public Linphone.NatPolicy NatPolicy
		{
			get
			{
				IntPtr ptr = linphone_core_get_nat_policy(nativePtr);
				Linphone.NatPolicy obj = fromNativePtr<Linphone.NatPolicy>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_nat_policy(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_native_ringing_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_native_ringing(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether the native ringing is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>True if we use the native ringing, false otherwise </returns>
		public bool NativeRingingEnabled
		{
			get
			{
				return linphone_core_native_ringing_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_native_ringing(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_network_reachable(IntPtr thiz, char reachable);

		/// <summary>
		/// This method is called by the application to notify the linphone core library
		/// when network is reachable. 
		/// <para>
		/// Calling this method with true trigger linphone to initiate a registration
		/// process for all proxies. Calling this method disables the automatic network
		/// detection mode. It means you must call this method after each network state
		/// changes.
		/// </para>
		/// </summary>
		/// <param name="reachable">true if network is reachable, false otherwise </param>
		public bool NetworkReachable
		{
			set
			{
				linphone_core_set_network_reachable(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_nortp_onhold_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_nortp_onhold_timeout(IntPtr thiz, int seconds);

		/// <summary>
		/// Gets the value of the no-rtp timeout when the call is on hold. 
		/// <para>
		/// When no RTP or RTCP packets have been received for a while when the call is on
		/// hold <see cref="Linphone.Core">Linphone.Core</see> will consider the call is
		/// broken (remote end crashed or disconnected from the network), and thus will
		/// terminate the call. The no-rtp timeout is the duration above which the call is
		/// considered broken. 
		/// </para>
		/// </summary>
		/// <returns>The value of the no-rtp timeout in seconds when the call is on hold
		/// </returns>
		public int NortpOnholdTimeout
		{
			get
			{
				return linphone_core_get_nortp_onhold_timeout(nativePtr);
			}
			set
			{
				linphone_core_set_nortp_onhold_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_nortp_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_nortp_timeout(IntPtr thiz, int seconds);

		/// <summary>
		/// Gets the value of the no-rtp timeout. 
		/// <para>
		/// When no RTP or RTCP packets have been received for a while <see cref="Linphone.Core">
		/// Linphone.Core</see> will consider the call is broken (remote end crashed or
		/// disconnected from the network), and thus will terminate the call. The no-rtp
		/// timeout is the duration above which the call is considered broken. 
		/// </para>
		/// </summary>
		/// <returns>The value of the no-rtp timeout in seconds </returns>
		public int NortpTimeout
		{
			get
			{
				return linphone_core_get_nortp_timeout(nativePtr);
			}
			set
			{
				linphone_core_set_nortp_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_output_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_output_audio_device(IntPtr thiz, IntPtr audioDevice);

		/// <summary>
		/// Gets the output audio device for the current call. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The output audio device for the current or first call, null if there
		/// is no call.    </returns>
		public Linphone.AudioDevice OutputAudioDevice
		{
			get
			{
				IntPtr ptr = linphone_core_get_output_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_output_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_play_file(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_play_file(IntPtr thiz, string file);

		/// <summary>
		/// Get the wav file that is played when putting somebody on hold, or when files
		/// are used instead of soundcards (see <see cref="Linphone.Core.UseFiles">
		/// Linphone.Core.UseFiles</see>). 
		/// <para>
		/// The file is a 16 bit linear wav file. 
		/// </para>
		/// </summary>
		/// <returns>The path to the file that is played when putting somebody on hold.   
		/// </returns>
		public string PlayFile
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_play_file(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_play_file(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_playback_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_playback_device(IntPtr thiz, string devid);

		/// <summary>
		/// Gets the name of the currently assigned sound device for playback. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The name of the currently assigned sound device for playback.   
		/// </returns>
		public string PlaybackDevice
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_playback_device(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_playback_device(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("PlaybackDevice setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_core_get_playback_gain_db(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_playback_gain_db(IntPtr thiz, float level);

		/// <summary>
		/// Get playback gain in db before entering sound card. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current playback gain </returns>
		public float PlaybackGainDb
		{
			get
			{
				return linphone_core_get_playback_gain_db(nativePtr);
			}
			set
			{
				linphone_core_set_playback_gain_db(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_core_get_preferred_framerate(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_preferred_framerate(IntPtr thiz, float fps);

		/// <summary>
		/// Returns the preferred video framerate, previously set by <see cref="Linphone.Core.PreferredFramerate">
		/// Linphone.Core.PreferredFramerate</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>frame rate in number of frames per seconds. </returns>
		public float PreferredFramerate
		{
			get
			{
				return linphone_core_get_preferred_framerate(nativePtr);
			}
			set
			{
				linphone_core_set_preferred_framerate(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_preferred_video_definition(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_preferred_video_definition(IntPtr thiz, IntPtr videoDefinition);

		/// <summary>
		/// Get the preferred video definition for the stream that is captured and sent to
		/// the remote party. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The preferred <see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see>    </returns>
		public Linphone.VideoDefinition PreferredVideoDefinition
		{
			get
			{
				IntPtr ptr = linphone_core_get_preferred_video_definition(nativePtr);
				Linphone.VideoDefinition obj = fromNativePtr<Linphone.VideoDefinition>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_preferred_video_definition(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_preferred_video_definition_by_name(IntPtr thiz, string name);

		/// <summary>
		/// Sets the preferred video definition by its name. 
		/// <para>
		/// Call <see cref="Linphone.Factory.SupportedVideoDefinitions">
		/// Linphone.Factory.SupportedVideoDefinitions</see> to have a list of supported
		/// video definitions.
		/// </para>
		/// </summary>
		/// <param name="name">The name of the definition to set    </param>
		public string PreferredVideoDefinitionByName
		{
			set
			{
				linphone_core_set_preferred_video_definition_by_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_presence_model(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_presence_model(IntPtr thiz, IntPtr presence);

		/// <summary>
		/// Get my presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.PresenceModel">Linphone.PresenceModel</see>
		/// object, or null if no presence model has been set.    </returns>
		public Linphone.PresenceModel PresenceModel
		{
			get
			{
				IntPtr ptr = linphone_core_get_presence_model(nativePtr);
				Linphone.PresenceModel obj = fromNativePtr<Linphone.PresenceModel>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_presence_model(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_preview_video_definition(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_preview_video_definition(IntPtr thiz, IntPtr videoDefinition);

		/// <summary>
		/// Get the definition of the captured video. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The captured <see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see> if it was previously set by <see cref="Linphone.Core.PreviewVideoDefinition">
		/// Linphone.Core.PreviewVideoDefinition</see>, otherwise a 0x0
		/// LinphoneVideoDefinition.    </returns>
		/// <remarks>See : <see cref="Linphone.Core.PreviewVideoDefinition">
		/// Linphone.Core.PreviewVideoDefinition</see> </remarks>
		public Linphone.VideoDefinition PreviewVideoDefinition
		{
			get
			{
				IntPtr ptr = linphone_core_get_preview_video_definition(nativePtr);
				Linphone.VideoDefinition obj = fromNativePtr<Linphone.VideoDefinition>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_preview_video_definition(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_preview_video_definition_by_name(IntPtr thiz, string name);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">The name of the definition to set    </param>
		public string PreviewVideoDefinitionByName
		{
			set
			{
				linphone_core_set_preview_video_definition_by_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_primary_contact(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_primary_contact(IntPtr thiz, string contact);

		/// <summary>
		/// Returns the default identity when no proxy configuration is used. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the primary contact identity    </returns>
		public string PrimaryContact
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_primary_contact(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_primary_contact(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("PrimaryContact setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_primary_contact_parsed(IntPtr thiz);

		/// <summary>
		/// Same as <see cref="Linphone.Core.PrimaryContact">
		/// Linphone.Core.PrimaryContact</see> but the result is a <see cref="Linphone.Address">
		/// Linphone.Address</see> object instead of const char *. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Address">Linphone.Address</see> object.     
		/// </returns>
		/// deprecated : 22/10/2018 Use <see cref="Linphone.Core.CreatePrimaryContactParsed()">
		/// Linphone.Core.CreatePrimaryContactParsed()</see> instead. 
		public Linphone.Address PrimaryContactParsed
		{
			get
			{
				IntPtr ptr = linphone_core_get_primary_contact_parsed(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_provisioning_uri(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_provisioning_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Get provisioning URI. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the provisioning URI.    </returns>
		public string ProvisioningUri
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_provisioning_uri(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_provisioning_uri(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("ProvisioningUri setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_proxy_config_list(IntPtr thiz);

		/// <summary>
		/// Returns an unmodifiable list of entered proxy configurations. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of <see cref="Linphone.ProxyConfig">Linphone.ProxyConfig</see>.
		///      </returns>
		public IEnumerable<Linphone.ProxyConfig> ProxyConfigList
		{
			get
			{
				return MarshalBctbxList<Linphone.ProxyConfig>(linphone_core_get_proxy_config_list(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_push_incoming_call_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_push_incoming_call_timeout(IntPtr thiz, int seconds);

		/// <summary>
		/// Returns the push incoming call timeout See <see cref="Linphone.Core.PushIncomingCallTimeout">
		/// Linphone.Core.PushIncomingCallTimeout</see> for details. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current push incoming call timeout in seconds </returns>
		public int PushIncomingCallTimeout
		{
			get
			{
				return linphone_core_get_push_incoming_call_timeout(nativePtr);
			}
			set
			{
				linphone_core_set_push_incoming_call_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_push_notification_config(IntPtr thiz);

		/// <summary>
		/// Gets the push notification configuration object if it exists. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.PushNotificationConfig">
		/// Linphone.PushNotificationConfig</see> if it exists, null otherwise.   
		/// </returns>
		public Linphone.PushNotificationConfig PushNotificationConfig
		{
			get
			{
				IntPtr ptr = linphone_core_get_push_notification_config(nativePtr);
				Linphone.PushNotificationConfig obj = fromNativePtr<Linphone.PushNotificationConfig>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_push_notification_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_push_notification(IntPtr thiz, char enable);

		/// <summary>
		/// Gets whether push notifications are enabled or not (Android &amp; iOS only). 
		/// <para>
		/// If not, the app will have to handle all the push-related settings for each
		/// accounts 
		/// </para>
		/// </summary>
		/// <returns>true if push notifications are enabled, false otherwise </returns>
		public bool PushNotificationEnabled
		{
			get
			{
				return linphone_core_push_notification_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_push_notification(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_qrcode_video_preview_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_qrcode_video_preview(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether QRCode is enabled in the preview. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether QRCode is enabled in the preview.
		/// </returns>
		public bool QrcodeVideoPreviewEnabled
		{
			get
			{
				return linphone_core_qrcode_video_preview_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_qrcode_video_preview(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_realtime_text_enabled(IntPtr thiz);

		/// <summary>
		/// Gets if realtime text is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if realtime text is enabled, false otherwise </returns>
		public bool RealtimeTextEnabled
		{
			get
			{
				return linphone_core_realtime_text_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_record_aware_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_record_aware(IntPtr thiz, char enable);

		/// <summary>
		/// Gets if the record aware feature is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the record aware feature is enabled, false otherwise.
		/// </returns>
		public bool RecordAwareEnabled
		{
			get
			{
				return linphone_core_record_aware_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_record_aware(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_record_file(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_record_file(IntPtr thiz, string file);

		/// <summary>
		/// Get the wav file where incoming stream is recorded, when files are used instead
		/// of soundcards (see <see cref="Linphone.Core.UseFiles">
		/// Linphone.Core.UseFiles</see>). 
		/// <para>
		/// This feature is different from call recording (<see cref="Linphone.CallParams.RecordFile">
		/// Linphone.CallParams.RecordFile</see>) The file is a 16 bit linear wav file. 
		/// </para>
		/// </summary>
		/// <returns>The path to the file where incoming stream is recorded.    </returns>
		public string RecordFile
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_record_file(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_record_file(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_remote_ringback_tone(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_remote_ringback_tone(IntPtr thiz, string ring);

		/// <summary>
		/// Get the ring back tone played to far end during incoming calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the path to the remote ring back tone to be played.    </returns>
		public string RemoteRingbackTone
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_remote_ringback_tone(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_remote_ringback_tone(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_retransmission_on_nack_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_retransmission_on_nack(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether NACK context is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether NACK context is enabled or not
		/// </returns>
		public bool RetransmissionOnNackEnabled
		{
			get
			{
				return linphone_core_retransmission_on_nack_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_retransmission_on_nack(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_ring(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_ring(IntPtr thiz, string path);

		/// <summary>
		/// Returns the path to the wav file used for ringing. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to the wav file used for ringing.    </returns>
		public string Ring
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_ring(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_ring(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_ring_during_incoming_early_media(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_ring_during_incoming_early_media(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether the ring play is enabled during an incoming early media call. 
		/// <para>
		/// </para>
		/// </summary>
		public bool RingDuringIncomingEarlyMedia
		{
			get
			{
				return linphone_core_get_ring_during_incoming_early_media(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_ring_during_incoming_early_media(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_ringback(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_ringback(IntPtr thiz, string path);

		/// <summary>
		/// Returns the path to the wav file used for ringing back. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to the wav file used for ringing back.    </returns>
		public string Ringback
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_ringback(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_ringback(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_ringer_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_ringer_device(IntPtr thiz, string devid);

		/// <summary>
		/// Gets the name of the currently assigned sound device for ringing. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The name of the currently assigned sound device for ringing.   
		/// </returns>
		public string RingerDevice
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_ringer_device(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_ringer_device(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("RingerDevice setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_root_ca(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_root_ca(IntPtr thiz, string path);

		/// <summary>
		/// Gets the path to a file or folder containing the trusted root CAs (PEM format) 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to a file or folder containing the trusted root CAs.   
		/// </returns>
		public string RootCa
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_root_ca(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_root_ca(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_root_ca_data(IntPtr thiz, string data);

		/// <summary>
		/// Sets the trusted root CAs (PEM format) 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="data">The trusted root CAs as a string    </param>
		public string RootCaData
		{
			set
			{
				linphone_core_set_root_ca_data(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_rtp_bundle_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_rtp_bundle(IntPtr thiz, char val);

		/// <summary>
		/// Returns whether RTP bundle mode (also known as Media Multiplexing) is enabled. 
		/// <para>
		/// See https://datatracker.ietf.org/doc/html/rfc8843 for more information. 
		/// </para>
		/// </summary>
		/// <returns>a boolean indicating the enablement of rtp bundle mode. </returns>
		public bool RtpBundleEnabled
		{
			get
			{
				return linphone_core_rtp_bundle_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_rtp_bundle(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_sdp_200_ack_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_sdp_200_ack(IntPtr thiz, char enable);

		/// <summary>
		/// Media offer control param for SIP INVITE. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if INVITE has to be sent whitout SDP. </returns>
		public bool Sdp200AckEnabled
		{
			get
			{
				return linphone_core_sdp_200_ack_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_sdp_200_ack(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_self_view_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_self_view(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether video self view during call is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether self view is enabled </returns>
		/// <remarks>See : <see cref="Linphone.Core.EnableSelfView()">
		/// Linphone.Core.EnableSelfView()</see> for details. </remarks>
		public bool SelfViewEnabled
		{
			get
			{
				return linphone_core_self_view_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_self_view(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_sender_name_hidden_in_forward_message(IntPtr thiz, char enable);

		/// <summary>
		/// Enable whether or not to hide sender name in forward message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="enable">whether or not to enable the feature </param>
		public bool SenderNameHiddenInForwardMessageEnabled
		{
			set
			{
				linphone_core_enable_sender_name_hidden_in_forward_message(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_session_expires_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_session_expires(IntPtr thiz, char enabled);

		/// <summary>
		/// Check if the Session Timers feature is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if session timers are enabled, false otherwise </returns>
		public bool SessionExpiresEnabled
		{
			get
			{
				return linphone_core_session_expires_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_session_expires(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_session_expires_min_value(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_session_expires_min_value(IntPtr thiz, int min);

		/// <summary>
		/// Returns the session expires min value, 90 by default. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The minSE value </returns>
		public int SessionExpiresMinValue
		{
			get
			{
				return linphone_core_get_session_expires_min_value(nativePtr);
			}
			set
			{
				linphone_core_set_session_expires_min_value(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SessionExpiresRefresher linphone_core_get_session_expires_refresher_value(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_session_expires_refresher_value(IntPtr thiz, int refresher);

		/// <summary>
		/// Returns the session expires refresher value. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.SessionExpiresRefresher">
		/// Linphone.SessionExpiresRefresher</see> configuration refresher value </returns>
		public Linphone.SessionExpiresRefresher SessionExpiresRefresherValue
		{
			get
			{
				return linphone_core_get_session_expires_refresher_value(nativePtr);
			}
			set
			{
				linphone_core_set_session_expires_refresher_value(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_session_expires_value(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_session_expires_value(IntPtr thiz, int expires);

		/// <summary>
		/// Returns the session expires value. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The session timer expire value </returns>
		public int SessionExpiresValue
		{
			get
			{
				return linphone_core_get_session_expires_value(nativePtr);
			}
			set
			{
				linphone_core_set_session_expires_value(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_sip_dscp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_sip_dscp(IntPtr thiz, int dscp);

		/// <summary>
		/// Get the DSCP field for SIP signaling channel. 
		/// <para>
		/// The DSCP defines the quality of service in IP packets. 
		/// </para>
		/// </summary>
		/// <returns>The current DSCP value </returns>
		public int SipDscp
		{
			get
			{
				return linphone_core_get_sip_dscp(nativePtr);
			}
			set
			{
				linphone_core_set_sip_dscp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_sip_network_reachable(IntPtr thiz, char reachable);

		/// <summary>
		/// This method is called by the application to notify the linphone core library
		/// when the SIP network is reachable. 
		/// <para>
		/// This is for advanced usage, when SIP and RTP layers are required to use
		/// different interfaces. Most applications just need <see cref="Linphone.Core.NetworkReachable">
		/// Linphone.Core.NetworkReachable</see>.
		/// </para>
		/// </summary>
		/// <param name="reachable">true if network is reachable, false otherwise </param>
		public bool SipNetworkReachable
		{
			set
			{
				linphone_core_set_sip_network_reachable(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_sip_transport_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_sip_transport_timeout(IntPtr thiz, int timeoutMs);

		/// <summary>
		/// Get the SIP transport timeout, which represents the maximum time permitted to
		/// establish a connection to a SIP server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The SIP transport timeout in milliseconds. </returns>
		public int SipTransportTimeout
		{
			get
			{
				return linphone_core_get_sip_transport_timeout(nativePtr);
			}
			set
			{
				linphone_core_set_sip_transport_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_sound_devices_list(IntPtr thiz);

		/// <summary>
		/// Gets the list of the available sound devices. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>An unmodifiable array of strings contanining the names of the
		/// available sound devices that is null terminated.         </returns>
		/// deprecated : 10/04/2021 Use <see cref="Linphone.Core.AudioDevices">
		/// Linphone.Core.AudioDevices</see> instead.
		public IEnumerable<string> SoundDevicesList
		{
			get
			{
				return MarshalStringArray(linphone_core_get_sound_devices_list(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_srtp_crypto_suites(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_srtp_crypto_suites(IntPtr thiz, string suites);

		/// <summary>
		/// Get the crypto suites available to the core. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a comma separated list of supported suites    </returns>
		public string SrtpCryptoSuites
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_srtp_crypto_suites(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_srtp_crypto_suites(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_static_picture(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_static_picture(IntPtr thiz, string path);

		/// <summary>
		/// Get the path to the image file streamed when &quot;Static picture&quot; is set
		/// as the video device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to the image file streamed when &quot;Static picture&quot; is
		/// set as the video device.    </returns>
		public string StaticPicture
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_static_picture(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_static_picture(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("StaticPicture setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_core_get_static_picture_fps(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_static_picture_fps(IntPtr thiz, float fps);

		/// <summary>
		/// Get the frame rate for static picture. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The frame rate used for static picture. </returns>
		public float StaticPictureFps
		{
			get
			{
				return linphone_core_get_static_picture_fps(nativePtr);
			}
			set
			{
				int exception_result = linphone_core_set_static_picture_fps(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("StaticPictureFps setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_stun_server(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_stun_server(IntPtr thiz, string server);

		/// <summary>
		/// Get the STUN server address being used. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The STUN server address being used.    </returns>
		public string StunServer
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_stun_server(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_stun_server(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_supported_file_formats_list(IntPtr thiz);

		/// <summary>
		/// Returns a null terminated table of strings containing the file format extension
		/// supported for call recording. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The supported formats, typically &apos;wav&apos; and &apos;mkv&apos;. 
		///        </returns>
		public IEnumerable<string> SupportedFileFormatsList
		{
			get
			{
				return MarshalStringArray(linphone_core_get_supported_file_formats_list(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_supported_tag(IntPtr thiz, string tags);

		/// <summary>
		/// Set the supported tags. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="tags">The feature tags to set    </param>
		public string SupportedTag
		{
			set
			{
				linphone_core_set_supported_tag(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SupportLevel linphone_core_get_tag_100rel_support_level(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_tag_100rel_support_level(IntPtr thiz, int level);

		/// <summary>
		/// Get the support level of the 100rel attribute. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The 100 rel support level </returns>
		public Linphone.SupportLevel Tag100RelSupportLevel
		{
			get
			{
				return linphone_core_get_tag_100rel_support_level(nativePtr);
			}
			set
			{
				linphone_core_set_tag_100rel_support_level(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_tcap_line_merging(IntPtr thiz, char merge);

		/// <summary>
		/// Define whether tcap lines are going to be merged if capability negotiation
		/// (RFC5939) is supported. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="merge">true to merge tcap lines with consecutive indexes; false
		/// otherwise. </param>
		public bool TcapLineMergingEnabled
		{
			set
			{
				linphone_core_enable_tcap_line_merging(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_tcap_lines_merging_enabled(IntPtr thiz);

		/// <summary>
		/// Check if tcap lines are going to the merged if the capability negotiation
		/// (RFC5939) is supported or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if tcap lines with consecutive indexes are going to be merged;
		/// false otherwise. </returns>
		public bool TcapLinesMergingEnabled
		{
			get
			{
				return linphone_core_tcap_lines_merging_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_text_payload_types(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_text_payload_types(IntPtr thiz, IntPtr payloadTypes);

		/// <summary>
		/// Return the list of the available text payload types. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A freshly allocated list of the available payload types. The list must
		/// be destroyed with bctbx_list_free() after usage. The elements of the list
		/// haven&apos;t to be unref.      </returns>
		public IEnumerable<Linphone.PayloadType> TextPayloadTypes
		{
			get
			{
				return MarshalBctbxList<Linphone.PayloadType>(linphone_core_get_text_payload_types(nativePtr), true);
			}
			set
			{
				linphone_core_set_text_payload_types(nativePtr, ObjectArrayToBctbxList<Linphone.PayloadType>(value));
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_text_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_text_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the UDP port used for text streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The UDP port used for text streaming </returns>
		public int TextPort
		{
			get
			{
				return linphone_core_get_text_port(nativePtr);
			}
			set
			{
				linphone_core_set_text_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_text_ports_range(IntPtr thiz);

		/// <summary>
		/// Get the text port range from which is randomly chosen the UDP port used for
		/// text streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Range">Linphone.Range</see> object      
		/// </returns>
		public Linphone.Range TextPortsRange
		{
			get
			{
				IntPtr ptr = linphone_core_get_text_ports_range(nativePtr);
				Linphone.Range obj = fromNativePtr<Linphone.Range>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_tls_cert(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_tls_cert(IntPtr thiz, string tlsCert);

		/// <summary>
		/// Gets the TLS certificate. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the TLS certificate or null if not set yet.    </returns>
		public string TlsCert
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_tls_cert(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_tls_cert(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_tls_cert_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_tls_cert_path(IntPtr thiz, string tlsCertPath);

		/// <summary>
		/// Gets the path to the TLS certificate file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the TLS certificate path or null if not set yet.    </returns>
		public string TlsCertPath
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_tls_cert_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_tls_cert_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_tls_key(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_tls_key(IntPtr thiz, string tlsKey);

		/// <summary>
		/// Gets the TLS key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the TLS key or null if not set yet.    </returns>
		public string TlsKey
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_tls_key(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_tls_key(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_tls_key_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_tls_key_path(IntPtr thiz, string tlsKeyPath);

		/// <summary>
		/// Gets the path to the TLS key file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the TLS key path or null if not set yet.    </returns>
		public string TlsKeyPath
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_tls_key_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_tls_key_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_transports(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_transports(IntPtr thiz, IntPtr transports);

		/// <summary>
		/// Retrieves the port configuration used for each transport (udp, tcp, tls). 
		/// <para>
		/// A zero value port for a given transport means the transport is not used. A
		/// value of LC_SIP_TRANSPORT_RANDOM (-1) means the port is to be chosen randomly
		/// by the system. A value of LC_SIP_TRANSPORT_DONTBIND (-2) means that the socket
		/// will not be bound explicitely, in other words liblinphone won&apos;t listen for
		/// incoming connections at all. This mode is suitable for a pure client
		/// application (ex: a mobile application). 
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.Transports">Linphone.Transports</see> structure
		/// with the configured ports       </returns>
		public Linphone.Transports Transports
		{
			get
			{
				IntPtr ptr = linphone_core_get_transports(nativePtr);
				Linphone.Transports obj = fromNativePtr<Linphone.Transports>(ptr, true);
				return obj;
			}
			set
			{
				int exception_result = linphone_core_set_transports(nativePtr, value.nativePtr);
				if (exception_result != 0) throw new LinphoneException("Transports setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_transports_used(IntPtr thiz);

		/// <summary>
		/// Retrieves the real port number assigned for each sip transport (udp, tcp, tls). 
		/// <para>
		/// A zero value means that the transport is not activated. If
		/// LC_SIP_TRANSPORT_RANDOM was passed to linphone_core_set_sip_transports, the
		/// random port choosed by the system is returned. 
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.Transports">Linphone.Transports</see> structure
		/// with the ports being used       </returns>
		public Linphone.Transports TransportsUsed
		{
			get
			{
				IntPtr ptr = linphone_core_get_transports_used(nativePtr);
				Linphone.Transports obj = fromNativePtr<Linphone.Transports>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_tunnel(IntPtr thiz);

		/// <summary>
		/// get tunnel instance if available 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.Tunnel">Linphone.Tunnel</see> or null if not
		/// available.    </returns>
		public Linphone.Tunnel Tunnel
		{
			get
			{
				IntPtr ptr = linphone_core_get_tunnel(nativePtr);
				Linphone.Tunnel obj = fromNativePtr<Linphone.Tunnel>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_unread_chat_message_count(IntPtr thiz);

		/// <summary>
		/// Return the global unread chat message count. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The global unread chat message count. </returns>
		public int UnreadChatMessageCount
		{
			get
			{
				return linphone_core_get_unread_chat_message_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_unread_chat_message_count_from_active_locals(IntPtr thiz);

		/// <summary>
		/// Return the unread chat message count for all active local address. 
		/// <para>
		/// (Primary contact + proxy configs.) 
		/// </para>
		/// </summary>
		/// <returns>The unread chat message count. </returns>
		public int UnreadChatMessageCountFromActiveLocals
		{
			get
			{
				return linphone_core_get_unread_chat_message_count_from_active_locals(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_upload_bandwidth(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_upload_bandwidth(IntPtr thiz, int bandwidth);

		/// <summary>
		/// Retrieve the maximum available upload bandwidth. 
		/// <para>
		/// This value was set by <see cref="Linphone.Core.UploadBandwidth">
		/// Linphone.Core.UploadBandwidth</see>. 
		/// </para>
		/// </summary>
		/// <returns>the upload bandiwdth in kbits/s, 0 for infinite </returns>
		public int UploadBandwidth
		{
			get
			{
				return linphone_core_get_upload_bandwidth(nativePtr);
			}
			set
			{
				linphone_core_set_upload_bandwidth(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_upload_ptime(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_upload_ptime(IntPtr thiz, int ptime);

		/// <summary>
		/// Set audio packetization time linphone will send (in absence of requirement from
		/// peer) A value of 0 stands for the current codec default packetization time. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the upload packetization time set </returns>
		public int UploadPtime
		{
			get
			{
				return linphone_core_get_upload_ptime(nativePtr);
			}
			set
			{
				linphone_core_set_upload_ptime(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_upnp_external_ipaddress(IntPtr thiz);

		/// <summary>
		/// Return the external ip address of router. 
		/// <para>
		/// In some cases the uPnP can have an external ip address but not a usable uPnP
		/// (state different of Ok).
		/// </para>
		/// </summary>
		/// <returns>a null terminated string containing the external ip address. If the
		/// the external ip address is not available return null.    </returns>
		public string UpnpExternalIpaddress
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_upnp_external_ipaddress(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.UpnpState linphone_core_get_upnp_state(IntPtr thiz);

		/// <summary>
		/// Return the internal state of uPnP. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>an LinphoneUpnpState. </returns>
		public Linphone.UpnpState UpnpState
		{
			get
			{
				return linphone_core_get_upnp_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_use_files(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_use_files(IntPtr thiz, char yesno);

		/// <summary>
		/// Gets whether linphone is currently streaming audio from and to files, rather
		/// than using the soundcard. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value representing whether linphone is streaming audio from
		/// and to files or not. </returns>
		public bool UseFiles
		{
			get
			{
				return linphone_core_get_use_files(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_use_files(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_use_info_for_dtmf(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_use_info_for_dtmf(IntPtr thiz, char useInfo);

		/// <summary>
		/// Indicates whether SIP INFO is used to send digits. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether SIP INFO is used to send digits
		/// </returns>
		public bool UseInfoForDtmf
		{
			get
			{
				return linphone_core_get_use_info_for_dtmf(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_use_info_for_dtmf(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_get_use_rfc2833_for_dtmf(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_use_rfc2833_for_dtmf(IntPtr thiz, char useRfc2833);

		/// <summary>
		/// Indicates whether RFC2833 is used to send digits. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether RFC2833 is used to send digits
		/// </returns>
		public bool UseRfc2833ForDtmf
		{
			get
			{
				return linphone_core_get_use_rfc2833_for_dtmf(nativePtr) != 0;
			}
			set
			{
				linphone_core_set_use_rfc2833_for_dtmf(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_user_agent(IntPtr thiz);

		/// <summary>
		/// Gets the user-agent as a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>liblinphone&apos;s user agent as a string.    </returns>
		public string UserAgent
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_user_agent(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_user_certificates_path(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_user_certificates_path(IntPtr thiz, string path);

		/// <summary>
		/// Get the path to the directory storing the user&apos;s certificates. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to the directory storing the user&apos;s certificates.   
		/// </returns>
		public string UserCertificatesPath
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_user_certificates_path(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_user_certificates_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_vibration_on_incoming_call_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_vibration_on_incoming_call(IntPtr thiz, char enable);

		/// <summary>
		/// Gets whether the device will vibrate while an incoming call is ringing (Android
		/// only). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the device will vibrate (if possible), false otherwise
		/// </returns>
		public bool VibrationOnIncomingCallEnabled
		{
			get
			{
				return linphone_core_vibration_on_incoming_call_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_vibration_on_incoming_call(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_activation_policy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_activation_policy(IntPtr thiz, IntPtr policy);

		/// <summary>
		/// Get the default policy for video. 
		/// <para>
		/// See <see cref="Linphone.Core.VideoActivationPolicy">
		/// Linphone.Core.VideoActivationPolicy</see> for more details. 
		/// </para>
		/// </summary>
		/// <returns>The video policy being used       </returns>
		public Linphone.VideoActivationPolicy VideoActivationPolicy
		{
			get
			{
				IntPtr ptr = linphone_core_get_video_activation_policy(nativePtr);
				Linphone.VideoActivationPolicy obj = fromNativePtr<Linphone.VideoActivationPolicy>(ptr, true);
				return obj;
			}
			set
			{
				linphone_core_set_video_activation_policy(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_adaptive_jittcomp_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_video_adaptive_jittcomp(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether the video adaptive jitter compensation is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the video adaptive jitter compensation is enabled, false
		/// otherwise. </returns>
		public bool VideoAdaptiveJittcompEnabled
		{
			get
			{
				return linphone_core_video_adaptive_jittcomp_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_video_adaptive_jittcomp(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_capture_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_video_capture(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether video capture is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if video capture is enabled, false if disabled. </returns>
		public bool VideoCaptureEnabled
		{
			get
			{
				return linphone_core_video_capture_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_video_capture(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.CodecPriorityPolicy linphone_core_get_video_codec_priority_policy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_codec_priority_policy(IntPtr thiz, int policy);

		/// <summary>
		/// Get the current priority policy for video codecs (payload types). 
		/// <para>
		/// See <see cref="Linphone.CodecPriorityPolicy">Linphone.CodecPriorityPolicy</see>
		/// for more details. 
		/// </para>
		/// </summary>
		/// <returns>the current <see cref="Linphone.CodecPriorityPolicy">
		/// Linphone.CodecPriorityPolicy</see> </returns>
		public Linphone.CodecPriorityPolicy VideoCodecPriorityPolicy
		{
			get
			{
				return linphone_core_get_video_codec_priority_policy(nativePtr);
			}
			set
			{
				linphone_core_set_video_codec_priority_policy(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_video_device(IntPtr thiz, string id);

		/// <summary>
		/// Returns the name of the currently active video device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The name of the currently active video device.    </returns>
		public string VideoDevice
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_video_device(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_video_device(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("VideoDevice setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_devices_list(IntPtr thiz);

		/// <summary>
		/// Gets the list of the available video capture devices. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>An unmodifiable array of strings contanining the names of the
		/// available video capture devices that is null terminated.         </returns>
		public IEnumerable<string> VideoDevicesList
		{
			get
			{
				return MarshalStringArray(linphone_core_get_video_devices_list(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_display_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_video_display(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether video display is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if video display is enabled, false if disabled. </returns>
		public bool VideoDisplayEnabled
		{
			get
			{
				return linphone_core_video_display_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_video_display(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_display_filter(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_display_filter(IntPtr thiz, string filterName);

		/// <summary>
		/// Get the name of the mediastreamer2 filter used for rendering video. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The currently selected video display filter.    </returns>
		public string VideoDisplayFilter
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_video_display_filter(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_video_display_filter(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_video_dscp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_dscp(IntPtr thiz, int dscp);

		/// <summary>
		/// Get the DSCP field for outgoing video streams. 
		/// <para>
		/// The DSCP defines the quality of service in IP packets. 
		/// </para>
		/// </summary>
		/// <returns>The current DSCP value </returns>
		public int VideoDscp
		{
			get
			{
				return linphone_core_get_video_dscp(nativePtr);
			}
			set
			{
				linphone_core_set_video_dscp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_enabled(IntPtr thiz);

		/// <summary>
		/// Returns true if either capture or display is enabled, false otherwise. 
		/// <para>
		/// same as ( <see cref="Linphone.Core.VideoCaptureEnabled()">
		/// Linphone.Core.VideoCaptureEnabled()</see> | <see cref="Linphone.Core.VideoDisplayEnabled()">
		/// Linphone.Core.VideoDisplayEnabled()</see> )
		/// </para>
		/// </summary>
		/// <returns>true if either capture or display is enabled, false otherwise.
		/// </returns>
		public bool VideoEnabled
		{
			get
			{
				return linphone_core_video_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_video_jittcomp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_jittcomp(IntPtr thiz, int milliseconds);

		/// <summary>
		/// Returns the nominal video jitter buffer size in milliseconds. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The nominal video jitter buffer size in milliseconds </returns>
		public int VideoJittcomp
		{
			get
			{
				return linphone_core_get_video_jittcomp(nativePtr);
			}
			set
			{
				linphone_core_set_video_jittcomp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_multicast_addr(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_video_multicast_addr(IntPtr thiz, string ip);

		/// <summary>
		/// Use to get multicast address to be used for video stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>an ipv4/6 multicast address, or default value.    </returns>
		public string VideoMulticastAddr
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_video_multicast_addr(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_core_set_video_multicast_addr(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("VideoMulticastAddr setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_multicast_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_video_multicast(IntPtr thiz, char yesno);

		/// <summary>
		/// Use to get multicast state of video stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if subsequent calls will propose multicast ip set by <see cref="Linphone.Core.VideoMulticastAddr">
		/// Linphone.Core.VideoMulticastAddr</see> </returns>
		public bool VideoMulticastEnabled
		{
			get
			{
				return linphone_core_video_multicast_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_video_multicast(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_video_multicast_ttl(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_set_video_multicast_ttl(IntPtr thiz, int ttl);

		/// <summary>
		/// Use to get multicast ttl to be used for video stream. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a time to leave value </returns>
		public int VideoMulticastTtl
		{
			get
			{
				return linphone_core_get_video_multicast_ttl(nativePtr);
			}
			set
			{
				int exception_result = linphone_core_set_video_multicast_ttl(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("VideoMulticastTtl setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_payload_types(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_payload_types(IntPtr thiz, IntPtr payloadTypes);

		/// <summary>
		/// Return the list of the available video payload types. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A freshly allocated list of the available payload types.        
		/// </returns>
		public IEnumerable<Linphone.PayloadType> VideoPayloadTypes
		{
			get
			{
				return MarshalBctbxList<Linphone.PayloadType>(linphone_core_get_video_payload_types(nativePtr), true);
			}
			set
			{
				linphone_core_set_video_payload_types(nativePtr, ObjectArrayToBctbxList<Linphone.PayloadType>(value));
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_video_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the UDP port used for video streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The UDP port used for video streaming </returns>
		public int VideoPort
		{
			get
			{
				return linphone_core_get_video_port(nativePtr);
			}
			set
			{
				linphone_core_set_video_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_ports_range(IntPtr thiz);

		/// <summary>
		/// Get the video port range from which is randomly chosen the UDP port used for
		/// video streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Range">Linphone.Range</see> object      
		/// </returns>
		public Linphone.Range VideoPortsRange
		{
			get
			{
				IntPtr ptr = linphone_core_get_video_ports_range(nativePtr);
				Linphone.Range obj = fromNativePtr<Linphone.Range>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_video_preset(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_preset(IntPtr thiz, string preset);

		/// <summary>
		/// Get the video preset used for video calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The name of the video preset used for video calls (can be null if the
		/// default video preset is used).    </returns>
		public string VideoPreset
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_video_preset(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_video_preset(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_preview_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_video_preview(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether video preview is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether video preview is enabled </returns>
		public bool VideoPreviewEnabled
		{
			get
			{
				return linphone_core_video_preview_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_video_preview(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_video_source_reuse(IntPtr thiz, char enable);

		/// <summary>
		/// Enable or disable video source reuse when switching from preview to actual
		/// video call. 
		/// <para>
		/// This source reuse is useful when you always display the preview, even before
		/// calls are initiated. By keeping the video source for the transition to a real
		/// video call, you will smooth out the source close/reopen cycle.
		/// This function does not have any effect durfing calls. It just indicates the
		/// <see cref="Linphone.Core">Linphone.Core</see> to initiate future calls with
		/// video source reuse or not. Also, at the end of a video call, the source will be
		/// closed whatsoever for now. 
		/// </para>
		/// </summary>
		/// <param name="enable">true to enable video source reuse. false to disable it for
		/// subsequent calls. </param>
		public bool VideoSourceReuseEnabled
		{
			set
			{
				linphone_core_enable_video_source_reuse(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_wifi_only_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_wifi_only(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether Wifi only mode is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : Only works for Android platform. </remarks> 
		/// <returns>A boolean value telling whether Wifi only mode is enabled or not
		/// </returns>
		public bool WifiOnlyEnabled
		{
			get
			{
				return linphone_core_wifi_only_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_wifi_only(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_zero_rtp_port_for_stream_inactive_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_zero_rtp_port_for_stream_inactive(IntPtr thiz, char enable);

		/// <summary>
		/// Check if RTP port is set to 0 when a stream is inactive. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the RTP port is set to 0 if the stream direction is inactive;
		/// false otherwise. </returns>
		public bool ZeroRtpPortForStreamInactiveEnabled
		{
			get
			{
				return linphone_core_zero_rtp_port_for_stream_inactive_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_zero_rtp_port_for_stream_inactive(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_zrtp_cache_db(IntPtr thiz);

		/// <summary>
		/// Get a pointer to the sqlite db holding zrtp/lime cache. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>An sqlite3 pointer cast to a void one or null if cache is not
		/// available(not enabled at compile or access
		/// failed)    </returns>
		public IntPtr ZrtpCacheDb
		{
			get
			{
				return linphone_core_get_zrtp_cache_db(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_zrtp_go_clear_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_zrtp_go_clear(IntPtr thiz, char enabled);

		/// <summary>
		/// Check if the ZRTP go clear is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if ZTRP go clear is enabled; false otherwise. </returns>
		public bool ZrtpGoClearEnabled
		{
			get
			{
				return linphone_core_zrtp_go_clear_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_core_enable_zrtp_go_clear(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_zrtp_secrets_file(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_zrtp_secrets_file(IntPtr thiz, string file);

		/// <summary>
		/// Get the path to the file storing the zrtp secrets cache. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to the file storing the zrtp secrets cache.    </returns>
		public string ZrtpSecretsFile
		{
			get
			{
				IntPtr stringPtr = linphone_core_get_zrtp_secrets_file(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_core_set_zrtp_secrets_file(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_activate_audio_session(IntPtr thiz, char activated);

		/// <summary>
		/// Special function to indicate if the audio session is activated. 
		/// <para>
		/// Must be called when ProviderDelegate of the callkit notifies that the audio
		/// session is activated or deactivated. 
		/// </para>
		/// </summary>
		/// <param name="activated">true to activate the audio session, false to disable
		/// it. </param>
		public void ActivateAudioSession(bool activated)
		{
			linphone_core_activate_audio_session(nativePtr, activated ? (char)1 : (char)0);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_add_account(IntPtr thiz, IntPtr account);

		/// <summary>
		/// Add an account. 
		/// <para>
		/// This will start registration on the proxy, if registration is enabled. 
		/// </para>
		/// </summary>
		/// <param name="account">the <see cref="Linphone.Account">Linphone.Account</see>
		/// to add    </param>
		/// <returns>0 if successful, -1 otherwise </returns>
		public void AddAccount(Linphone.Account account)
		{
			int exception_result = linphone_core_add_account(nativePtr, account != null ? account.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddAccount returned value" + exception_result);
			
			GC.KeepAlive(account);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_add_all_to_conference(IntPtr thiz);

		/// <summary>
		/// Add all current calls into the conference. 
		/// <para>
		/// If no conference is running a new internal conference context is created and
		/// all current calls are added to it. 
		/// </para>
		/// </summary>
		/// <returns>0 if succeeded. Negative number if failed </returns>
		/// <remarks>Warning : This function guarantees that the local endpoint is added to
		/// the conference. </remarks> 
		public void AddAllToConference()
		{
			int exception_result = linphone_core_add_all_to_conference(nativePtr);
			if (exception_result != 0) throw new LinphoneException("AddAllToConference returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_add_auth_info(IntPtr thiz, IntPtr info);

		/// <summary>
		/// Adds authentication information to the <see cref="Linphone.Core">
		/// Linphone.Core</see>. 
		/// <para>
		/// That piece of information will be used during all SIP transactions that require
		/// authentication. 
		/// </para>
		/// </summary>
		/// <param name="info">The <see cref="Linphone.AuthInfo">Linphone.AuthInfo</see> to
		/// add.    </param>
		public void AddAuthInfo(Linphone.AuthInfo info)
		{
			linphone_core_add_auth_info(nativePtr, info != null ? info.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(info);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_add_content_type_support(IntPtr thiz, string contentType);

		/// <summary>
		/// Add support for the specified content type. 
		/// <para>
		/// It is the application responsibility to handle it correctly afterwards. 
		/// </para>
		/// </summary>
		/// <param name="contentType">The content type to add support for    </param>
		public void AddContentTypeSupport(string contentType)
		{
			linphone_core_add_content_type_support(nativePtr, contentType);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_add_friend_list(IntPtr thiz, IntPtr list);

		/// <summary>
		/// Add a friend list. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="list"><see cref="Linphone.FriendList">Linphone.FriendList</see>
		/// object    </param>
		public void AddFriendList(Linphone.FriendList list)
		{
			linphone_core_add_friend_list(nativePtr, list != null ? list.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(list);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_add_ldap(IntPtr thiz, IntPtr ldap);

		/// <summary>
		/// Add or update a LDAP server and save it to the configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="ldap">The LDAP to add/update.    </param>
		public void AddLdap(Linphone.Ldap ldap)
		{
			linphone_core_add_ldap(nativePtr, ldap != null ? ldap.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(ldap);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_add_linphone_spec(IntPtr thiz, string spec);

		/// <summary>
		/// Add the given linphone specs to the list of functionalities the linphone client
		/// supports. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="spec">The spec to add    </param>
		public void AddLinphoneSpec(string spec)
		{
			linphone_core_add_linphone_spec(nativePtr, spec);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_add_provisioning_header(IntPtr thiz, string headerName, string val);

		/// <summary>
		/// Add an extra header for retrieving the remote provisioning (check <see cref="Linphone.Core.ProvisioningUri">
		/// Linphone.Core.ProvisioningUri</see>). 
		/// <para>
		/// This can also be set from configuration file or factory config file, from[misc]
		/// section, item &quot;config-uri-headers_X&quot; where X is the index of the
		/// header starting by 0. 
		/// </para>
		/// </summary>
		/// <param name="headerName">the header to use when downloading the configuration. 
		///   </param>
		/// <param name="val">the value to use when downloading the configuration.   
		/// </param>
		public void AddProvisioningHeader(string headerName, string val)
		{
			linphone_core_add_provisioning_header(nativePtr, headerName, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_add_proxy_config(IntPtr thiz, IntPtr config);

		/// <summary>
		/// Add a proxy configuration. 
		/// <para>
		/// This will start registration on the proxy, if registration is enabled. 
		/// </para>
		/// </summary>
		/// <param name="config">the <see cref="Linphone.ProxyConfig">
		/// Linphone.ProxyConfig</see> to add    </param>
		/// <returns>0 if successful, -1 otherwise </returns>
		public void AddProxyConfig(Linphone.ProxyConfig config)
		{
			int exception_result = linphone_core_add_proxy_config(nativePtr, config != null ? config.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddProxyConfig returned value" + exception_result);
			
			GC.KeepAlive(config);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_add_supported_tag(IntPtr thiz, string tag);

		/// <summary>
		/// This function controls signaling features supported by the core. 
		/// <para>
		/// They are typically included in a SIP Supported header. 
		/// </para>
		/// </summary>
		/// <param name="tag">The feature tag name    </param>
		public void AddSupportedTag(string tag)
		{
			linphone_core_add_supported_tag(nativePtr, tag);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_add_to_conference(IntPtr thiz, IntPtr call);

		/// <summary>
		/// Add a participant to the conference. 
		/// <para>
		/// If no conference is going on a new internal conference context is created and
		/// the participant is added to it. 
		/// </para>
		/// </summary>
		/// <param name="call">The current call with the participant to add    </param>
		/// <returns>0 if succeeded. Negative number if failed </returns>
		public void AddToConference(Linphone.Call call)
		{
			int exception_result = linphone_core_add_to_conference(nativePtr, call != null ? call.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddToConference returned value" + exception_result);
			
			GC.KeepAlive(call);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_audio_route_changed(IntPtr thiz);

		/// <summary>
		/// Special function to indicate if the audio route is changed. 
		/// <para>
		/// Must be called in the callback of AVAudioSessionRouteChangeNotification. 
		/// </para>
		/// </summary>
		/// deprecated : 07/01/2020 now handled in the linphone SDK directly 
		public void AudioRouteChanged()
		{
			linphone_core_audio_route_changed(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomEphemeralMode linphone_core_chat_room_get_default_ephemeral_mode(IntPtr thiz);

		/// <summary>
		/// Gets the default ephemeral message mode. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the default ephemeral message mode <see cref="Linphone.ChatRoomEphemeralMode">
		/// Linphone.ChatRoomEphemeralMode</see> </returns>
		public Linphone.ChatRoomEphemeralMode ChatRoomGetDefaultEphemeralMode()
		{
			Linphone.ChatRoomEphemeralMode returnVal = linphone_core_chat_room_get_default_ephemeral_mode(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_chat_room_set_default_ephemeral_mode(IntPtr thiz, int mode);

		/// <summary>
		/// Sets the default ephemeral message mode. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="mode">default ephemeral message mode <see cref="Linphone.ChatRoomEphemeralMode">
		/// Linphone.ChatRoomEphemeralMode</see> </param>
		public void ChatRoomSetDefaultEphemeralMode(Linphone.ChatRoomEphemeralMode mode)
		{
			linphone_core_chat_room_set_default_ephemeral_mode(nativePtr, (int)mode);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_check_for_update(IntPtr thiz, string currentVersion);

		/// <summary>
		/// Checks if a new version of the application is available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="currentVersion">The current version of the application    </param>
		public void CheckForUpdate(string currentVersion)
		{
			linphone_core_check_for_update(nativePtr, currentVersion);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_clear_accounts(IntPtr thiz);

		/// <summary>
		/// Erase all account from config. 
		/// <para>
		/// </para>
		/// </summary>
		public void ClearAccounts()
		{
			linphone_core_clear_accounts(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_clear_all_auth_info(IntPtr thiz);

		/// <summary>
		/// Clear all authentication information. 
		/// <para>
		/// </para>
		/// </summary>
		public void ClearAllAuthInfo()
		{
			linphone_core_clear_all_auth_info(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_clear_call_logs(IntPtr thiz);

		/// <summary>
		/// Erase the call log. 
		/// <para>
		/// </para>
		/// </summary>
		public void ClearCallLogs()
		{
			linphone_core_clear_call_logs(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_clear_ldaps(IntPtr thiz);

		/// <summary>
		/// Erase all LDAP from the configuration. 
		/// <para>
		/// </para>
		/// </summary>
		public void ClearLdaps()
		{
			linphone_core_clear_ldaps(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_clear_provisioning_headers(IntPtr thiz);

		/// <summary>
		/// Clear all headers that were added with <see cref="Linphone.Core.AddProvisioningHeader()">
		/// Linphone.Core.AddProvisioningHeader()</see>. 
		/// <para>
		/// </para>
		/// </summary>
		public void ClearProvisioningHeaders()
		{
			linphone_core_clear_provisioning_headers(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_clear_proxy_config(IntPtr thiz);

		/// <summary>
		/// Erase all proxies from config. 
		/// <para>
		/// </para>
		/// </summary>
		public void ClearProxyConfig()
		{
			linphone_core_clear_proxy_config(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_config_sync(IntPtr thiz);

		/// <summary>
		/// Writes the config file to disk. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, -1 otherwise </returns>
		public void ConfigSync()
		{
			int exception_result = linphone_core_config_sync(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ConfigSync returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_configure_audio_session(IntPtr thiz);

		/// <summary>
		/// Special function to configure audio session with default settings. 
		/// <para>
		/// Must be called in ProviderDelegate&apos;s callbacks when answer an incoming
		/// call and start an outgoing call. 
		/// </para>
		/// </summary>
		public void ConfigureAudioSession()
		{
			linphone_core_configure_audio_session(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_account(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Create an account using given parameters, see <see cref="Linphone.Core.CreateAccountParams()">
		/// Linphone.Core.CreateAccountParams()</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters"><see cref="Linphone.AccountParams">
		/// Linphone.AccountParams</see> object    </param>
		/// <returns><see cref="Linphone.Account">Linphone.Account</see> with default
		/// values set    </returns>
		public Linphone.Account CreateAccount(Linphone.AccountParams parameters)
		{
			IntPtr ptr = linphone_core_create_account(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			Linphone.Account returnVal = fromNativePtr<Linphone.Account>(ptr, false);
			
			GC.KeepAlive(parameters);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_account_creator(IntPtr thiz, string xmlrpcUrl);

		/// <summary>
		/// Create a <see cref="Linphone.AccountCreator">Linphone.AccountCreator</see> and
		/// set Linphone Request callbacks. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="xmlrpcUrl">The URL to the XML-RPC server.    </param>
		/// <returns>The new <see cref="Linphone.AccountCreator">
		/// Linphone.AccountCreator</see> object.    </returns>
		public Linphone.AccountCreator CreateAccountCreator(string xmlrpcUrl)
		{
			IntPtr ptr = linphone_core_create_account_creator(nativePtr, xmlrpcUrl);
			Linphone.AccountCreator returnVal = fromNativePtr<Linphone.AccountCreator>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_account_params(IntPtr thiz);

		/// <summary>
		/// Create an account params using default values from Linphone core. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.AccountParams">Linphone.AccountParams</see> with
		/// default values set    </returns>
		public Linphone.AccountParams CreateAccountParams()
		{
			IntPtr ptr = linphone_core_create_account_params(nativePtr);
			Linphone.AccountParams returnVal = fromNativePtr<Linphone.AccountParams>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_address(IntPtr thiz, string address);

		/// <summary>
		/// Create a <see cref="Linphone.Address">Linphone.Address</see> object by parsing
		/// the user supplied address, given as a string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address">String containing the user supplied address    </param>
		/// <returns>The create <see cref="Linphone.Address">Linphone.Address</see> object 
		///   </returns>
		public Linphone.Address CreateAddress(string address)
		{
			IntPtr ptr = linphone_core_create_address(nativePtr, address);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_call_log(IntPtr thiz, IntPtr from, IntPtr to, int dir, int duration, long startTime, long connectedTime, int status, char videoEnabled, float quality);

		/// <summary>
		/// Creates a fake <see cref="Linphone.CallLog">Linphone.CallLog</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="from"><see cref="Linphone.Address">Linphone.Address</see> of
		/// caller    </param>
		/// <param name="to"><see cref="Linphone.Address">Linphone.Address</see> of callee 
		///   </param>
		/// <param name="dir"><see cref="Linphone.CallDir">Linphone.CallDir</see> of call
		/// </param>
		/// <param name="duration">call length in seconds </param>
		/// <param name="startTime">timestamp of call start time </param>
		/// <param name="connectedTime">timestamp of call connection </param>
		/// <param name="status"><see cref="Linphone.CallStatus">Linphone.CallStatus</see>
		/// of call </param>
		/// <param name="videoEnabled">whether video was enabled or not for this call
		/// </param>
		/// <param name="quality">call quality </param>
		/// <returns>a <see cref="Linphone.CallLog">Linphone.CallLog</see> object   
		/// </returns>
		public Linphone.CallLog CreateCallLog(Linphone.Address from, Linphone.Address to, Linphone.CallDir dir, int duration, long startTime, long connectedTime, Linphone.CallStatus status, bool videoEnabled, float quality)
		{
			IntPtr ptr = linphone_core_create_call_log(nativePtr, from != null ? from.nativePtr : IntPtr.Zero, to != null ? to.nativePtr : IntPtr.Zero, (int)dir, duration, startTime, connectedTime, (int)status, videoEnabled ? (char)1 : (char)0, quality);
			Linphone.CallLog returnVal = fromNativePtr<Linphone.CallLog>(ptr, false);
			
			GC.KeepAlive(from);
GC.KeepAlive(to);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_call_params(IntPtr thiz, IntPtr call);

		/// <summary>
		/// Create a <see cref="Linphone.CallParams">Linphone.CallParams</see> suitable for
		/// <see cref="Linphone.Core.InviteWithParams()">
		/// Linphone.Core.InviteWithParams()</see>, linphone_core_accept_call_with_params,
		/// linphone_core_accept_early_media_with_params or
		/// linphone_core_accept_call_update. 
		/// <para>
		/// The parameters are initialized according to the current <see cref="Linphone.Core">
		/// Linphone.Core</see> configuration and the last used local <see cref="Linphone.CallParams">
		/// Linphone.CallParams</see>, the ones passed through <see cref="Linphone.Call.Update()">
		/// Linphone.Call.Update()</see>, <see cref="Linphone.Call.AcceptWithParams()">
		/// Linphone.Call.AcceptWithParams()</see> or
		/// linphone_call_accept_update_with_params(). 
		/// </para>
		/// </summary>
		/// <param name="call"><see cref="Linphone.Call">Linphone.Call</see> for which the
		/// parameters are to be build, or null in the case where the parameters are to be
		/// used for a new outgoing call.    </param>
		/// <returns>A new <see cref="Linphone.CallParams">Linphone.CallParams</see>
		/// object.    </returns>
		public Linphone.CallParams CreateCallParams(Linphone.Call call)
		{
			IntPtr ptr = linphone_core_create_call_params(nativePtr, call != null ? call.nativePtr : IntPtr.Zero);
			Linphone.CallParams returnVal = fromNativePtr<Linphone.CallParams>(ptr, false);
			
			GC.KeepAlive(call);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_chat_room_6(IntPtr thiz, IntPtr parameters, IntPtr localAddr, IntPtr participants);

		/// <summary>
		/// Create a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The chat room creation parameters <see cref="Linphone.ChatRoomParams">
		/// Linphone.ChatRoomParams</see>    </param>
		/// <param name="localAddr"><see cref="Linphone.Address">Linphone.Address</see>
		/// representing the local proxy configuration to use for the chat room creation or
		/// null    </param>
		/// <param name="participants">The initial list of participants of the chat room.  
		///    </param>
		/// <returns>The newly created chat room (can be an existing one if backend is
		/// Basic) or null.    </returns>
		public Linphone.ChatRoom CreateChatRoom(Linphone.ChatRoomParams parameters, Linphone.Address localAddr, IEnumerable<Linphone.Address> participants)
		{
			IntPtr ptr = linphone_core_create_chat_room_6(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero, ObjectArrayToBctbxList<Linphone.Address>(participants));
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
			GC.KeepAlive(parameters);
GC.KeepAlive(localAddr);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_chat_room(IntPtr thiz, IntPtr parameters, IntPtr localAddr, string subject, IntPtr participants);

		/// <summary>
		/// Create a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The chat room creation parameters <see cref="Linphone.ChatRoomParams">
		/// Linphone.ChatRoomParams</see>    </param>
		/// <param name="localAddr"><see cref="Linphone.Address">Linphone.Address</see>
		/// representing the local proxy configuration to use for the chat room creation   
		/// </param>
		/// <param name="subject">The subject of the group chat room    </param>
		/// <param name="participants">The initial list of participants of the chat room   
		///   </param>
		/// <returns>The newly created chat room.    </returns>
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()">
		/// Linphone.Core.CreateChatRoom()</see> instead
		public Linphone.ChatRoom CreateChatRoom(Linphone.ChatRoomParams parameters, Linphone.Address localAddr, string subject, IEnumerable<Linphone.Address> participants)
		{
			IntPtr ptr = linphone_core_create_chat_room(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero, subject, ObjectArrayToBctbxList<Linphone.Address>(participants));
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
			GC.KeepAlive(parameters);
GC.KeepAlive(localAddr);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_chat_room_2(IntPtr thiz, IntPtr parameters, string subject, IntPtr participants);

		/// <summary>
		/// Create a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The chat room creation parameters <see cref="Linphone.ChatRoomParams">
		/// Linphone.ChatRoomParams</see>    </param>
		/// <param name="subject">The subject of the group chat room    </param>
		/// <param name="participants">The initial list of participants of the chat room.  
		///    </param>
		/// <returns>The newly created chat room.    </returns>
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()">
		/// Linphone.Core.CreateChatRoom()</see> instead
		public Linphone.ChatRoom CreateChatRoom(Linphone.ChatRoomParams parameters, string subject, IEnumerable<Linphone.Address> participants)
		{
			IntPtr ptr = linphone_core_create_chat_room_2(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero, subject, ObjectArrayToBctbxList<Linphone.Address>(participants));
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
			GC.KeepAlive(parameters);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_chat_room_3(IntPtr thiz, string subject, IntPtr participants);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="subject">The subject of the group chat room    </param>
		/// <param name="participants">The initial list of participants of the chat room.  
		///    </param>
		/// <returns>The newly created chat room.    </returns>
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()">
		/// Linphone.Core.CreateChatRoom()</see> instead
		public Linphone.ChatRoom CreateChatRoom(string subject, IEnumerable<Linphone.Address> participants)
		{
			IntPtr ptr = linphone_core_create_chat_room_3(nativePtr, subject, ObjectArrayToBctbxList<Linphone.Address>(participants));
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_chat_room_4(IntPtr thiz, IntPtr parameters, IntPtr localAddr, IntPtr participant);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The chat room creation parameters <see cref="Linphone.ChatRoomParams">
		/// Linphone.ChatRoomParams</see>    </param>
		/// <param name="localAddr"><see cref="Linphone.Address">Linphone.Address</see>
		/// representing the local proxy configuration to use for the chat room creation   
		/// </param>
		/// <param name="participant"><see cref="Linphone.Address">Linphone.Address</see>
		/// representing the initial participant to add to the chat room    </param>
		/// <returns>The newly created chat room.    </returns>
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()">
		/// Linphone.Core.CreateChatRoom()</see> instead
		public Linphone.ChatRoom CreateChatRoom(Linphone.ChatRoomParams parameters, Linphone.Address localAddr, Linphone.Address participant)
		{
			IntPtr ptr = linphone_core_create_chat_room_4(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero, participant != null ? participant.nativePtr : IntPtr.Zero);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
			GC.KeepAlive(parameters);
GC.KeepAlive(localAddr);
GC.KeepAlive(participant);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_chat_room_5(IntPtr thiz, IntPtr participant);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="participant"><see cref="Linphone.Address">Linphone.Address</see>
		/// representing the initial participant to add to the chat room    </param>
		/// <returns>The newly created chat room.    </returns>
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()">
		/// Linphone.Core.CreateChatRoom()</see> instead
		public Linphone.ChatRoom CreateChatRoom(Linphone.Address participant)
		{
			IntPtr ptr = linphone_core_create_chat_room_5(nativePtr, participant != null ? participant.nativePtr : IntPtr.Zero);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
			GC.KeepAlive(participant);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_client_group_chat_room(IntPtr thiz, string subject, char fallback);

		/// <summary>
		/// Create a client-side group chat room. 
		/// <para>
		/// When calling this function the chat room is only created at the client-side and
		/// is empty. You need to call <see cref="Linphone.ChatRoom.AddParticipants()">
		/// Linphone.ChatRoom.AddParticipants()</see> to create at the server side and add
		/// participants to it. Also, the created chat room will not be a one-to-one chat
		/// room even if <see cref="Linphone.ChatRoom.AddParticipants()">
		/// Linphone.ChatRoom.AddParticipants()</see> is called with only one participant.
		/// </para>
		/// </summary>
		/// <param name="subject">The subject of the group chat room    </param>
		/// <param name="fallback">Boolean value telling whether we should plan on being
		/// able to fallback to a basic chat room if the client-side group chat room
		/// creation fails </param>
		/// <returns>The newly created client-side group chat room.    </returns>
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()">
		/// Linphone.Core.CreateChatRoom()</see> instead
		public Linphone.ChatRoom CreateClientGroupChatRoom(string subject, bool fallback)
		{
			IntPtr ptr = linphone_core_create_client_group_chat_room(nativePtr, subject, fallback ? (char)1 : (char)0);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_client_group_chat_room_2(IntPtr thiz, string subject, char fallback, char encrypted);

		/// <summary>
		/// Create a client-side group chat room. 
		/// <para>
		/// When calling this function the chat room is only created at the client-side and
		/// is empty. You need to call <see cref="Linphone.ChatRoom.AddParticipants()">
		/// Linphone.ChatRoom.AddParticipants()</see> to create at the server side and add
		/// participants to it. Also, the created chat room will not be a one-to-one chat
		/// room even if <see cref="Linphone.ChatRoom.AddParticipants()">
		/// Linphone.ChatRoom.AddParticipants()</see> is called with only one participant.
		/// </para>
		/// </summary>
		/// <param name="subject">The subject of the group chat room    </param>
		/// <param name="fallback">Boolean value telling whether we should plan on being
		/// able to fallback to a basic chat room if the client-side group chat room
		/// creation fails </param>
		/// <param name="encrypted">Boolean value telling whether we should apply
		/// encryption or not on chat messages sent and received on this room. </param>
		/// <returns>The newly created client-side group chat room.    </returns>
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.CreateChatRoom()">
		/// Linphone.Core.CreateChatRoom()</see> instead
		public Linphone.ChatRoom CreateClientGroupChatRoom(string subject, bool fallback, bool encrypted)
		{
			IntPtr ptr = linphone_core_create_client_group_chat_room_2(nativePtr, subject, fallback ? (char)1 : (char)0, encrypted ? (char)1 : (char)0);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_conference_params_2(IntPtr thiz, IntPtr conference);

		/// <summary>
		/// Create some default conference parameters for instanciating a conference with
		/// <see cref="Linphone.Core.CreateConferenceWithParams()">
		/// Linphone.Core.CreateConferenceWithParams()</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conference"><see cref="Linphone.Conference">
		/// Linphone.Conference</see> for which the parameters are to be build, or null in
		/// the case where the parameters are to be used for a new conference.    </param>
		/// <returns>a <see cref="Linphone.ConferenceParams">
		/// Linphone.ConferenceParams</see> object.    </returns>
		public Linphone.ConferenceParams CreateConferenceParams(Linphone.Conference conference)
		{
			IntPtr ptr = linphone_core_create_conference_params_2(nativePtr, conference != null ? conference.nativePtr : IntPtr.Zero);
			Linphone.ConferenceParams returnVal = fromNativePtr<Linphone.ConferenceParams>(ptr, false);
			
			GC.KeepAlive(conference);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_conference_scheduler(IntPtr thiz);

		/// <summary>
		/// Create a conference scheduler that can be used to create remote conferences for
		/// now or later and then send conference info as an ICS through chat. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer on the freshly created <see cref="Linphone.ConferenceScheduler">
		/// Linphone.ConferenceScheduler</see>.    </returns>
		public Linphone.ConferenceScheduler CreateConferenceScheduler()
		{
			IntPtr ptr = linphone_core_create_conference_scheduler(nativePtr);
			Linphone.ConferenceScheduler returnVal = fromNativePtr<Linphone.ConferenceScheduler>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_conference_with_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Create a conference. 
		/// <para>
		/// Local or remote conference is determinated from the &apos;conference_type&apos;
		/// variable in the &apos;misc&apos; section of the configuration, or by the
		/// factory address parameter. See <see cref="Linphone.ConferenceParams.ConferenceFactoryAddress">
		/// Linphone.ConferenceParams.ConferenceFactoryAddress</see> for more details. 
		/// </para>
		/// </summary>
		/// <param name="parameters">Parameters of the conference. See <see cref="Linphone.ConferenceParams">
		/// Linphone.ConferenceParams</see>.    </param>
		/// <returns>A pointer on the freshly created conference <see cref="Linphone.Conference">
		/// Linphone.Conference</see>. That object will be automatically freed by the core
		/// after calling <see cref="Linphone.Core.TerminateConference()">
		/// Linphone.Core.TerminateConference()</see>.    </returns>
		public Linphone.Conference CreateConferenceWithParams(Linphone.ConferenceParams parameters)
		{
			IntPtr ptr = linphone_core_create_conference_with_params(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			Linphone.Conference returnVal = fromNativePtr<Linphone.Conference>(ptr, false);
			
			GC.KeepAlive(parameters);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_config(IntPtr thiz, string filename);

		/// <summary>
		/// Create a <see cref="Linphone.Config">Linphone.Config</see> object from a user
		/// config file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filename">The filename of the config file to read to fill the
		/// instantiated <see cref="Linphone.Config">Linphone.Config</see>    </param>
		/// <returns>a <see cref="Linphone.Config">Linphone.Config</see> object.   
		/// </returns>
		public Linphone.Config CreateConfig(string filename)
		{
			IntPtr ptr = linphone_core_create_config(nativePtr, filename);
			Linphone.Config returnVal = fromNativePtr<Linphone.Config>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_content(IntPtr thiz);

		/// <summary>
		/// Create a content with default values from Linphone core. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.Content">Linphone.Content</see> object with
		/// default values set    </returns>
		public Linphone.Content CreateContent()
		{
			IntPtr ptr = linphone_core_create_content(nativePtr);
			Linphone.Content returnVal = fromNativePtr<Linphone.Content>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_default_chat_room_params(IntPtr thiz);

		/// <summary>
		/// Creates and returns the default chat room parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.ChatRoomParams">Linphone.ChatRoomParams</see>
		/// object    </returns>
		public Linphone.ChatRoomParams CreateDefaultChatRoomParams()
		{
			IntPtr ptr = linphone_core_create_default_chat_room_params(nativePtr);
			Linphone.ChatRoomParams returnVal = fromNativePtr<Linphone.ChatRoomParams>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_friend(IntPtr thiz);

		/// <summary>
		/// Create a default LinphoneFriend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The created <see cref="Linphone.Friend">Linphone.Friend</see> object  
		///  </returns>
		public Linphone.Friend CreateFriend()
		{
			IntPtr ptr = linphone_core_create_friend(nativePtr);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_friend_list(IntPtr thiz);

		/// <summary>
		/// Create a new empty <see cref="Linphone.FriendList">Linphone.FriendList</see>
		/// object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A new <see cref="Linphone.FriendList">Linphone.FriendList</see>
		/// object.    </returns>
		public Linphone.FriendList CreateFriendList()
		{
			IntPtr ptr = linphone_core_create_friend_list(nativePtr);
			Linphone.FriendList returnVal = fromNativePtr<Linphone.FriendList>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_friend_with_address(IntPtr thiz, string address);

		/// <summary>
		/// Create a <see cref="Linphone.Friend">Linphone.Friend</see> from the given
		/// address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address">A string containing the address to create the <see cref="Linphone.Friend">
		/// Linphone.Friend</see> from    </param>
		/// <returns>The created <see cref="Linphone.Friend">Linphone.Friend</see> object. 
		///   </returns>
		public Linphone.Friend CreateFriendWithAddress(string address)
		{
			IntPtr ptr = linphone_core_create_friend_with_address(nativePtr, address);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_info_message(IntPtr thiz);

		/// <summary>
		/// Creates an empty info message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a new LinphoneInfoMessage.   </returns>
		/// The info message can later be filled with information using <see cref="Linphone.InfoMessage.AddHeader()">
		/// Linphone.InfoMessage.AddHeader()</see> or <see cref="Linphone.InfoMessage.Content">
		/// Linphone.InfoMessage.Content</see>, and finally sent with
		/// linphone_core_send_info_message(). 
		public Linphone.InfoMessage CreateInfoMessage()
		{
			IntPtr ptr = linphone_core_create_info_message(nativePtr);
			Linphone.InfoMessage returnVal = fromNativePtr<Linphone.InfoMessage>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_ldap(IntPtr thiz);

		/// <summary>
		/// Create an empty LDAP search. 
		/// <para>
		/// <see cref="Linphone.Ldap.Params">Linphone.Ldap.Params</see> must be call to
		/// save the parameters in the configuration file.
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.Ldap">Linphone.Ldap</see> with default values set 
		///      </returns>
		public Linphone.Ldap CreateLdap()
		{
			IntPtr ptr = linphone_core_create_ldap(nativePtr);
			Linphone.Ldap returnVal = fromNativePtr<Linphone.Ldap>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_ldap_params(IntPtr thiz);

		/// <summary>
		/// Create a LDAP params using default values from Linphone core. 
		/// <para>
		/// Check #linphone_ldap_params to update values. In order to add a new LDAP
		/// configuration to Magic search, these parameters must be passed to
		/// linphone_core_create_ldap_with_params. Or, use <see cref="Linphone.Ldap.Params">
		/// Linphone.Ldap.Params</see>.
		/// The newly created LDAP from <see cref="Linphone.Core.CreateLdap()">
		/// Linphone.Core.CreateLdap()</see>.
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.LdapParams">Linphone.LdapParams</see> with default
		/// values set.       </returns>
		public Linphone.LdapParams CreateLdapParams()
		{
			IntPtr ptr = linphone_core_create_ldap_params(nativePtr);
			Linphone.LdapParams returnVal = fromNativePtr<Linphone.LdapParams>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_ldap_with_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Create a LDAP search using given parameters and store them in the configuration
		/// file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters"><see cref="Linphone.LdapParams">
		/// Linphone.LdapParams</see> object    </param>
		/// <returns><see cref="Linphone.Ldap">Linphone.Ldap</see> with default values set 
		///      </returns>
		public Linphone.Ldap CreateLdapWithParams(Linphone.LdapParams parameters)
		{
			IntPtr ptr = linphone_core_create_ldap_with_params(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			Linphone.Ldap returnVal = fromNativePtr<Linphone.Ldap>(ptr, false);
			
			GC.KeepAlive(parameters);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_local_player(IntPtr thiz, string soundCardName, string videoDisplayName, IntPtr windowId);

		/// <summary>
		/// Create an independent media file player. 
		/// <para>
		/// This player support WAVE and MATROSKA formats. 
		/// </para>
		/// </summary>
		/// <param name="soundCardName">Playback sound card. If null, the ringer sound card
		/// set in <see cref="Linphone.Core">Linphone.Core</see> will be used    </param>
		/// <param name="videoDisplayName">Video display. If null, the video display set in
		/// <see cref="Linphone.Core">Linphone.Core</see> will be used    </param>
		/// <param name="windowId">Id of the drawing window. Depend of video out    </param>
		/// <returns>A pointer on the new instance. null if failed.    </returns>
		public Linphone.Player CreateLocalPlayer(string soundCardName, string videoDisplayName, IntPtr windowId)
		{
			IntPtr ptr = linphone_core_create_local_player(nativePtr, soundCardName, videoDisplayName, windowId);
			Linphone.Player returnVal = fromNativePtr<Linphone.Player>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_magic_search(IntPtr thiz);

		/// <summary>
		/// Create a <see cref="Linphone.MagicSearch">Linphone.MagicSearch</see> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The created <see cref="Linphone.MagicSearch">
		/// Linphone.MagicSearch</see> object    </returns>
		public Linphone.MagicSearch CreateMagicSearch()
		{
			IntPtr ptr = linphone_core_create_magic_search(nativePtr);
			Linphone.MagicSearch returnVal = fromNativePtr<Linphone.MagicSearch>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_nat_policy(IntPtr thiz);

		/// <summary>
		/// Create a new <see cref="Linphone.NatPolicy">Linphone.NatPolicy</see> object
		/// with every policies being disabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A new <see cref="Linphone.NatPolicy">Linphone.NatPolicy</see> object. 
		///   </returns>
		public Linphone.NatPolicy CreateNatPolicy()
		{
			IntPtr ptr = linphone_core_create_nat_policy(nativePtr);
			Linphone.NatPolicy returnVal = fromNativePtr<Linphone.NatPolicy>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_native_preview_window_id(IntPtr thiz);

		/// <summary>
		/// Create a native window handle for the video preview window. 
		/// <para>
		/// see linphone_core_set_native_video_window_id for details about window_id
		/// MSQOgl can be used for the creation. <see cref="Linphone.Core.CreateNativePreviewWindowId()">
		/// Linphone.Core.CreateNativePreviewWindowId()</see> returns a
		/// #QQuickFramebufferObject::Renderer. This object must be returned by your
		/// QQuickFramebufferObject::createRenderer() overload for Qt.
		/// linphone_core_set_native_preview_window_id must be called with this object
		/// after the creation. Note : Qt blocks GUI thread when calling createRenderer(),
		/// so it is safe to call linphone functions there if needed.
		/// </para>
		/// </summary>
		/// <returns>The native window handle of the video preview window.    </returns>
		public IntPtr CreateNativePreviewWindowId()
		{
			IntPtr returnVal = linphone_core_create_native_preview_window_id(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_native_video_window_id(IntPtr thiz);

		/// <summary>
		/// Create a native window handle for the video window. 
		/// <para>
		/// see linphone_core_set_native_video_window_id for details about window_id
		/// MSQOgl can be used for the creation. <see cref="Linphone.Core.CreateNativeVideoWindowId()">
		/// Linphone.Core.CreateNativeVideoWindowId()</see> returns a
		/// #QQuickFramebufferObject::Renderer. This object must be returned by your
		/// QQuickFramebufferObject::createRenderer() overload for Qt.
		/// linphone_core_set_native_video_window_id must be called with this object after
		/// the creation. Note : Qt blocks GUI thread when calling createRenderer(), so it
		/// is safe to call linphone functions there if needed.
		/// </para>
		/// </summary>
		/// <returns>The native window handle of the video window.    </returns>
		public IntPtr CreateNativeVideoWindowId()
		{
			IntPtr returnVal = linphone_core_create_native_video_window_id(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_notify(IntPtr thiz, IntPtr resource, string ev);

		/// <summary>
		/// Create an out-of-dialog notification, specifying the destination resource, the
		/// event name. 
		/// <para>
		/// The notification can be send with <see cref="Linphone.Event.Notify()">
		/// Linphone.Event.Notify()</see>. 
		/// </para>
		/// </summary>
		/// <param name="resource">the destination resource    </param>
		/// <param name="ev">the event name    </param>
		/// <returns>a <see cref="Linphone.Event">Linphone.Event</see> holding the context
		/// of the notification.    </returns>
		public Linphone.Event CreateNotify(Linphone.Address resource, string ev)
		{
			IntPtr ptr = linphone_core_create_notify(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, ev);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, false);
			
			GC.KeepAlive(resource);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_one_shot_publish(IntPtr thiz, IntPtr resource, string ev);

		/// <summary>
		/// Create a publish context for a one-shot publish. 
		/// <para>
		/// After being created, the publish must be sent using <see cref="Linphone.Event.SendPublish()">
		/// Linphone.Event.SendPublish()</see>. The <see cref="Linphone.Event">
		/// Linphone.Event</see> is automatically terminated when the publish transaction
		/// is finished, either with success or failure. The application must not call <see cref="Linphone.Event.Terminate()">
		/// Linphone.Event.Terminate()</see> for such one-shot publish. 
		/// </para>
		/// </summary>
		/// <param name="resource">the resource uri for the event    </param>
		/// <param name="ev">the event name    </param>
		/// <returns>the <see cref="Linphone.Event">Linphone.Event</see> holding the
		/// context of the publish.    </returns>
		public Linphone.Event CreateOneShotPublish(Linphone.Address resource, string ev)
		{
			IntPtr ptr = linphone_core_create_one_shot_publish(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, ev);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, false);
			
			GC.KeepAlive(resource);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_activity(IntPtr thiz, int acttype, string description);

		/// <summary>
		/// Create a <see cref="Linphone.PresenceActivity">Linphone.PresenceActivity</see>
		/// with the given type and description. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="acttype">The <see cref="Linphone.PresenceActivityType">
		/// Linphone.PresenceActivityType</see> to set for the activity. </param>
		/// <param name="description">An additional description of the activity to set for
		/// the activity. Can be null if no additional description is to be added.   
		/// </param>
		/// <returns>The created <see cref="Linphone.PresenceActivity">
		/// Linphone.PresenceActivity</see> object.    </returns>
		public Linphone.PresenceActivity CreatePresenceActivity(Linphone.PresenceActivityType acttype, string description)
		{
			IntPtr ptr = linphone_core_create_presence_activity(nativePtr, (int)acttype, description);
			Linphone.PresenceActivity returnVal = fromNativePtr<Linphone.PresenceActivity>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_model(IntPtr thiz);

		/// <summary>
		/// Create a default LinphonePresenceModel. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The created <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object.    </returns>
		public Linphone.PresenceModel CreatePresenceModel()
		{
			IntPtr ptr = linphone_core_create_presence_model(nativePtr);
			Linphone.PresenceModel returnVal = fromNativePtr<Linphone.PresenceModel>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_model_with_activity(IntPtr thiz, int acttype, string description);

		/// <summary>
		/// Create a <see cref="Linphone.PresenceModel">Linphone.PresenceModel</see> with
		/// the given activity type and activity description. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="acttype">The <see cref="Linphone.PresenceActivityType">
		/// Linphone.PresenceActivityType</see> to set for the activity of the created
		/// model. </param>
		/// <param name="description">An additional description of the activity to set for
		/// the activity. Can be null if no additional description is to be added.   
		/// </param>
		/// <returns>The created <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object.    </returns>
		public Linphone.PresenceModel CreatePresenceModelWithActivity(Linphone.PresenceActivityType acttype, string description)
		{
			IntPtr ptr = linphone_core_create_presence_model_with_activity(nativePtr, (int)acttype, description);
			Linphone.PresenceModel returnVal = fromNativePtr<Linphone.PresenceModel>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_model_with_activity_and_note(IntPtr thiz, int acttype, string description, string note, string lang);

		/// <summary>
		/// Create a <see cref="Linphone.PresenceModel">Linphone.PresenceModel</see> with
		/// the given activity type, activity description, note content and note language. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="acttype">The <see cref="Linphone.PresenceActivityType">
		/// Linphone.PresenceActivityType</see> to set for the activity of the created
		/// model. </param>
		/// <param name="description">An additional description of the activity to set for
		/// the activity. Can be null if no additional description is to be added.   
		/// </param>
		/// <param name="note">The content of the note to be added to the created model.   
		/// </param>
		/// <param name="lang">The language of the note to be added to the created model.  
		///  </param>
		/// <returns>The created <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object.    </returns>
		public Linphone.PresenceModel CreatePresenceModelWithActivityAndNote(Linphone.PresenceActivityType acttype, string description, string note, string lang)
		{
			IntPtr ptr = linphone_core_create_presence_model_with_activity_and_note(nativePtr, (int)acttype, description, note, lang);
			Linphone.PresenceModel returnVal = fromNativePtr<Linphone.PresenceModel>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_note(IntPtr thiz, string content, string lang);

		/// <summary>
		/// Create a <see cref="Linphone.PresenceNote">Linphone.PresenceNote</see> with the
		/// given content and language. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">The content of the note to be created.    </param>
		/// <param name="lang">The language of the note to be created.    </param>
		/// <returns>The created <see cref="Linphone.PresenceNote">
		/// Linphone.PresenceNote</see> object.    </returns>
		public Linphone.PresenceNote CreatePresenceNote(string content, string lang)
		{
			IntPtr ptr = linphone_core_create_presence_note(nativePtr, content, lang);
			Linphone.PresenceNote returnVal = fromNativePtr<Linphone.PresenceNote>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_person(IntPtr thiz, string id);

		/// <summary>
		/// Create a <see cref="Linphone.PresencePerson">Linphone.PresencePerson</see> with
		/// the given id. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="id">The id of the person to be created.    </param>
		/// <returns>The created <see cref="Linphone.PresencePerson">
		/// Linphone.PresencePerson</see> object.    </returns>
		public Linphone.PresencePerson CreatePresencePerson(string id)
		{
			IntPtr ptr = linphone_core_create_presence_person(nativePtr, id);
			Linphone.PresencePerson returnVal = fromNativePtr<Linphone.PresencePerson>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_presence_service(IntPtr thiz, string id, int basicStatus, string contact);

		/// <summary>
		/// Create a <see cref="Linphone.PresenceService">Linphone.PresenceService</see>
		/// with the given id, basic status and contact. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="id">The id of the service to be created.    </param>
		/// <param name="basicStatus">The basic status of the service to be created.
		/// </param>
		/// <param name="contact">A string containing a contact information corresponding
		/// to the service to be created.    </param>
		/// <returns>The created <see cref="Linphone.PresenceService">
		/// Linphone.PresenceService</see> object.    </returns>
		public Linphone.PresenceService CreatePresenceService(string id, Linphone.PresenceBasicStatus basicStatus, string contact)
		{
			IntPtr ptr = linphone_core_create_presence_service(nativePtr, id, (int)basicStatus, contact);
			Linphone.PresenceService returnVal = fromNativePtr<Linphone.PresenceService>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_primary_contact_parsed(IntPtr thiz);

		/// <summary>
		/// Same as <see cref="Linphone.Core.PrimaryContact">
		/// Linphone.Core.PrimaryContact</see> but the result is a <see cref="Linphone.Address">
		/// Linphone.Address</see> object instead of const char *. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Address">Linphone.Address</see> object.   
		/// </returns>
		public Linphone.Address CreatePrimaryContactParsed()
		{
			IntPtr ptr = linphone_core_create_primary_contact_parsed(nativePtr);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_proxy_config(IntPtr thiz);

		/// <summary>
		/// Create a proxy config with default values from Linphone core. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.ProxyConfig">Linphone.ProxyConfig</see> with
		/// default values set    </returns>
		public Linphone.ProxyConfig CreateProxyConfig()
		{
			IntPtr ptr = linphone_core_create_proxy_config(nativePtr);
			Linphone.ProxyConfig returnVal = fromNativePtr<Linphone.ProxyConfig>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_publish(IntPtr thiz, IntPtr resource, string ev, int expires);

		/// <summary>
		/// Create a publish context for an event state. 
		/// <para>
		/// After being created, the publish must be sent using <see cref="Linphone.Event.SendPublish()">
		/// Linphone.Event.SendPublish()</see>. After expiry, the publication is refreshed
		/// unless it is terminated before. 
		/// </para>
		/// </summary>
		/// <param name="resource">the resource uri for the event    </param>
		/// <param name="ev">the event name    </param>
		/// <param name="expires">the lifetime of event being published, -1 if no
		/// associated duration, in which case it will not be refreshed. </param>
		/// <returns>the <see cref="Linphone.Event">Linphone.Event</see> holding the
		/// context of the publish.    </returns>
		public Linphone.Event CreatePublish(Linphone.Address resource, string ev, int expires)
		{
			IntPtr ptr = linphone_core_create_publish(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, ev, expires);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, false);
			
			GC.KeepAlive(resource);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_recorder(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Create a media file recorder. 
		/// <para>
		/// This recorder support WAVE and MATROSKA formats. 
		/// </para>
		/// </summary>
		/// <param name="parameters">The <see cref="Linphone.RecorderParams">
		/// Linphone.RecorderParams</see> that will contains all recorder parameters.   
		/// </param>
		/// <returns>A pointer on the new instance. null if failed.    </returns>
		public Linphone.Recorder CreateRecorder(Linphone.RecorderParams parameters)
		{
			IntPtr ptr = linphone_core_create_recorder(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			Linphone.Recorder returnVal = fromNativePtr<Linphone.Recorder>(ptr, false);
			
			GC.KeepAlive(parameters);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_recorder_params(IntPtr thiz);

		/// <summary>
		/// Create a recorder params that will hold parameters. 
		/// <para>
		/// This recorder support WAVE and MATROSKA formats. 
		/// </para>
		/// </summary>
		/// <returns>A pointer on the newly created instance.    </returns>
		public Linphone.RecorderParams CreateRecorderParams()
		{
			IntPtr ptr = linphone_core_create_recorder_params(nativePtr);
			Linphone.RecorderParams returnVal = fromNativePtr<Linphone.RecorderParams>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_subscribe(IntPtr thiz, IntPtr resource, string ev, int expires);

		/// <summary>
		/// Create an outgoing subscription, specifying the destination resource, the event
		/// name, and an optional content body. 
		/// <para>
		/// If accepted, the subscription runs for a finite period, but is automatically
		/// renewed if not terminated before. Unlike <see cref="Linphone.Core.Subscribe()">
		/// Linphone.Core.Subscribe()</see> the subscription isn&apos;t sent immediately.
		/// It will be send when calling <see cref="Linphone.Event.SendSubscribe()">
		/// Linphone.Event.SendSubscribe()</see>. 
		/// </para>
		/// </summary>
		/// <param name="resource">the destination resource    </param>
		/// <param name="ev">the event name    </param>
		/// <param name="expires">the whished duration of the subscription </param>
		/// <returns>a <see cref="Linphone.Event">Linphone.Event</see> holding the context
		/// of the created subcription.    </returns>
		public Linphone.Event CreateSubscribe(Linphone.Address resource, string ev, int expires)
		{
			IntPtr ptr = linphone_core_create_subscribe(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, ev, expires);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, false);
			
			GC.KeepAlive(resource);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_subscribe_2(IntPtr thiz, IntPtr resource, IntPtr proxy, string ev, int expires);

		/// <summary>
		/// Create an outgoing subscription, specifying the destination resource, the event
		/// name, and an optional content body. 
		/// <para>
		/// If accepted, the subscription runs for a finite period, but is automatically
		/// renewed if not terminated before. Unlike <see cref="Linphone.Core.Subscribe()">
		/// Linphone.Core.Subscribe()</see> the subscription isn&apos;t sent immediately.
		/// It will be send when calling <see cref="Linphone.Event.SendSubscribe()">
		/// Linphone.Event.SendSubscribe()</see>. 
		/// </para>
		/// </summary>
		/// <param name="resource">the destination resource    </param>
		/// <param name="proxy">the proxy configuration to use    </param>
		/// <param name="ev">the event name    </param>
		/// <param name="expires">the whished duration of the subscription </param>
		/// <returns>a <see cref="Linphone.Event">Linphone.Event</see> holding the context
		/// of the created subcription.    </returns>
		public Linphone.Event CreateSubscribe(Linphone.Address resource, Linphone.ProxyConfig proxy, string ev, int expires)
		{
			IntPtr ptr = linphone_core_create_subscribe_2(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, proxy != null ? proxy.nativePtr : IntPtr.Zero, ev, expires);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, false);
			
			GC.KeepAlive(resource);
GC.KeepAlive(proxy);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_create_xml_rpc_session(IntPtr thiz, string url);

		/// <summary>
		/// Create a <see cref="Linphone.XmlRpcSession">Linphone.XmlRpcSession</see> for a
		/// given url. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="url">The URL to the XML-RPC server. Must be NON null.    </param>
		/// <returns>The new <see cref="Linphone.XmlRpcSession">
		/// Linphone.XmlRpcSession</see> object.    </returns>
		public Linphone.XmlRpcSession CreateXmlRpcSession(string url)
		{
			IntPtr ptr = linphone_core_create_xml_rpc_session(nativePtr, url);
			Linphone.XmlRpcSession returnVal = fromNativePtr<Linphone.XmlRpcSession>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_delete_chat_room(IntPtr thiz, IntPtr chatRoom);

		/// <summary>
		/// Removes a chatroom including all message history from the LinphoneCore. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatRoom">A <see cref="Linphone.ChatRoom">Linphone.ChatRoom</see>
		/// object    </param>
		public void DeleteChatRoom(Linphone.ChatRoom chatRoom)
		{
			linphone_core_delete_chat_room(nativePtr, chatRoom != null ? chatRoom.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(chatRoom);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_delete_conference_information(IntPtr thiz, IntPtr conferenceInfo);

		/// <summary>
		/// Deletes a conference information from DB. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conferenceInfo">the <see cref="Linphone.ConferenceInfo">
		/// Linphone.ConferenceInfo</see> to delete.    </param>
		public void DeleteConferenceInformation(Linphone.ConferenceInfo conferenceInfo)
		{
			linphone_core_delete_conference_information(nativePtr, conferenceInfo != null ? conferenceInfo.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(conferenceInfo);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_did_register_for_remote_push(IntPtr thiz, IntPtr deviceToken);

		/// <summary>
		/// Sets device_token when application
		/// didRegisterForRemoteNotificationsWithDeviceToken (IOS only). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="deviceToken">format (NSData *).    </param>
		public void DidRegisterForRemotePush(IntPtr deviceToken)
		{
			linphone_core_did_register_for_remote_push(nativePtr, deviceToken);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_did_register_for_remote_push_with_stringified_token(IntPtr thiz, string deviceTokenStr);

		/// <summary>
		/// Sets device_token when application
		/// didRegisterForRemoteNotificationsWithDeviceToken (IOS only). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="deviceTokenStr">string extracted from the Data objectf received in
		/// didRegisterForRemoteNotificationsWithDeviceToken ios function. Append
		/// &quot;:remote&quot; after data formating..    </param>
		public void DidRegisterForRemotePushWithStringifiedToken(string deviceTokenStr)
		{
			linphone_core_did_register_for_remote_push_with_stringified_token(nativePtr, deviceTokenStr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_disable_chat(IntPtr thiz, int denyReason);

		/// <summary>
		/// Inconditionnaly disable incoming chat messages. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="denyReason">the deny reason (<see cref="Linphone.Reason.None">
		/// Linphone.Reason.None</see> has no effect). </param>
		public void DisableChat(Linphone.Reason denyReason)
		{
			linphone_core_disable_chat(nativePtr, (int)denyReason);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enable_chat(IntPtr thiz);

		/// <summary>
		/// Enable reception of incoming chat messages. 
		/// <para>
		/// By default it is enabled but it can be disabled with <see cref="Linphone.Core.DisableChat()">
		/// Linphone.Core.DisableChat()</see>. 
		/// </para>
		/// </summary>
		public void EnableChat()
		{
			linphone_core_enable_chat(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_ensure_registered(IntPtr thiz);

		/// <summary>
		/// Call this method when you receive a push notification (if you handle push
		/// notifications manually). 
		/// <para>
		/// It will ensure the proxy configs are correctly registered to the proxy server,
		/// so the call or the message will be correctly delivered. 
		/// </para>
		/// </summary>
		/// deprecated : 09/03/2022 See <see cref="Linphone.Core.ProcessPushNotification()">
		/// Linphone.Core.ProcessPushNotification()</see> instead. 
		public void EnsureRegistered()
		{
			linphone_core_ensure_registered(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enter_background(IntPtr thiz);

		/// <summary>
		/// This method is called by the application to notify the linphone core library
		/// when it enters background mode. 
		/// <para>
		/// </para>
		/// </summary>
		public void EnterBackground()
		{
			linphone_core_enter_background(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_enter_conference(IntPtr thiz);

		/// <summary>
		/// Join the local participant to the running conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if succeeded. Negative number if failed </returns>
		/// deprecated : 09/03/2021 Use <see cref="Linphone.Conference.Enter()">
		/// Linphone.Conference.Enter()</see> instead. 
		public void EnterConference()
		{
			int exception_result = linphone_core_enter_conference(nativePtr);
			if (exception_result != 0) throw new LinphoneException("EnterConference returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_enter_foreground(IntPtr thiz);

		/// <summary>
		/// This method is called by the application to notify the linphone core library
		/// when it enters foreground mode. 
		/// <para>
		/// </para>
		/// </summary>
		public void EnterForeground()
		{
			linphone_core_enter_foreground(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_file_format_supported(IntPtr thiz, string fmt);

		/// <summary>
		/// Returns whether a specific file format is supported. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>See : linphone_core_get_supported_file_formats </remarks>
		/// <param name="fmt">The format extension (wav, mkv).    </param>
		/// <returns>true if the file format is supported, false otherwise </returns>
		public bool FileFormatSupported(string fmt)
		{
			bool returnVal = linphone_core_file_format_supported(nativePtr, fmt) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_auth_info(IntPtr thiz, string realm, string username, string sipDomain);

		/// <summary>
		/// Find authentication info matching realm, username, domain criteria. 
		/// <para>
		/// First of all, (realm,username) pair are searched. If multiple results (which
		/// should not happen because realm are supposed to be unique), then domain is
		/// added to the search. 
		/// </para>
		/// </summary>
		/// <param name="realm">the authentication &apos;realm&apos; (optional)    </param>
		/// <param name="username">the SIP username to be authenticated (mandatory)   
		/// </param>
		/// <param name="sipDomain">the SIP domain name (optional)    </param>
		/// <returns>a <see cref="Linphone.AuthInfo">Linphone.AuthInfo</see> if found.   
		/// </returns>
		public Linphone.AuthInfo FindAuthInfo(string realm, string username, string sipDomain)
		{
			IntPtr ptr = linphone_core_find_auth_info(nativePtr, realm, username, sipDomain);
			Linphone.AuthInfo returnVal = fromNativePtr<Linphone.AuthInfo>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_call_from_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Search from the list of current calls if a remote address match uri. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri">which should match call remote uri    </param>
		/// <returns><see cref="Linphone.Call">Linphone.Call</see> or null if no match is
		/// found.    </returns>
		/// deprecated : 27/10/2020. Use <see cref="Linphone.Core.CallByRemoteAddress2">
		/// Linphone.Core.CallByRemoteAddress2</see> instead. 
		public Linphone.Call FindCallFromUri(string uri)
		{
			IntPtr ptr = linphone_core_find_call_from_uri(nativePtr, uri);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_call_log(IntPtr thiz, string callId, int limit);

		/// <summary>
		/// Get the call log matching the call id, or null if can&apos;t be found. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="callId">Call id of the call log to find    </param>
		/// <param name="limit">Search limit of the most recent call logs to find   
		/// </param>
		/// <returns>A call log matching the call id if any.       </returns>
		public Linphone.CallLog FindCallLog(string callId, int limit)
		{
			IntPtr ptr = linphone_core_find_call_log(nativePtr, callId, limit);
			Linphone.CallLog returnVal = fromNativePtr<Linphone.CallLog>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_call_log_from_call_id(IntPtr thiz, string callId);

		/// <summary>
		/// Get the call log matching the call id, or null if can&apos;t be found. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="callId">Call id of the call log to find    </param>
		/// <returns>A call log matching the call id if any.       </returns>
		public Linphone.CallLog FindCallLogFromCallId(string callId)
		{
			IntPtr ptr = linphone_core_find_call_log_from_call_id(nativePtr, callId);
			Linphone.CallLog returnVal = fromNativePtr<Linphone.CallLog>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_chat_room(IntPtr thiz, IntPtr peerAddr, IntPtr localAddr);

		/// <summary>
		/// Find a chat room. 
		/// <para>
		/// No reference is transfered to the application. The <see cref="Linphone.Core">
		/// Linphone.Core</see> keeps a reference on the chat room. 
		/// </para>
		/// </summary>
		/// <param name="peerAddr">a linphone address.    </param>
		/// <param name="localAddr">a linphone address.    </param>
		/// <returns><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see> where messaging
		/// can take place.    </returns>
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.SearchChatRoom()">
		/// Linphone.Core.SearchChatRoom()</see> instead
		public Linphone.ChatRoom FindChatRoom(Linphone.Address peerAddr, Linphone.Address localAddr)
		{
			IntPtr ptr = linphone_core_find_chat_room(nativePtr, peerAddr != null ? peerAddr.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, true);
			
			GC.KeepAlive(peerAddr);
GC.KeepAlive(localAddr);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_conference_information_from_uri(IntPtr thiz, IntPtr uri);

		/// <summary>
		/// Retrieve the conference information linked to the provided URI if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri"><see cref="Linphone.Address">Linphone.Address</see> of the
		/// uri.    </param>
		/// <returns>The <see cref="Linphone.ConferenceInfo">Linphone.ConferenceInfo</see>
		/// found if any, null otherwise.       </returns>
		public Linphone.ConferenceInfo FindConferenceInformationFromUri(Linphone.Address uri)
		{
			IntPtr ptr = linphone_core_find_conference_information_from_uri(nativePtr, uri != null ? uri.nativePtr : IntPtr.Zero);
			Linphone.ConferenceInfo returnVal = fromNativePtr<Linphone.ConferenceInfo>(ptr, false);
			
			GC.KeepAlive(uri);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_contacts_by_char(IntPtr thiz, string filter, char sipOnly);

		/// <summary>
		/// Retrieves a list of <see cref="Linphone.Address">Linphone.Address</see> sort
		/// and filter. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filter">Chars used for the filter*    </param>
		/// <param name="sipOnly">Only sip address or not </param>
		/// <returns>A list of filtered <see cref="Linphone.Address">Linphone.Address</see>
		/// + the <see cref="Linphone.Address">Linphone.Address</see> created with the
		/// filter.      </returns>
		public IEnumerable<Linphone.Address> FindContactsByChar(string filter, bool sipOnly)
		{
			IEnumerable<Linphone.Address> returnVal = MarshalBctbxList<Linphone.Address>(linphone_core_find_contacts_by_char(nativePtr, filter, sipOnly ? (char)1 : (char)0), true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_friend(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Search a <see cref="Linphone.Friend">Linphone.Friend</see> by its address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address">The <see cref="Linphone.Address">Linphone.Address</see>
		/// to use to search the friend.    </param>
		/// <returns>The <see cref="Linphone.Friend">Linphone.Friend</see> object
		/// corresponding to the given address or null if not found.    </returns>
		public Linphone.Friend FindFriend(Linphone.Address address)
		{
			IntPtr ptr = linphone_core_find_friend(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
			GC.KeepAlive(address);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_friend_by_phone_number(IntPtr thiz, string phoneNumber);

		/// <summary>
		/// Search a <see cref="Linphone.Friend">Linphone.Friend</see> by its phone number. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">The phone number to use to search the friend.   
		/// </param>
		/// <returns>The <see cref="Linphone.Friend">Linphone.Friend</see> object
		/// corresponding to the given phone number or null if not found.    </returns>
		public Linphone.Friend FindFriendByPhoneNumber(string phoneNumber)
		{
			IntPtr ptr = linphone_core_find_friend_by_phone_number(nativePtr, phoneNumber);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_friends(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Search all <see cref="Linphone.Friend">Linphone.Friend</see> matching an
		/// address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address">The address to use to search the friends.    </param>
		/// <returns>A list of <see cref="Linphone.Friend">Linphone.Friend</see>
		/// corresponding to the given address.         </returns>
		public IEnumerable<Linphone.Friend> FindFriends(Linphone.Address address)
		{
			IEnumerable<Linphone.Friend> returnVal = MarshalBctbxList<Linphone.Friend>(linphone_core_find_friends(nativePtr, address != null ? address.nativePtr : IntPtr.Zero), false);
			
			GC.KeepAlive(address);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_find_one_to_one_chat_room_2(IntPtr thiz, IntPtr localAddr, IntPtr participantAddr, char encrypted);

		/// <summary>
		/// Find a one to one chat room. 
		/// <para>
		/// No reference is transfered to the application. The <see cref="Linphone.Core">
		/// Linphone.Core</see> keeps a reference on the chat room. 
		/// </para>
		/// </summary>
		/// <param name="localAddr">a linphone address.    </param>
		/// <param name="participantAddr">a linphone address.    </param>
		/// <param name="encrypted">whether to look for an encrypted chat room or not
		/// </param>
		/// <returns><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see> where messaging
		/// can take place.    </returns>
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.SearchChatRoom()">
		/// Linphone.Core.SearchChatRoom()</see> instead
		public Linphone.ChatRoom FindOneToOneChatRoom(Linphone.Address localAddr, Linphone.Address participantAddr, bool encrypted)
		{
			IntPtr ptr = linphone_core_find_one_to_one_chat_room_2(nativePtr, localAddr != null ? localAddr.nativePtr : IntPtr.Zero, participantAddr != null ? participantAddr.nativePtr : IntPtr.Zero, encrypted ? (char)1 : (char)0);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, true);
			
			GC.KeepAlive(localAddr);
GC.KeepAlive(participantAddr);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_account_by_idkey(IntPtr thiz, string idkey);

		/// <summary>
		/// Search for a <see cref="Linphone.Account">Linphone.Account</see> by it&apos;s
		/// idkey. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="idkey">An arbitrary idkey string associated to an account.   
		/// </param>
		/// <returns>the <see cref="Linphone.Account">Linphone.Account</see> object for the
		/// given idkey value, or null if none found    </returns>
		public Linphone.Account GetAccountByIdkey(string idkey)
		{
			IntPtr ptr = linphone_core_get_account_by_idkey(nativePtr, idkey);
			Linphone.Account returnVal = fromNativePtr<Linphone.Account>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_call_by_callid(IntPtr thiz, string callId);

		/// <summary>
		/// Get the call by callid. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="callId">of call    </param>
		/// <returns>call <see cref="Linphone.Call">Linphone.Call</see>, return null if
		/// there is no call find.    </returns>
		public Linphone.Call GetCallByCallid(string callId)
		{
			IntPtr ptr = linphone_core_get_call_by_callid(nativePtr, callId);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_call_by_remote_address(IntPtr thiz, string remoteAddress);

		/// <summary>
		/// Get the call with the remote_address specified. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="remoteAddress">The remote address of the call that we want to get 
		///   </param>
		/// <returns>The call if it has been found, null otherwise.   </returns>
		/// deprecated : 08/07/2020 use <see cref="Linphone.Core.CallByRemoteAddress2">
		/// Linphone.Core.CallByRemoteAddress2</see> instead 
		public Linphone.Call GetCallByRemoteAddress(string remoteAddress)
		{
			IntPtr ptr = linphone_core_get_call_by_remote_address(nativePtr, remoteAddress);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_call_by_remote_address2(IntPtr thiz, IntPtr remoteAddress);

		/// <summary>
		/// Get the call with the specified <see cref="Linphone.Address">
		/// Linphone.Address</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="remoteAddress">the <see cref="Linphone.Address">
		/// Linphone.Address</see> for which the call remote address must match    </param>
		/// <returns>the <see cref="Linphone.Call">Linphone.Call</see> of the call if
		/// found.    </returns>
		public Linphone.Call GetCallByRemoteAddress2(Linphone.Address remoteAddress)
		{
			IntPtr ptr = linphone_core_get_call_by_remote_address2(nativePtr, remoteAddress != null ? remoteAddress.nativePtr : IntPtr.Zero);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
			GC.KeepAlive(remoteAddress);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_call_history_2(IntPtr thiz, IntPtr peerAddress, IntPtr localAddress);

		/// <summary>
		/// Get the list of call logs (past calls). 
		/// <para>
		/// At the contrary of linphone_core_get_call_logs, it is your responsibility to
		/// unref the logs and free this list once you are done using it. Requires
		/// ENABLE_DB_STORAGE to work. 
		/// </para>
		/// </summary>
		/// <param name="peerAddress">The remote <see cref="Linphone.Address">
		/// Linphone.Address</see> object.    </param>
		/// <param name="localAddress">The local <see cref="Linphone.Address">
		/// Linphone.Address</see> object    </param>
		/// <returns>A list of <see cref="Linphone.CallLog">Linphone.CallLog</see>.        
		/// </returns>
		public IEnumerable<Linphone.CallLog> GetCallHistory(Linphone.Address peerAddress, Linphone.Address localAddress)
		{
			IEnumerable<Linphone.CallLog> returnVal = MarshalBctbxList<Linphone.CallLog>(linphone_core_get_call_history_2(nativePtr, peerAddress != null ? peerAddress.nativePtr : IntPtr.Zero, localAddress != null ? localAddress.nativePtr : IntPtr.Zero), false);
			
			GC.KeepAlive(peerAddress);
GC.KeepAlive(localAddress);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_chat_room(IntPtr thiz, IntPtr addr);

		/// <summary>
		/// Get a chat room whose peer is the supplied address. 
		/// <para>
		/// If it does not exist yet, it will be created as a basic chat room. No reference
		/// is transfered to the application. The <see cref="Linphone.Core">
		/// Linphone.Core</see> keeps a reference on the chat room. </para>
		/// </summary>
		/// <remarks>Warning : This method is prone to errors, use <see cref="Linphone.Core.SearchChatRoom()">
		/// Linphone.Core.SearchChatRoom()</see> instead </remarks> 
		/// <param name="addr">a linphone address.    </param>
		/// <returns><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see> where messaging
		/// can take place.    </returns>
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.SearchChatRoom()">
		/// Linphone.Core.SearchChatRoom()</see> instead
		public Linphone.ChatRoom GetChatRoom(Linphone.Address addr)
		{
			IntPtr ptr = linphone_core_get_chat_room(nativePtr, addr != null ? addr.nativePtr : IntPtr.Zero);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, true);
			
			GC.KeepAlive(addr);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_chat_room_2(IntPtr thiz, IntPtr peerAddr, IntPtr localAddr);

		/// <summary>
		/// Get a chat room. 
		/// <para>
		/// If it does not exist yet, it will be created as a basic chat room. No reference
		/// is transfered to the application. The <see cref="Linphone.Core">
		/// Linphone.Core</see> keeps a reference on the chat room. </para>
		/// </summary>
		/// <remarks>Warning : This method is prone to errors, use <see cref="Linphone.Core.SearchChatRoom()">
		/// Linphone.Core.SearchChatRoom()</see> instead </remarks> 
		/// <param name="peerAddr">a linphone address.    </param>
		/// <param name="localAddr">a linphone address.    </param>
		/// <returns><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see> where messaging
		/// can take place.    </returns>
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.SearchChatRoom()">
		/// Linphone.Core.SearchChatRoom()</see> instead
		public Linphone.ChatRoom GetChatRoom(Linphone.Address peerAddr, Linphone.Address localAddr)
		{
			IntPtr ptr = linphone_core_get_chat_room_2(nativePtr, peerAddr != null ? peerAddr.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, true);
			
			GC.KeepAlive(peerAddr);
GC.KeepAlive(localAddr);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_chat_room_from_uri(IntPtr thiz, string to);

		/// <summary>
		/// Get a chat room for messaging from a sip uri like sip:joe@sip.linphone.org. 
		/// <para>
		/// If it does not exist yet, it will be created as a basic chat room. No reference
		/// is transfered to the application. The <see cref="Linphone.Core">
		/// Linphone.Core</see> keeps a reference on the chat room. </para>
		/// </summary>
		/// <remarks>Warning : This method is prone to errors, use <see cref="Linphone.Core.SearchChatRoom()">
		/// Linphone.Core.SearchChatRoom()</see> instead </remarks> 
		/// <param name="to">The destination address for messages.    </param>
		/// <returns><see cref="Linphone.ChatRoom">Linphone.ChatRoom</see> where messaging
		/// can take place.    </returns>
		/// deprecated : 02/07/2020, use <see cref="Linphone.Core.SearchChatRoom()">
		/// Linphone.Core.SearchChatRoom()</see> instead
		public Linphone.ChatRoom GetChatRoomFromUri(string to)
		{
			IntPtr ptr = linphone_core_get_chat_room_from_uri(nativePtr, to);
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_conference_information_list_after_time(IntPtr thiz, long time);

		/// <summary>
		/// Retrieve the list of conference information on DB after a certain time. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="time">Time to retrieve conference info. </param>
		/// <returns>The list of conference infos  .       </returns>
		public IEnumerable<Linphone.ConferenceInfo> GetConferenceInformationListAfterTime(long time)
		{
			IEnumerable<Linphone.ConferenceInfo> returnVal = MarshalBctbxList<Linphone.ConferenceInfo>(linphone_core_get_conference_information_list_after_time(nativePtr, time), false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_friend_by_ref_key(IntPtr thiz, string key);

		/// <summary>
		/// Search a <see cref="Linphone.Friend">Linphone.Friend</see> by its reference
		/// key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The reference key to use to search the friend.    </param>
		/// <returns>The <see cref="Linphone.Friend">Linphone.Friend</see> object
		/// corresponding to the given reference key.    </returns>
		public Linphone.Friend GetFriendByRefKey(string key)
		{
			IntPtr ptr = linphone_core_get_friend_by_ref_key(nativePtr, key);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_friend_list_by_name(IntPtr thiz, string name);

		/// <summary>
		/// Retrieves the list of <see cref="Linphone.Friend">Linphone.Friend</see> from
		/// the core that has the given display name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the name of the list    </param>
		/// <returns>the first <see cref="Linphone.FriendList">Linphone.FriendList</see>
		/// object or null.    </returns>
		public Linphone.FriendList GetFriendListByName(string name)
		{
			IntPtr ptr = linphone_core_get_friend_list_by_name(nativePtr, name);
			Linphone.FriendList returnVal = fromNativePtr<Linphone.FriendList>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_payload_type(IntPtr thiz, string type, int rate, int channels);

		/// <summary>
		/// Get payload type from mime type and clock rate. 
		/// <para>
		/// This function searches in audio and video codecs for the given payload type
		/// name and clockrate. 
		/// </para>
		/// </summary>
		/// <param name="type">payload mime type (I.E SPEEX, PCMU, VP8)    </param>
		/// <param name="rate">can be LINPHONE_FIND_PAYLOAD_IGNORE_RATE </param>
		/// <param name="channels">number of channels, can be
		/// LINPHONE_FIND_PAYLOAD_IGNORE_CHANNELS </param>
		/// <returns>Returns null if not found. If a <see cref="Linphone.PayloadType">
		/// Linphone.PayloadType</see> is returned, it must be released with
		/// linphone_payload_type_unref after using it.       </returns>
		public Linphone.PayloadType GetPayloadType(string type, int rate, int channels)
		{
			IntPtr ptr = linphone_core_get_payload_type(nativePtr, type, rate, channels);
			Linphone.PayloadType returnVal = fromNativePtr<Linphone.PayloadType>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_get_proxy_config_by_idkey(IntPtr thiz, string idkey);

		/// <summary>
		/// Search for a <see cref="Linphone.ProxyConfig">Linphone.ProxyConfig</see> by
		/// it&apos;s idkey. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="idkey">An arbitrary idkey string associated to a proxy
		/// configuration </param>
		/// <returns>the <see cref="Linphone.ProxyConfig">Linphone.ProxyConfig</see> object
		/// for the given idkey value, or null if none found    </returns>
		public Linphone.ProxyConfig GetProxyConfigByIdkey(string idkey)
		{
			IntPtr ptr = linphone_core_get_proxy_config_by_idkey(nativePtr, idkey);
			Linphone.ProxyConfig returnVal = fromNativePtr<Linphone.ProxyConfig>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_get_unread_chat_message_count_from_local(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Return the unread chat message count for a given local address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address"><see cref="Linphone.Address">Linphone.Address</see>
		/// object.    </param>
		/// <returns>The unread chat message count. </returns>
		public int GetUnreadChatMessageCountFromLocal(Linphone.Address address)
		{
			int returnVal = linphone_core_get_unread_chat_message_count_from_local(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(address);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ZrtpPeerStatus linphone_core_get_zrtp_status(IntPtr thiz, string addr);

		/// <summary>
		/// Get the zrtp sas validation status for a peer uri. 
		/// <para>
		/// Once the SAS has been validated or rejected, the status will never return to
		/// Unknown (unless you delete your cache) 
		/// </para>
		/// </summary>
		/// <param name="addr">the peer uri   </param>
		/// <returns>- LinphoneZrtpPeerStatusUnknown: this uri is not present in cache OR
		/// during calls with the active device, SAS never was validated or rejected
		/// </returns>
		public Linphone.ZrtpPeerStatus GetZrtpStatus(string addr)
		{
			Linphone.ZrtpPeerStatus returnVal = linphone_core_get_zrtp_status(nativePtr, addr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_has_builtin_echo_canceller(IntPtr thiz);

		/// <summary>
		/// Check whether the device has a hardware echo canceller. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if it does, false otherwise </returns>
		public bool HasBuiltinEchoCanceller()
		{
			bool returnVal = linphone_core_has_builtin_echo_canceller(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_has_crappy_opengl(IntPtr thiz);

		/// <summary>
		/// Check whether the device is flagged has crappy opengl. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if crappy opengl flag is set, false otherwise </returns>
		public bool HasCrappyOpengl()
		{
			bool returnVal = linphone_core_has_crappy_opengl(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_in_call(IntPtr thiz);

		/// <summary>
		/// Tells whether there is a call running. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether a call is currently running or not
		/// </returns>
		public bool InCall()
		{
			bool returnVal = linphone_core_in_call(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_interpret_url(IntPtr thiz, string url);

		/// <summary>
		/// Constructs a <see cref="Linphone.Address">Linphone.Address</see> from the given
		/// string if possible. 
		/// <para>
		/// In case of just a username, characters will be unescaped. If a phone number is
		/// detected, it will be flattened. sip: or sips: prefix will be added if not
		/// present. Finally, @domain will be added if not present using default proxy
		/// config. </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.ProxyConfig.NormalizeSipUri()">
		/// Linphone.ProxyConfig.NormalizeSipUri()</see> for documentation. </remarks>
		/// <param name="url">the url to parse    </param>
		/// <returns>the <see cref="Linphone.Address">Linphone.Address</see> matching the
		/// url or null in case of failure.      </returns>
		/// deprecated : on 18/07/2022, use <see cref="Linphone.Core.InterpretUrl()">
		/// Linphone.Core.InterpretUrl()</see> instead. 
		public Linphone.Address InterpretUrl(string url)
		{
			IntPtr ptr = linphone_core_interpret_url(nativePtr, url);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_interpret_url_2(IntPtr thiz, string url, char applyInternationalPrefix);

		/// <summary>
		/// Constructs a <see cref="Linphone.Address">Linphone.Address</see> from the given
		/// string if possible. 
		/// <para>
		/// In case of just a username, characters will be unescaped. If a phone number is
		/// detected, it will be flattened. sip: or sips: prefix will be added if not
		/// present. Finally, @domain will be added if not present using default proxy
		/// config. </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.ProxyConfig.NormalizeSipUri()">
		/// Linphone.ProxyConfig.NormalizeSipUri()</see> for documentation. </remarks>
		/// <param name="url">the url to parse    </param>
		/// <param name="applyInternationalPrefix">whether or not to try to format url as
		/// phone number using default account prefix if it set (and if url is a number).
		/// </param>
		/// <returns>the <see cref="Linphone.Address">Linphone.Address</see> matching the
		/// url or null in case of failure.       </returns>
		public Linphone.Address InterpretUrl(string url, bool applyInternationalPrefix)
		{
			IntPtr ptr = linphone_core_interpret_url_2(nativePtr, url, applyInternationalPrefix ? (char)1 : (char)0);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_invite(IntPtr thiz, string url);

		/// <summary>
		/// Initiates an outgoing call. 
		/// <para>
		/// The application doesn&apos;t own a reference to the returned LinphoneCall
		/// object. Use linphone_call_ref to safely keep the LinphoneCall pointer valid
		/// within your application.
		/// </para>
		/// </summary>
		/// <param name="url">The destination of the call (sip address, or phone number).  
		///  </param>
		/// <returns>A <see cref="Linphone.Call">Linphone.Call</see> object or null in case
		/// of failure.    </returns>
		public Linphone.Call Invite(string url)
		{
			IntPtr ptr = linphone_core_invite(nativePtr, url);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_invite_address(IntPtr thiz, IntPtr addr);

		/// <summary>
		/// Initiates an outgoing call given a destination <see cref="Linphone.Address">
		/// Linphone.Address</see> The <see cref="Linphone.Address">Linphone.Address</see>
		/// can be constructed directly using <see cref="Linphone.Factory.CreateAddress()">
		/// Linphone.Factory.CreateAddress()</see>, or created by <see cref="Linphone.Core.InterpretUrl()">
		/// Linphone.Core.InterpretUrl()</see>. 
		/// <para>
		/// The application doesn&apos;t own a reference to the returned <see cref="Linphone.Call">
		/// Linphone.Call</see> object. Use linphone_call_ref to safely keep the <see cref="Linphone.Call">
		/// Linphone.Call</see> pointer valid within your application. 
		/// </para>
		/// </summary>
		/// <param name="addr">The destination of the call (sip address).    </param>
		/// <returns>A <see cref="Linphone.Call">Linphone.Call</see> object or null in case
		/// of failure.    </returns>
		public Linphone.Call InviteAddress(Linphone.Address addr)
		{
			IntPtr ptr = linphone_core_invite_address(nativePtr, addr != null ? addr.nativePtr : IntPtr.Zero);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
			GC.KeepAlive(addr);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_invite_address_with_params(IntPtr thiz, IntPtr addr, IntPtr parameters);

		/// <summary>
		/// Initiates an outgoing call given a destination <see cref="Linphone.Address">
		/// Linphone.Address</see> The <see cref="Linphone.Address">Linphone.Address</see>
		/// can be constructed directly using <see cref="Linphone.Factory.CreateAddress()">
		/// Linphone.Factory.CreateAddress()</see>, or created by <see cref="Linphone.Core.InterpretUrl()">
		/// Linphone.Core.InterpretUrl()</see>. 
		/// <para>
		/// The application doesn&apos;t own a reference to the returned <see cref="Linphone.Call">
		/// Linphone.Call</see> object. Use linphone_call_ref to safely keep the <see cref="Linphone.Call">
		/// Linphone.Call</see> pointer valid within your application. If the proxy is not
		/// specified in parameters, the caller proxy will be automatically selected by
		/// finding what is the best to reach the destination of the call. 
		/// </para>
		/// </summary>
		/// <param name="addr">The destination of the call (sip address).    </param>
		/// <param name="parameters">Call parameters    </param>
		/// <returns>A <see cref="Linphone.Call">Linphone.Call</see> object or null in case
		/// of failure.    </returns>
		public Linphone.Call InviteAddressWithParams(Linphone.Address addr, Linphone.CallParams parameters)
		{
			IntPtr ptr = linphone_core_invite_address_with_params(nativePtr, addr != null ? addr.nativePtr : IntPtr.Zero, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
			GC.KeepAlive(addr);
GC.KeepAlive(parameters);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_invite_address_with_params_2(IntPtr thiz, IntPtr addr, IntPtr parameters, string subject, IntPtr content);

		/// <summary>
		/// Initiates an outgoing call given a destination <see cref="Linphone.Address">
		/// Linphone.Address</see> The <see cref="Linphone.Address">Linphone.Address</see>
		/// can be constructed directly using <see cref="Linphone.Factory.CreateAddress()">
		/// Linphone.Factory.CreateAddress()</see>, or created by <see cref="Linphone.Core.InterpretUrl()">
		/// Linphone.Core.InterpretUrl()</see>. 
		/// <para>
		/// The application doesn&apos;t own a reference to the returned <see cref="Linphone.Call">
		/// Linphone.Call</see> object. Use linphone_call_ref to safely keep the <see cref="Linphone.Call">
		/// Linphone.Call</see> pointer valid within your application. If the proxy is not
		/// specified in parameters, the caller proxy will be automatically selected by
		/// finding what is the best to reach the destination of the call. 
		/// </para>
		/// </summary>
		/// <param name="addr">The destination of the call (sip address).    </param>
		/// <param name="parameters">Call parameters    </param>
		/// <param name="subject">Subject of the call    </param>
		/// <param name="content">Body of the SIP INVITE    </param>
		/// <returns>A <see cref="Linphone.Call">Linphone.Call</see> object or null in case
		/// of failure.    </returns>
		public Linphone.Call InviteAddressWithParams(Linphone.Address addr, Linphone.CallParams parameters, string subject, Linphone.Content content)
		{
			IntPtr ptr = linphone_core_invite_address_with_params_2(nativePtr, addr != null ? addr.nativePtr : IntPtr.Zero, parameters != null ? parameters.nativePtr : IntPtr.Zero, subject, content != null ? content.nativePtr : IntPtr.Zero);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
			GC.KeepAlive(addr);
GC.KeepAlive(parameters);
GC.KeepAlive(content);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_invite_with_params(IntPtr thiz, string url, IntPtr parameters);

		/// <summary>
		/// Initiates an outgoing call according to supplied call parameters The
		/// application doesn&apos;t own a reference to the returned <see cref="Linphone.Call">
		/// Linphone.Call</see> object. 
		/// <para>
		/// Use linphone_call_ref to safely keep the <see cref="Linphone.Call">
		/// Linphone.Call</see> pointer valid within your application. 
		/// </para>
		/// </summary>
		/// <param name="url">The destination of the call (sip address, or phone number).  
		///  </param>
		/// <param name="parameters">the <see cref="Linphone.CallParams">
		/// Linphone.CallParams</see> call parameters    </param>
		/// <returns>A <see cref="Linphone.Call">Linphone.Call</see> object or null in case
		/// of failure.    </returns>
		public Linphone.Call InviteWithParams(string url, Linphone.CallParams parameters)
		{
			IntPtr ptr = linphone_core_invite_with_params(nativePtr, url, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			Linphone.Call returnVal = fromNativePtr<Linphone.Call>(ptr, true);
			
			GC.KeepAlive(parameters);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_content_type_supported(IntPtr thiz, string contentType);

		/// <summary>
		/// Tells whether a content type is supported. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="contentType">The content type to check    </param>
		/// <returns>A boolean value telling whether the specified content type is
		/// supported or not. </returns>
		public bool IsContentTypeSupported(string contentType)
		{
			bool returnVal = linphone_core_is_content_type_supported(nativePtr, contentType) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_media_encryption_supported(IntPtr thiz, int menc);

		/// <summary>
		/// Check if media encryption is supported. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="menc">The media encryption policy to be used. </param>
		/// <returns>true if the media encryption is supported, false otherwise </returns>
		public bool IsMediaEncryptionSupported(Linphone.MediaEncryption menc)
		{
			bool returnVal = linphone_core_is_media_encryption_supported(nativePtr, (int)menc) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_media_filter_supported(IntPtr thiz, string filtername);

		/// <summary>
		/// Checks if the given media filter is loaded and usable. 
		/// <para>
		/// This is for advanced users of the library, mainly to expose mediastreamer video
		/// filter status. 
		/// </para>
		/// </summary>
		/// <param name="filtername">the filter name    </param>
		/// <returns>true if the filter is loaded and usable, false otherwise </returns>
		public bool IsMediaFilterSupported(string filtername)
		{
			bool returnVal = linphone_core_is_media_filter_supported(nativePtr, filtername) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_is_plugin_loaded(IntPtr thiz, string name);

		/// <summary>
		/// Tells whether a plugin is loaded or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">name of the plugin    </param>
		/// <returns>A boolean value telling whether the plugin has been loaded </returns>
		public bool IsPluginLoaded(string name)
		{
			bool returnVal = linphone_core_is_plugin_loaded(nativePtr, name) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_iterate(IntPtr thiz);

		/// <summary>
		/// Main loop function. 
		/// <para>
		/// It is crucial that your application call it periodically.
		/// <see cref="Linphone.Core.Iterate()">Linphone.Core.Iterate()</see> performs
		/// various backgrounds tasks:
		/// </para>
		/// </summary>
		public void Iterate()
		{
			linphone_core_iterate(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_ldap_available(IntPtr thiz);

		/// <summary>
		/// Tells if LDAP is available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if LDAP is available, false otherwise </returns>
		public bool LdapAvailable()
		{
			bool returnVal = linphone_core_ldap_available(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_leave_conference(IntPtr thiz);

		/// <summary>
		/// Make the local participant leave the running conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if succeeded. Negative number if failed </returns>
		/// deprecated : 09/03/2021 Use <see cref="Linphone.Conference.Leave()">
		/// Linphone.Conference.Leave()</see> instead. 
		public void LeaveConference()
		{
			int exception_result = linphone_core_leave_conference(nativePtr);
			if (exception_result != 0) throw new LinphoneException("LeaveConference returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_lime_x3dh_available(IntPtr thiz);

		/// <summary>
		/// Tells if LIME X3DH is available. 
		/// <para>
		/// </para>
		/// </summary>
		public bool LimeX3DhAvailable()
		{
			bool returnVal = linphone_core_lime_x3dh_available(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_load_config_from_xml(IntPtr thiz, string xmlUri);

		/// <summary>
		/// Update current config with the content of a xml config file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="xmlUri">the path to the xml file    </param>
		public void LoadConfigFromXml(string xmlUri)
		{
			linphone_core_load_config_from_xml(nativePtr, xmlUri);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_media_encryption_supported(IntPtr thiz, int menc);

		/// <summary>
		/// Check if a media encryption type is supported. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="menc"><see cref="Linphone.MediaEncryption">
		/// Linphone.MediaEncryption</see> </param>
		/// <returns>whether a media encryption scheme is supported by the <see cref="Linphone.Core">
		/// Linphone.Core</see> engine </returns>
		public bool MediaEncryptionSupported(Linphone.MediaEncryption menc)
		{
			bool returnVal = linphone_core_media_encryption_supported(nativePtr, (int)menc) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_migrate_logs_from_rc_to_db(IntPtr thiz);

		/// <summary>
		/// Migrates the call logs from the linphonerc to the database if not done yet. 
		/// <para>
		/// </para>
		/// </summary>
		public void MigrateLogsFromRcToDb()
		{
			linphone_core_migrate_logs_from_rc_to_db(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_migrate_to_multi_transport(IntPtr thiz);

		/// <summary>
		/// Migrate configuration so that all SIP transports are enabled. 
		/// <para>
		/// Versions of linphone &lt; 3.7 did not support using multiple SIP transport
		/// simultaneously. This function helps application to migrate the configuration so
		/// that all transports are enabled. Existing proxy configuration are added a
		/// transport parameter so that they continue using the unique transport that was
		/// set previously. This function must be used just after creating the core, before
		/// any call to <see cref="Linphone.Core.Iterate()">Linphone.Core.Iterate()</see> 
		/// </para>
		/// </summary>
		/// <returns>1 if migration was done, 0 if not done because unnecessary or already
		/// done, -1 in case of error. </returns>
		public void MigrateToMultiTransport()
		{
			int exception_result = linphone_core_migrate_to_multi_transport(nativePtr);
			if (exception_result != 0) throw new LinphoneException("MigrateToMultiTransport returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_notify_all_friends(IntPtr thiz, IntPtr presence);

		/// <summary>
		/// Notify all friends that have subscribed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="presence"><see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> to notify    </param>
		public void NotifyAllFriends(Linphone.PresenceModel presence)
		{
			linphone_core_notify_all_friends(nativePtr, presence != null ? presence.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(presence);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_notify_notify_presence_received(IntPtr thiz, IntPtr linphoneFriend);

		/// <summary>
		/// Notifies the upper layer that a presence status has been received by calling
		/// the appropriate callback if one has been set. 
		/// <para>
		/// This method is for advanced usage, where customization of the
		/// liblinphone&apos;s internal behavior is required. 
		/// </para>
		/// </summary>
		/// <param name="linphoneFriend">the <see cref="Linphone.Friend">
		/// Linphone.Friend</see> whose presence information has been received.    </param>
		public void NotifyNotifyPresenceReceived(Linphone.Friend linphoneFriend)
		{
			linphone_core_notify_notify_presence_received(nativePtr, linphoneFriend != null ? linphoneFriend.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(linphoneFriend);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_notify_notify_presence_received_for_uri_or_tel(IntPtr thiz, IntPtr linphoneFriend, string uriOrTel, IntPtr presenceModel);

		/// <summary>
		/// Notifies the upper layer that a presence model change has been received for the
		/// uri or telephone number given as a parameter, by calling the appropriate
		/// callback if one has been set. 
		/// <para>
		/// This method is for advanced usage, where customization of the
		/// liblinphone&apos;s internal behavior is required. 
		/// </para>
		/// </summary>
		/// <param name="linphoneFriend">the <see cref="Linphone.Friend">
		/// Linphone.Friend</see> whose presence information has been received.    </param>
		/// <param name="uriOrTel">telephone number or sip uri    </param>
		/// <param name="presenceModel">the <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> that has been modified    </param>
		public void NotifyNotifyPresenceReceivedForUriOrTel(Linphone.Friend linphoneFriend, string uriOrTel, Linphone.PresenceModel presenceModel)
		{
			linphone_core_notify_notify_presence_received_for_uri_or_tel(nativePtr, linphoneFriend != null ? linphoneFriend.nativePtr : IntPtr.Zero, uriOrTel, presenceModel != null ? presenceModel.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(linphoneFriend);
GC.KeepAlive(presenceModel);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_pause_all_calls(IntPtr thiz);

		/// <summary>
		/// Pause all currently running calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 </returns>
		public void PauseAllCalls()
		{
			int exception_result = linphone_core_pause_all_calls(nativePtr);
			if (exception_result != 0) throw new LinphoneException("PauseAllCalls returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_play_dtmf(IntPtr thiz, sbyte dtmf, int durationMs);

		/// <summary>
		/// Plays a dtmf sound to the local user. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="dtmf">DTMF to play [&apos;0&apos;..&apos;16&apos;] | &apos;#&apos;
		/// | &apos;#&apos; </param>
		/// <param name="durationMs">Duration in ms, -1 means play until next further call
		/// to <see cref="Linphone.Core.StopDtmf()">Linphone.Core.StopDtmf()</see> </param>
		public void PlayDtmf(sbyte dtmf, int durationMs)
		{
			linphone_core_play_dtmf(nativePtr, dtmf, durationMs);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_play_local(IntPtr thiz, string audiofile);

		/// <summary>
		/// Plays an audio file to the local user. 
		/// <para>
		/// This function works at any time, during calls, or when no calls are running. It
		/// doesn&apos;t request the underlying audio system to support multiple playback
		/// streams. 
		/// </para>
		/// </summary>
		/// <param name="audiofile">The path to an audio file in wav PCM 16 bit format   
		/// </param>
		/// <returns>0 on success, -1 on error </returns>
		public void PlayLocal(string audiofile)
		{
			int exception_result = linphone_core_play_local(nativePtr, audiofile);
			if (exception_result != 0) throw new LinphoneException("PlayLocal returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_preempt_sound_resources(IntPtr thiz);

		/// <summary>
		/// Empties sound resources to allow a new call to be accepted. 
		/// <para>
		/// This function is autyomatically called by the core if the media resource mode
		/// is set to unique. 
		/// </para>
		/// </summary>
		/// <returns>An integer returning the exit value. If it is 0, sound resources have
		/// been emptied. Otherwise, sound resources are busy and cannot be freed
		/// immediately. </returns>
		public int PreemptSoundResources()
		{
			int returnVal = linphone_core_preempt_sound_resources(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_preview_ogl_render(IntPtr thiz);

		/// <summary>
		/// Call generic OpenGL render for a given core. 
		/// <para>
		/// </para>
		/// </summary>
		public void PreviewOglRender()
		{
			linphone_core_preview_ogl_render(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_process_push_notification(IntPtr thiz, string callId);

		/// <summary>
		/// Call this method when you receive a push notification (if you handle push
		/// notifications manually). 
		/// <para>
		/// It will ensure the proxy configs are correctly registered to the proxy server,
		/// so the call or the message will be correctly delivered. 
		/// </para>
		/// </summary>
		/// <param name="callId">the Call-ID of the MESSAGE or INVITE for which the push
		/// was received and to wait for.    </param>
		public void ProcessPushNotification(string callId)
		{
			linphone_core_process_push_notification(nativePtr, callId);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_publish(IntPtr thiz, IntPtr resource, string ev, int expires, IntPtr body);

		/// <summary>
		/// Publish an event state. 
		/// <para>
		/// This first create a <see cref="Linphone.Event">Linphone.Event</see> with <see cref="Linphone.Core.CreatePublish()">
		/// Linphone.Core.CreatePublish()</see> and calls <see cref="Linphone.Event.SendPublish()">
		/// Linphone.Event.SendPublish()</see> to actually send it. After expiry, the
		/// publication is refreshed unless it is terminated before. 
		/// </para>
		/// </summary>
		/// <param name="resource">the resource uri for the event    </param>
		/// <param name="ev">the event name    </param>
		/// <param name="expires">the lifetime of event being published, -1 if no
		/// associated duration, in which case it will not be refreshed. </param>
		/// <param name="body">the actual published data    </param>
		/// <returns>the <see cref="Linphone.Event">Linphone.Event</see> holding the
		/// context of the publish.    </returns>
		public Linphone.Event Publish(Linphone.Address resource, string ev, int expires, Linphone.Content body)
		{
			IntPtr ptr = linphone_core_publish(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, ev, expires, body != null ? body.nativePtr : IntPtr.Zero);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, true);
			
			GC.KeepAlive(resource);
GC.KeepAlive(body);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_core_realtime_text_get_keepalive_interval(IntPtr thiz);

		/// <summary>
		/// Gets keep alive interval of real time text. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>keep alive interval of real time text. </returns>
		public uint RealtimeTextGetKeepaliveInterval()
		{
			uint returnVal = linphone_core_realtime_text_get_keepalive_interval(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_realtime_text_set_keepalive_interval(IntPtr thiz, uint interval);

		/// <summary>
		/// Set keep alive interval for real time text. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="interval">The keep alive interval of real time text, 25000 by
		/// default. </param>
		public void RealtimeTextSetKeepaliveInterval(uint interval)
		{
			linphone_core_realtime_text_set_keepalive_interval(nativePtr, interval);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_refresh_registers(IntPtr thiz);

		/// <summary>
		/// force registration refresh to be initiated upon next iterate 
		/// <para>
		/// </para>
		/// </summary>
		public void RefreshRegisters()
		{
			linphone_core_refresh_registers(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_reject_subscriber(IntPtr thiz, IntPtr linphoneFriend);

		/// <summary>
		/// Black list a friend. 
		/// <para>
		/// same as <see cref="Linphone.Friend.IncSubscribePolicy">
		/// Linphone.Friend.IncSubscribePolicy</see> with <see cref="Linphone.SubscribePolicy.SPDeny">
		/// Linphone.SubscribePolicy.SPDeny</see> policy; 
		/// </para>
		/// </summary>
		/// <param name="linphoneFriend"><see cref="Linphone.Friend">Linphone.Friend</see>
		/// to reject    </param>
		public void RejectSubscriber(Linphone.Friend linphoneFriend)
		{
			linphone_core_reject_subscriber(nativePtr, linphoneFriend != null ? linphoneFriend.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(linphoneFriend);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_reload_ms_plugins(IntPtr thiz, string path);

		/// <summary>
		/// Reload mediastreamer2 plugins from specified directory. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="path">the path from where plugins are to be loaded, pass null to
		/// use default (compile-time determined) plugin directory.    </param>
		public void ReloadMsPlugins(string path)
		{
			linphone_core_reload_ms_plugins(nativePtr, path);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_reload_sound_devices(IntPtr thiz);

		/// <summary>
		/// Update detection of sound devices. 
		/// <para>
		/// Use this function when the application is notified of USB plug events, so that
		/// list of available hardwares for sound playback and capture is updated. 
		/// </para>
		/// </summary>
		public void ReloadSoundDevices()
		{
			linphone_core_reload_sound_devices(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_reload_video_devices(IntPtr thiz);

		/// <summary>
		/// Update detection of camera devices. 
		/// <para>
		/// Use this function when the application is notified of USB plug events, so that
		/// list of available hardwares for video capture is updated. 
		/// </para>
		/// </summary>
		public void ReloadVideoDevices()
		{
			linphone_core_reload_video_devices(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_account(IntPtr thiz, IntPtr account);

		/// <summary>
		/// Removes an account. 
		/// <para>
		/// <see cref="Linphone.Core">Linphone.Core</see> will then automatically
		/// unregister and place the account on a deleted list. For that reason, a removed
		/// account does NOT need to be freed. 
		/// </para>
		/// </summary>
		/// <param name="account">the <see cref="Linphone.Account">Linphone.Account</see>
		/// to remove    </param>
		public void RemoveAccount(Linphone.Account account)
		{
			linphone_core_remove_account(nativePtr, account != null ? account.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(account);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_auth_info(IntPtr thiz, IntPtr info);

		/// <summary>
		/// Removes an authentication information object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="info">The <see cref="Linphone.AuthInfo">Linphone.AuthInfo</see> to
		/// remove.    </param>
		public void RemoveAuthInfo(Linphone.AuthInfo info)
		{
			linphone_core_remove_auth_info(nativePtr, info != null ? info.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(info);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_call_log(IntPtr thiz, IntPtr callLog);

		/// <summary>
		/// Remove a specific call log from call history list. 
		/// <para>
		/// This function destroys the call log object. It must not be accessed anymore by
		/// the application after calling this function. 
		/// </para>
		/// </summary>
		/// <param name="callLog"><see cref="Linphone.CallLog">Linphone.CallLog</see>
		/// object to remove.    </param>
		public void RemoveCallLog(Linphone.CallLog callLog)
		{
			linphone_core_remove_call_log(nativePtr, callLog != null ? callLog.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(callLog);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_content_type_support(IntPtr thiz, string contentType);

		/// <summary>
		/// Remove support for the specified content type. 
		/// <para>
		/// It is the application responsibility to handle it correctly afterwards. 
		/// </para>
		/// </summary>
		/// <param name="contentType">The content type to remove support for    </param>
		public void RemoveContentTypeSupport(string contentType)
		{
			linphone_core_remove_content_type_support(nativePtr, contentType);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_friend_list(IntPtr thiz, IntPtr list);

		/// <summary>
		/// Removes a friend list. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="list"><see cref="Linphone.FriendList">Linphone.FriendList</see>
		/// object    </param>
		public void RemoveFriendList(Linphone.FriendList list)
		{
			linphone_core_remove_friend_list(nativePtr, list != null ? list.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(list);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_remove_from_conference(IntPtr thiz, IntPtr call);

		/// <summary>
		/// Remove a call from the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">a call that has been previously merged into the conference. 
		///  </param>
		/// After removing the remote participant belonging to the supplied call, the call
		/// becomes a normal call in paused state. If one single remote participant is left
		/// alone together with the local user in the conference after the removal, then
		/// the conference is automatically transformed into a simple call in
		/// StreamsRunning state. The conference&apos;s resources are then automatically
		/// destroyed.
		/// In other words, unless <see cref="Linphone.Core.LeaveConference()">
		/// Linphone.Core.LeaveConference()</see> is explicitly called, the last remote
		/// participant of a conference is automatically put in a simple call in running
		/// state.
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void RemoveFromConference(Linphone.Call call)
		{
			int exception_result = linphone_core_remove_from_conference(nativePtr, call != null ? call.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("RemoveFromConference returned value" + exception_result);
			
			GC.KeepAlive(call);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_ldap(IntPtr thiz, IntPtr ldap);

		/// <summary>
		/// Remove a LDAP from the configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="ldap">The LDAP to remove.    </param>
		public void RemoveLdap(Linphone.Ldap ldap)
		{
			linphone_core_remove_ldap(nativePtr, ldap != null ? ldap.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(ldap);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_linphone_spec(IntPtr thiz, string spec);

		/// <summary>
		/// Remove the given linphone specs from the list of functionalities the linphone
		/// client supports. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="spec">The spec to remove    </param>
		public void RemoveLinphoneSpec(string spec)
		{
			linphone_core_remove_linphone_spec(nativePtr, spec);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_proxy_config(IntPtr thiz, IntPtr config);

		/// <summary>
		/// Removes a proxy configuration. 
		/// <para>
		/// <see cref="Linphone.Core">Linphone.Core</see> will then automatically
		/// unregister and place the proxy configuration on a deleted list. For that
		/// reason, a removed proxy does NOT need to be freed. 
		/// </para>
		/// </summary>
		/// <param name="config">the <see cref="Linphone.ProxyConfig">
		/// Linphone.ProxyConfig</see> to remove    </param>
		public void RemoveProxyConfig(Linphone.ProxyConfig config)
		{
			linphone_core_remove_proxy_config(nativePtr, config != null ? config.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(config);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_remove_supported_tag(IntPtr thiz, string tag);

		/// <summary>
		/// Remove a supported tag. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="tag">The tag to remove   </param>
		/// <remarks>See : <see cref="Linphone.Core.AddSupportedTag()">
		/// Linphone.Core.AddSupportedTag()</see> </remarks>
		public void RemoveSupportedTag(string tag)
		{
			linphone_core_remove_supported_tag(nativePtr, tag);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_reset_echo_cancellation_calibration(IntPtr thiz);

		/// <summary>
		/// Clears all state resulting from a previous echo canceller calibration
		/// procedure, which restores default policy and settings for echo cancellation. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>See : <see cref="Linphone.Core.EnableEchoCancellation()">
		/// Linphone.Core.EnableEchoCancellation()</see> and <see cref="Linphone.Core.StartEchoCancellerCalibration()">
		/// Linphone.Core.StartEchoCancellerCalibration()</see> </remarks>
		public void ResetEchoCancellationCalibration()
		{
			linphone_core_reset_echo_cancellation_calibration(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_reset_missed_calls_count(IntPtr thiz);

		/// <summary>
		/// Reset the counter of missed calls. 
		/// <para>
		/// </para>
		/// </summary>
		public void ResetMissedCallsCount()
		{
			linphone_core_reset_missed_calls_count(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_search_chat_room(IntPtr thiz, IntPtr parameters, IntPtr localAddr, IntPtr remoteAddr, IntPtr participants);

		/// <summary>
		/// Find a chat room. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The chat room parameters to match <see cref="Linphone.ChatRoomParams">
		/// Linphone.ChatRoomParams</see> or null    </param>
		/// <param name="localAddr"><see cref="Linphone.Address">Linphone.Address</see>
		/// representing the local proxy configuration or null    </param>
		/// <param name="remoteAddr"><see cref="Linphone.Address">Linphone.Address</see> to
		/// search for or null    </param>
		/// <param name="participants">The participants that must be present in the chat
		/// room to find.      </param>
		/// <returns>A matching chat room or null if none matches.    </returns>
		public Linphone.ChatRoom SearchChatRoom(Linphone.ChatRoomParams parameters, Linphone.Address localAddr, Linphone.Address remoteAddr, IEnumerable<Linphone.Address> participants)
		{
			IntPtr ptr = linphone_core_search_chat_room(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero, remoteAddr != null ? remoteAddr.nativePtr : IntPtr.Zero, ObjectArrayToBctbxList<Linphone.Address>(participants));
			Linphone.ChatRoom returnVal = fromNativePtr<Linphone.ChatRoom>(ptr, true);
			
			GC.KeepAlive(parameters);
GC.KeepAlive(localAddr);
GC.KeepAlive(remoteAddr);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_search_conference(IntPtr thiz, IntPtr parameters, IntPtr localAddr, IntPtr remoteAddr, IntPtr participants);

		/// <summary>
		/// Find a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="parameters">The conference parameters to match <see cref="Linphone.ConferenceParams">
		/// Linphone.ConferenceParams</see> or null    </param>
		/// <param name="localAddr"><see cref="Linphone.Address">Linphone.Address</see>
		/// representing the local proxy configuration or null    </param>
		/// <param name="remoteAddr"><see cref="Linphone.Address">Linphone.Address</see> to
		/// search for or null    </param>
		/// <param name="participants">The participants that must be present in the chat
		/// room to find      </param>
		/// <returns>A pointer on <see cref="Linphone.Conference">Linphone.Conference</see>
		/// satisfying the non-null function arguments or null if none matches    </returns>
		public Linphone.Conference SearchConference(Linphone.ConferenceParams parameters, Linphone.Address localAddr, Linphone.Address remoteAddr, IEnumerable<Linphone.Address> participants)
		{
			IntPtr ptr = linphone_core_search_conference(nativePtr, parameters != null ? parameters.nativePtr : IntPtr.Zero, localAddr != null ? localAddr.nativePtr : IntPtr.Zero, remoteAddr != null ? remoteAddr.nativePtr : IntPtr.Zero, ObjectArrayToBctbxList<Linphone.Address>(participants));
			Linphone.Conference returnVal = fromNativePtr<Linphone.Conference>(ptr, true);
			
			GC.KeepAlive(parameters);
GC.KeepAlive(localAddr);
GC.KeepAlive(remoteAddr);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_search_conference_2(IntPtr thiz, IntPtr conferenceAddr);

		/// <summary>
		/// Find a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="conferenceAddr"><see cref="Linphone.Address">
		/// Linphone.Address</see> representing the conference address    </param>
		/// <returns>A pointer on <see cref="Linphone.Conference">Linphone.Conference</see>
		/// whose conference address is the one provided as argument or null if none
		/// matches    </returns>
		public Linphone.Conference SearchConference(Linphone.Address conferenceAddr)
		{
			IntPtr ptr = linphone_core_search_conference_2(nativePtr, conferenceAddr != null ? conferenceAddr.nativePtr : IntPtr.Zero);
			Linphone.Conference returnVal = fromNativePtr<Linphone.Conference>(ptr, true);
			
			GC.KeepAlive(conferenceAddr);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_audio_port_range(IntPtr thiz, int minPort, int maxPort);

		/// <summary>
		/// Sets the UDP port range from which to randomly select the port used for audio
		/// streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="minPort">The lower bound of the audio port range to use </param>
		/// <param name="maxPort">The upper bound of the audio port range to use </param>
		public void SetAudioPortRange(int minPort, int maxPort)
		{
			linphone_core_set_audio_port_range(nativePtr, minPort, maxPort);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_qrcode_decode_rect(IntPtr thiz, int x, int y, int w, int h);

		/// <summary>
		/// Set the rectangle where the decoder will search a QRCode. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="x">axis </param>
		/// <param name="y">axis </param>
		/// <param name="w">width </param>
		/// <param name="h">height </param>
		public void SetQrcodeDecodeRect(int x, int y, int w, int h)
		{
			linphone_core_set_qrcode_decode_rect(nativePtr, x, y, w, h);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_refresh_window(IntPtr thiz, int minValue, int maxValue);

		/// <summary>
		/// Set the refresh window. 
		/// <para>
		/// During this window, belle-sip schedules the refreshes of the sip messages 
		/// </para>
		/// </summary>
		/// <param name="minValue">lower bound of the refresh window </param>
		/// <param name="maxValue">upper bound of the refresh window </param>
		/// <remarks>Warning : The refresh window must be set before starting the core
		/// </remarks> 
		public void SetRefreshWindow(int minValue, int maxValue)
		{
			linphone_core_set_refresh_window(nativePtr, minValue, maxValue);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_text_port_range(IntPtr thiz, int minPort, int maxPort);

		/// <summary>
		/// Sets the UDP port range from which to randomly select the port used for text
		/// streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="minPort">The lower bound of the text port range to use </param>
		/// <param name="maxPort">The upper bound of the text port range to use </param>
		public void SetTextPortRange(int minPort, int maxPort)
		{
			linphone_core_set_text_port_range(nativePtr, minPort, maxPort);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_tone(IntPtr thiz, int toneId, string audiofile);

		/// <summary>
		/// Assign an audio file to be played as a specific tone id. 
		/// <para>
		/// This function typically allows to customize telephony tones per country. 
		/// </para>
		/// </summary>
		/// <param name="toneId">the #LinphoneToneId </param>
		/// <param name="audiofile">a wav file to be played or null to disable it.   
		/// </param>
		public void SetTone(Linphone.ToneID toneId, string audiofile)
		{
			linphone_core_set_tone(nativePtr, (int)toneId, audiofile);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_user_agent(IntPtr thiz, string name, string version);

		/// <summary>
		/// Set the user agent string used in SIP messages. 
		/// <para>
		/// Set the user agent string used in SIP messages as
		/// &quot;[ua_name]/[version]&quot;. No slash character will be printed if null is
		/// given to &quot;version&quot;. If null is given to &quot;ua_name&quot; and
		/// &quot;version&quot; both, the User-agent header will be empty.
		/// This function should be called just after linphone_factory_create_core ideally. 
		/// </para>
		/// </summary>
		/// <param name="name">Name of the user agent.    </param>
		/// <param name="version">Version of the user agent.    </param>
		public void SetUserAgent(string name, string version)
		{
			linphone_core_set_user_agent(nativePtr, name, version);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_set_video_port_range(IntPtr thiz, int minPort, int maxPort);

		/// <summary>
		/// Sets the UDP port range from which to randomly select the port used for video
		/// streaming. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="minPort">The lower bound of the video port range to use </param>
		/// <param name="maxPort">The upper bound of the video port range to use </param>
		public void SetVideoPortRange(int minPort, int maxPort)
		{
			linphone_core_set_video_port_range(nativePtr, minPort, maxPort);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_sound_device_can_capture(IntPtr thiz, string device);

		/// <summary>
		/// Tells whether a specified sound device can capture sound. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="device">the device name as returned by
		/// linphone_core_get_sound_devices    </param>
		/// <returns>A boolean value telling whether the specified sound device can capture
		/// sound </returns>
		/// deprecated : 08/07/2020 use <see cref="Linphone.AudioDevice">
		/// Linphone.AudioDevice</see> API instead()
		public bool SoundDeviceCanCapture(string device)
		{
			bool returnVal = linphone_core_sound_device_can_capture(nativePtr, device) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_sound_device_can_playback(IntPtr thiz, string device);

		/// <summary>
		/// Tells whether a specified sound device can play sound. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="device">the device name as returned by
		/// linphone_core_get_sound_devices    </param>
		/// <returns>A boolean value telling whether the specified sound device can play
		/// sound </returns>
		/// deprecated : 08/07/2020 use <see cref="Linphone.AudioDevice">
		/// Linphone.AudioDevice</see> API instead()
		public bool SoundDeviceCanPlayback(string device)
		{
			bool returnVal = linphone_core_sound_device_can_playback(nativePtr, device) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_sound_resources_locked(IntPtr thiz);

		/// <summary>
		/// Check if a call will need the sound resources in near future (typically an
		/// outgoing call that is awaiting response). 
		/// <para>
		/// In liblinphone, it is not possible to have two independant calls using sound
		/// device or camera at the same time. In order to prevent this situation, an
		/// application can use <see cref="Linphone.Core.SoundResourcesLocked()">
		/// Linphone.Core.SoundResourcesLocked()</see> to know whether it is possible at a
		/// given time to start a new outgoing call. When the function returns true, an
		/// application should not allow the user to start an outgoing call. 
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether a call will need the sound resources
		/// in near future </returns>
		public bool SoundResourcesLocked()
		{
			bool returnVal = linphone_core_sound_resources_locked(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_start(IntPtr thiz);

		/// <summary>
		/// Start a <see cref="Linphone.Core">Linphone.Core</see> object after it has been
		/// instantiated and not automatically started. 
		/// <para>
		/// Also re-initialize a <see cref="Linphone.Core">Linphone.Core</see> object that
		/// has been stopped using <see cref="Linphone.Core.Stop()">
		/// Linphone.Core.Stop()</see>. Must be called only if <see cref="Linphone.GlobalState">
		/// Linphone.GlobalState</see> is either Ready of Off. State will changed to
		/// Startup, Configuring and then On.
		/// </para>
		/// </summary>
		/// <returns>0: success, -1: global failure, -2: could not connect database
		/// </returns>
		public void Start()
		{
			int exception_result = linphone_core_start(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Start returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_start_conference_recording(IntPtr thiz, string path);

		/// <summary>
		/// Start recording the running conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="path">Path to the file where the recording will be written   
		/// </param>
		/// <returns>0 if succeeded. Negative number if failed </returns>
		/// deprecated : 14/09/2021 Use <see cref="Linphone.Conference.StartRecording()">
		/// Linphone.Conference.StartRecording()</see> instead. 
		public void StartConferenceRecording(string path)
		{
			int exception_result = linphone_core_start_conference_recording(nativePtr, path);
			if (exception_result != 0) throw new LinphoneException("StartConferenceRecording returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_start_echo_canceller_calibration(IntPtr thiz);

		/// <summary>
		/// Starts an echo calibration of the sound devices, in order to find adequate
		/// settings for the echo canceler automatically. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>LinphoneStatus whether calibration has started or not. </returns>
		public void StartEchoCancellerCalibration()
		{
			int exception_result = linphone_core_start_echo_canceller_calibration(nativePtr);
			if (exception_result != 0) throw new LinphoneException("StartEchoCancellerCalibration returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_start_echo_tester(IntPtr thiz, uint rate);

		/// <summary>
		/// Start the simulation of call to test the latency with an external device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="rate">Sound sample rate. </param>
		/// <returns>-1 in case of failure, 1 otherwise. </returns>
		public void StartEchoTester(uint rate)
		{
			int exception_result = linphone_core_start_echo_tester(nativePtr, rate);
			if (exception_result != 0) throw new LinphoneException("StartEchoTester returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_stop(IntPtr thiz);

		/// <summary>
		/// Stop a <see cref="Linphone.Core">Linphone.Core</see> object after it has been
		/// instantiated and started. 
		/// <para>
		/// If stopped, it can be started again using <see cref="Linphone.Core.Start()">
		/// Linphone.Core.Start()</see>. Must be called only if <see cref="Linphone.GlobalState">
		/// Linphone.GlobalState</see> is either On. State will changed to Shutdown and
		/// then Off.
		/// </para>
		/// </summary>
		public void Stop()
		{
			linphone_core_stop(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_stop_async(IntPtr thiz);

		/// <summary>
		/// Stop asynchronously a <see cref="Linphone.Core">Linphone.Core</see> object
		/// after it has been instantiated and started. 
		/// <para>
		/// State changes to Shutdown then <see cref="Linphone.Core.Iterate()">
		/// Linphone.Core.Iterate()</see> must be called to allow the Core to end
		/// asynchronous tasks (terminate call, etc.). When all tasks are finished, State
		/// will change to Off. Must be called only if <see cref="Linphone.GlobalState">
		/// Linphone.GlobalState</see> is On. When <see cref="Linphone.GlobalState">
		/// Linphone.GlobalState</see> is Off <see cref="Linphone.Core">Linphone.Core</see>
		/// can be started again using <see cref="Linphone.Core.Start()">
		/// Linphone.Core.Start()</see>.
		/// </para>
		/// </summary>
		public void StopAsync()
		{
			linphone_core_stop_async(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_stop_conference_recording(IntPtr thiz);

		/// <summary>
		/// Stop recording the running conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if succeeded. Negative number if failed </returns>
		/// deprecated : 14/09/2021 Use <see cref="Linphone.Conference.StopRecording()">
		/// Linphone.Conference.StopRecording()</see> instead. 
		public void StopConferenceRecording()
		{
			int exception_result = linphone_core_stop_conference_recording(nativePtr);
			if (exception_result != 0) throw new LinphoneException("StopConferenceRecording returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_stop_dtmf(IntPtr thiz);

		/// <summary>
		/// Stops playing a dtmf started by <see cref="Linphone.Core.PlayDtmf()">
		/// Linphone.Core.PlayDtmf()</see>. 
		/// <para>
		/// </para>
		/// </summary>
		public void StopDtmf()
		{
			linphone_core_stop_dtmf(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_stop_echo_tester(IntPtr thiz);

		/// <summary>
		/// Stop the simulation of call. 
		/// <para>
		/// </para>
		/// </summary>
		public void StopEchoTester()
		{
			int exception_result = linphone_core_stop_echo_tester(nativePtr);
			if (exception_result != 0) throw new LinphoneException("StopEchoTester returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_stop_ringing(IntPtr thiz);

		/// <summary>
		/// Whenever the liblinphone is playing a ring to advertise an incoming call or
		/// ringback of an outgoing call, this function stops the ringing. 
		/// <para>
		/// Typical use is to stop ringing when the user requests to ignore the call. 
		/// </para>
		/// </summary>
		public void StopRinging()
		{
			linphone_core_stop_ringing(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_core_subscribe(IntPtr thiz, IntPtr resource, string ev, int expires, IntPtr body);

		/// <summary>
		/// Create an outgoing subscription, specifying the destination resource, the event
		/// name, and an optional content body. 
		/// <para>
		/// If accepted, the subscription runs for a finite period, but is automatically
		/// renewed if not terminated before. 
		/// </para>
		/// </summary>
		/// <param name="resource">the destination resource    </param>
		/// <param name="ev">the event name    </param>
		/// <param name="expires">the whished duration of the subscription </param>
		/// <param name="body">an optional body, may be null.    </param>
		/// <returns>a <see cref="Linphone.Event">Linphone.Event</see> holding the context
		/// of the created subcription.    </returns>
		public Linphone.Event Subscribe(Linphone.Address resource, string ev, int expires, Linphone.Content body)
		{
			IntPtr ptr = linphone_core_subscribe(nativePtr, resource != null ? resource.nativePtr : IntPtr.Zero, ev, expires, body != null ? body.nativePtr : IntPtr.Zero);
			Linphone.Event returnVal = fromNativePtr<Linphone.Event>(ptr, true);
			
			GC.KeepAlive(resource);
GC.KeepAlive(body);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_take_preview_snapshot(IntPtr thiz, string file);

		/// <summary>
		/// Take a photo of currently from capture device and write it into a jpeg file. 
		/// <para>
		/// Note that the snapshot is asynchronous, an application shall not assume that
		/// the file is created when the function returns.
		/// </para>
		/// </summary>
		/// <param name="file">a path where to write the jpeg content.    </param>
		/// <returns>0 if successful, -1 otherwise (typically if jpeg format is not
		/// supported). </returns>
		public void TakePreviewSnapshot(string file)
		{
			int exception_result = linphone_core_take_preview_snapshot(nativePtr, file);
			if (exception_result != 0) throw new LinphoneException("TakePreviewSnapshot returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_terminate_all_calls(IntPtr thiz);

		/// <summary>
		/// Terminates all the calls. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 </returns>
		public void TerminateAllCalls()
		{
			int exception_result = linphone_core_terminate_all_calls(nativePtr);
			if (exception_result != 0) throw new LinphoneException("TerminateAllCalls returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_core_terminate_conference(IntPtr thiz);

		/// <summary>
		/// Terminate the running conference. 
		/// <para>
		/// If it is a local conference, all calls inside it will become back separate
		/// calls and will be put in #LinphoneCallPaused state. If it is a conference
		/// involving a focus server, all calls inside the conference will be terminated. 
		/// </para>
		/// </summary>
		/// <returns>0 if succeeded. Negative number if failed </returns>
		public void TerminateConference()
		{
			int exception_result = linphone_core_terminate_conference(nativePtr);
			if (exception_result != 0) throw new LinphoneException("TerminateConference returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_upload_log_collection(IntPtr thiz);

		/// <summary>
		/// Upload the log collection to the configured server url. 
		/// <para>
		/// </para>
		/// </summary>
		public void UploadLogCollection()
		{
			linphone_core_upload_log_collection(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_use_preview_window(IntPtr thiz, char yesno);

		/// <summary>
		/// Tells the core to use a separate window for local camera preview video, instead
		/// of inserting local view within the remote video window. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="yesno">true to use a separate window, false to insert the preview
		/// in the remote video window. </param>
		public void UsePreviewWindow(bool yesno)
		{
			linphone_core_use_preview_window(nativePtr, yesno ? (char)1 : (char)0);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_verify_server_certificates(IntPtr thiz, char yesno);

		/// <summary>
		/// Specify whether the tls server certificate must be verified when connecting to
		/// a SIP/TLS server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="yesno">A boolean value telling whether the tls server certificate
		/// must be verified </param>
		public void VerifyServerCertificates(bool yesno)
		{
			linphone_core_verify_server_certificates(nativePtr, yesno ? (char)1 : (char)0);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_core_verify_server_cn(IntPtr thiz, char yesno);

		/// <summary>
		/// Specify whether the tls server certificate common name must be verified when
		/// connecting to a SIP/TLS server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="yesno">A boolean value telling whether the tls server certificate
		/// common name must be verified </param>
		public void VerifyServerCn(bool yesno)
		{
			linphone_core_verify_server_cn(nativePtr, yesno ? (char)1 : (char)0);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_core_video_supported(IntPtr thiz);

		/// <summary>
		/// Test if video is supported. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the library was built with video support, false otherwise
		/// </returns>
		public bool VideoSupported()
		{
			bool returnVal = linphone_core_video_supported(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
	}
	/// <summary>
	/// Represents a dial plan. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class DialPlan : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_by_ccc(string ccc);

		/// <summary>
		/// Find best match for given CCC. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="ccc">The country calling code    </param>
		/// <returns>the matching dial plan, or a generic one if none found    </returns>
		public static Linphone.DialPlan ByCcc(string ccc)
		{
			IntPtr ptr = linphone_dial_plan_by_ccc(ccc);
			Linphone.DialPlan returnVal = fromNativePtr<Linphone.DialPlan>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_by_ccc_as_int(int ccc);

		/// <summary>
		/// Find best match for given CCC. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="ccc">the country calling code    </param>
		/// <returns>the matching dial plan, or a generic one if none found    </returns>
		public static Linphone.DialPlan ByCccAsInt(int ccc)
		{
			IntPtr ptr = linphone_dial_plan_by_ccc_as_int(ccc);
			Linphone.DialPlan returnVal = fromNativePtr<Linphone.DialPlan>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_get_all_list();

		/// <summary>
		/// Returns a list of all known dial plans. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The list of all known dial plans.         </returns>
		static public IEnumerable<Linphone.DialPlan> AllList
		{
			get
			{
				return MarshalBctbxList<Linphone.DialPlan>(linphone_dial_plan_get_all_list(), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_dial_plan_lookup_ccc_from_e164(string e164);

		/// <summary>
		/// Function to get call country code from an e164 number, ex: +33952650121 will
		/// return 33. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="e164">phone number    </param>
		/// <returns>call country code or -1 if not found </returns>
		public static int LookupCccFromE164(string e164)
		{
			int returnVal = linphone_dial_plan_lookup_ccc_from_e164(e164);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_dial_plan_lookup_ccc_from_iso(string iso);

		/// <summary>
		/// Function to get call country code from ISO 3166-1 alpha-2 code, ex: FR returns
		/// 33. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="iso">country code alpha2    </param>
		/// <returns>call country code or -1 if not found </returns>
		public static int LookupCccFromIso(string iso)
		{
			int returnVal = linphone_dial_plan_lookup_ccc_from_iso(iso);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_get_country(IntPtr thiz);

		/// <summary>
		/// Returns the country name of the dialplan. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the country name </returns>
		public string Country
		{
			get
			{
				IntPtr stringPtr = linphone_dial_plan_get_country(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_get_country_calling_code(IntPtr thiz);

		/// <summary>
		/// Returns the country calling code of the dialplan. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the country calling code    </returns>
		public string CountryCallingCode
		{
			get
			{
				IntPtr stringPtr = linphone_dial_plan_get_country_calling_code(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_get_flag(IntPtr thiz);

		/// <summary>
		/// Returns the flag of the teritory as unicode characters. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the flag as unicode characters    </returns>
		public string Flag
		{
			get
			{
				IntPtr stringPtr = linphone_dial_plan_get_flag(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_get_international_call_prefix(IntPtr thiz);

		/// <summary>
		/// Returns the international call prefix of the dialplan. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the international call prefix    </returns>
		public string InternationalCallPrefix
		{
			get
			{
				IntPtr stringPtr = linphone_dial_plan_get_international_call_prefix(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_dial_plan_is_generic(IntPtr thiz);

		/// <summary>
		/// Return if given plan is generic. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if generic, false otherwise </returns>
		public bool IsGeneric
		{
			get
			{
				return linphone_dial_plan_is_generic(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dial_plan_get_iso_country_code(IntPtr thiz);

		/// <summary>
		/// Returns the iso country code of the dialplan. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the iso country code    </returns>
		public string IsoCountryCode
		{
			get
			{
				IntPtr stringPtr = linphone_dial_plan_get_iso_country_code(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_dial_plan_get_national_number_length(IntPtr thiz);

		/// <summary>
		/// Returns the national number length of the dialplan. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the national number length </returns>
		public int NationalNumberLength
		{
			get
			{
				return linphone_dial_plan_get_national_number_length(nativePtr);
			}
		}
	}
	/// <summary>
	/// Object that represents key-value pair container. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Dictionary : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_dictionary_clear(IntPtr thiz);

		/// <summary>
		/// Clears the dictionary. 
		/// <para>
		/// </para>
		/// </summary>
		public void Clear()
		{
			linphone_dictionary_clear(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dictionary_clone(IntPtr thiz);

		/// <summary>
		/// Instantiates a new dictionary with values from source. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The newly created <see cref="Linphone.Dictionary">
		/// Linphone.Dictionary</see> object.    </returns>
		public Linphone.Dictionary Clone()
		{
			IntPtr ptr = linphone_dictionary_clone(nativePtr);
			Linphone.Dictionary returnVal = fromNativePtr<Linphone.Dictionary>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_dictionary_get_float(IntPtr thiz, string key);

		/// <summary>
		/// Gets the float value of a key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key.    </param>
		/// <returns>The username.    </returns>
		public float GetFloat(string key)
		{
			float returnVal = linphone_dictionary_get_float(nativePtr, key);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_dictionary_get_int(IntPtr thiz, string key);

		/// <summary>
		/// Gets the int value of a key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key.    </param>
		/// <returns>The username.    </returns>
		public int GetInt(string key)
		{
			int returnVal = linphone_dictionary_get_int(nativePtr, key);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_dictionary_get_int64(IntPtr thiz, string key);

		/// <summary>
		/// Gets the int64 value of a key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key.    </param>
		/// <returns>The username.    </returns>
		public int GetInt64(string key)
		{
			int returnVal = linphone_dictionary_get_int64(nativePtr, key);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_dictionary_get_string(IntPtr thiz, string key);

		/// <summary>
		/// Gets the char* value of a key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key.    </param>
		/// <returns>The username.    </returns>
		public string GetString(string key)
		{
			IntPtr stringPtr = linphone_dictionary_get_string(nativePtr, key);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_dictionary_has_key(IntPtr thiz, string key);

		/// <summary>
		/// Search if the key is present in the dictionary. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key.    </param>
		/// <returns>The LinphoneStatus of the operation. </returns>
		public void HasKey(string key)
		{
			int exception_result = linphone_dictionary_has_key(nativePtr, key);
			if (exception_result != 0) throw new LinphoneException("HasKey returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_dictionary_remove(IntPtr thiz, string key);

		/// <summary>
		/// Removes the pair of the key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key.    </param>
		/// <returns>The LinphoneStatus of the operation. </returns>
		public void Remove(string key)
		{
			int exception_result = linphone_dictionary_remove(nativePtr, key);
			if (exception_result != 0) throw new LinphoneException("Remove returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_dictionary_set_float(IntPtr thiz, string key, float val);

		/// <summary>
		/// Sets a float value to a key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key.    </param>
		/// <param name="val">The int value. </param>
		public void SetFloat(string key, float val)
		{
			linphone_dictionary_set_float(nativePtr, key, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_dictionary_set_int(IntPtr thiz, string key, int val);

		/// <summary>
		/// Sets a int value to a key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key.    </param>
		/// <param name="val">The int value. </param>
		public void SetInt(string key, int val)
		{
			linphone_dictionary_set_int(nativePtr, key, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_dictionary_set_int64(IntPtr thiz, string key, int val);

		/// <summary>
		/// Sets a int64 value to a key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key.    </param>
		/// <param name="val">The int64 value. </param>
		public void SetInt64(string key, int val)
		{
			linphone_dictionary_set_int64(nativePtr, key, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_dictionary_set_string(IntPtr thiz, string key, string val);

		/// <summary>
		/// Sets a char* value to a key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key.    </param>
		/// <param name="val">The char* value. </param>
		public void SetString(string key, string val)
		{
			linphone_dictionary_set_string(nativePtr, key, val);
			
			
						
		}
	}
	/// <summary>
	/// The LinphoneDigestAuthenticationPolicy holds parameters relative to digest
	/// authentication procedures. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class DigestAuthenticationPolicy : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_digest_authentication_policy_get_allow_md5(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_digest_authentication_policy_set_allow_md5(IntPtr thiz, char val);

		/// <summary>
		/// Get whether MD5 hash algorithm is allowed. 
		/// <para>
		/// The default value is true, in order to maximize interoperability. MD5 is
		/// considered as a weak algorithm, some might want to disable it, in which case
		/// SHA-256 will be required to perform digest authentication. 
		/// </para>
		/// </summary>
		/// <returns>a boolean value </returns>
		public bool AllowMd5
		{
			get
			{
				return linphone_digest_authentication_policy_get_allow_md5(nativePtr) != 0;
			}
			set
			{
				linphone_digest_authentication_policy_set_allow_md5(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_digest_authentication_policy_get_allow_no_qop(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_digest_authentication_policy_set_allow_no_qop(IntPtr thiz, char val);

		/// <summary>
		/// Get whether digest authentication without &apos;qop=auth&apos; mode is allowed. 
		/// <para>
		/// The default value is true, in order to maximize interoperability.
		/// &apos;qop=auth&apos; mode enforces security thanks to the use of a client
		/// nonce, which makes password brute forcing more difficult. When set to false,
		/// linphone will refuse to authenticate to servers that are not implementing the
		/// qop=auth mode. 
		/// </para>
		/// </summary>
		/// <returns>a boolean value </returns>
		public bool AllowNoQop
		{
			get
			{
				return linphone_digest_authentication_policy_get_allow_no_qop(nativePtr) != 0;
			}
			set
			{
				linphone_digest_authentication_policy_set_allow_no_qop(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
	}
	/// <summary>
	/// Object representing full details about a signaling error or status. 
	/// <para>
	/// All <see cref="Linphone.ErrorInfo">Linphone.ErrorInfo</see> object returned by
	/// the liblinphone API are readonly and transcients. For safety they must be used
	/// immediately after obtaining them. Any other function call to the liblinphone
	/// may change their content or invalidate the pointer. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ErrorInfo : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_error_info_get_phrase(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_phrase(IntPtr thiz, string phrase);

		/// <summary>
		/// Get textual phrase from the error info. 
		/// <para>
		/// This is the text that is provided by the peer in the protocol (SIP). 
		/// </para>
		/// </summary>
		/// <returns>The error phrase    </returns>
		public string Phrase
		{
			get
			{
				IntPtr stringPtr = linphone_error_info_get_phrase(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_error_info_set_phrase(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_error_info_get_protocol(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_protocol(IntPtr thiz, string protocol);

		/// <summary>
		/// Get protocol from the error info. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The protocol.    </returns>
		public string Protocol
		{
			get
			{
				IntPtr stringPtr = linphone_error_info_get_protocol(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_error_info_set_protocol(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_error_info_get_protocol_code(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_protocol_code(IntPtr thiz, int code);

		/// <summary>
		/// Get the status code from the low level protocol (ex a SIP status code). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The status code </returns>
		public int ProtocolCode
		{
			get
			{
				return linphone_error_info_get_protocol_code(nativePtr);
			}
			set
			{
				linphone_error_info_set_protocol_code(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.Reason linphone_error_info_get_reason(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_reason(IntPtr thiz, int reason);

		/// <summary>
		/// Get reason code from the error info. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.Reason">Linphone.Reason</see> object </returns>
		public Linphone.Reason Reason
		{
			get
			{
				return linphone_error_info_get_reason(nativePtr);
			}
			set
			{
				linphone_error_info_set_reason(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_error_info_get_retry_after(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_retry_after(IntPtr thiz, int retryAfter);

		/// <summary>
		/// Get Retry-After delay second from the error info. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The Retry-After delay second </returns>
		public int RetryAfter
		{
			get
			{
				return linphone_error_info_get_retry_after(nativePtr);
			}
			set
			{
				linphone_error_info_set_retry_after(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_error_info_get_sub_error_info(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_sub_error_info(IntPtr thiz, IntPtr appendedErrorInfo);

		/// <summary>
		/// Get pointer to chained <see cref="Linphone.ErrorInfo">Linphone.ErrorInfo</see>
		/// set in sub_ei. 
		/// <para>
		/// It corresponds to a Reason header in a received SIP response. 
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.ErrorInfo">Linphone.ErrorInfo</see> pointer
		/// defined in the ei object.    </returns>
		public Linphone.ErrorInfo SubErrorInfo
		{
			get
			{
				IntPtr ptr = linphone_error_info_get_sub_error_info(nativePtr);
				Linphone.ErrorInfo obj = fromNativePtr<Linphone.ErrorInfo>(ptr, true);
				return obj;
			}
			set
			{
				linphone_error_info_set_sub_error_info(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_error_info_get_warnings(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set_warnings(IntPtr thiz, string warnings);

		/// <summary>
		/// Provides additional information regarding the failure. 
		/// <para>
		/// With SIP protocol, the content of &quot;Warning&quot; headers are returned. 
		/// </para>
		/// </summary>
		/// <returns>More details about the failure.    </returns>
		public string Warnings
		{
			get
			{
				IntPtr stringPtr = linphone_error_info_get_warnings(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_error_info_set_warnings(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_error_info_set(IntPtr thiz, string protocol, int reason, int code, string status, string warning);

		/// <summary>
		/// Assign information to a <see cref="Linphone.ErrorInfo">Linphone.ErrorInfo</see>
		/// object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="protocol">protocol name    </param>
		/// <param name="reason">reason from <see cref="Linphone.Reason">
		/// Linphone.Reason</see> enum </param>
		/// <param name="code">protocol code </param>
		/// <param name="status">description of the reason    </param>
		/// <param name="warning">warning message    </param>
		public void Set(string protocol, Linphone.Reason reason, int code, string status, string warning)
		{
			linphone_error_info_set(nativePtr, protocol, (int)reason, code, status, warning);
			
			
						
		}
	}
	/// <summary>
	/// Object representing an event state, which is subcribed or published. 
	/// <para>
	/// </para>
	/// </summary>
	/// <remarks>See : <see cref="Linphone.Core.Publish()">
	/// Linphone.Core.Publish()</see> </remarks>
	/// <remarks>See : <see cref="Linphone.Core.Subscribe()">
	/// Linphone.Core.Subscribe()</see> </remarks>
	[StructLayout(LayoutKind.Sequential)]
	public class Event : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_event_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private EventListener listener;

		public EventListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_event_cbs(linphone_factory_get());
					listener = fromNativePtr<EventListener>(nativeListener, false, true);
					linphone_event_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_event_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_core(IntPtr thiz);

		/// <summary>
		/// Returns back pointer to the <see cref="Linphone.Core">Linphone.Core</see> that
		/// created this <see cref="Linphone.Event">Linphone.Event</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Core">Linphone.Core</see> object associated.  
		///  </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_event_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_error_info(IntPtr thiz);

		/// <summary>
		/// Get full details about an error occured. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.ErrorInfo">Linphone.ErrorInfo</see> object.   
		/// </returns>
		public Linphone.ErrorInfo ErrorInfo
		{
			get
			{
				IntPtr ptr = linphone_event_get_error_info(nativePtr);
				Linphone.ErrorInfo obj = fromNativePtr<Linphone.ErrorInfo>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_from(IntPtr thiz);

		/// <summary>
		/// Get the &quot;from&quot; address of the subscription. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the from <see cref="Linphone.Address">Linphone.Address</see>.   
		/// </returns>
		public Linphone.Address From
		{
			get
			{
				IntPtr ptr = linphone_event_get_from(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_name(IntPtr thiz);

		/// <summary>
		/// Get the name of the event as specified in the event package RFC. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the event name.    </returns>
		public string Name
		{
			get
			{
				IntPtr stringPtr = linphone_event_get_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.PublishState linphone_event_get_publish_state(IntPtr thiz);

		/// <summary>
		/// Get publish state. 
		/// <para>
		/// If the event object was not created by a publish mechanism, <see cref="Linphone.PublishState.None">
		/// Linphone.PublishState.None</see> is returned. 
		/// </para>
		/// </summary>
		/// <returns>the current <see cref="Linphone.PublishState">
		/// Linphone.PublishState</see> </returns>
		public Linphone.PublishState PublishState
		{
			get
			{
				return linphone_event_get_publish_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.Reason linphone_event_get_reason(IntPtr thiz);

		/// <summary>
		/// Return reason code (in case of error state reached). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Reason">Linphone.Reason</see> enum </returns>
		public Linphone.Reason Reason
		{
			get
			{
				return linphone_event_get_reason(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_remote_contact(IntPtr thiz);

		/// <summary>
		/// Get the &quot;contact&quot; address of the subscription. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The &quot;contact&quot; address of the subscription    </returns>
		public Linphone.Address RemoteContact
		{
			get
			{
				IntPtr ptr = linphone_event_get_remote_contact(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_resource(IntPtr thiz);

		/// <summary>
		/// Get the resource address of the subscription or publish. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the resource <see cref="Linphone.Address">Linphone.Address</see>.   
		/// </returns>
		public Linphone.Address Resource
		{
			get
			{
				IntPtr ptr = linphone_event_get_resource(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SubscriptionDir linphone_event_get_subscription_dir(IntPtr thiz);

		/// <summary>
		/// Get subscription direction. 
		/// <para>
		/// If the object wasn&apos;t created by a subscription mechanism, <see cref="Linphone.SubscriptionDir.InvalidDir">
		/// Linphone.SubscriptionDir.InvalidDir</see> is returned. 
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.SubscriptionDir">
		/// Linphone.SubscriptionDir</see> </returns>
		public Linphone.SubscriptionDir SubscriptionDir
		{
			get
			{
				return linphone_event_get_subscription_dir(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SubscriptionState linphone_event_get_subscription_state(IntPtr thiz);

		/// <summary>
		/// Get subscription state. 
		/// <para>
		/// If the event object was not created by a subscription mechanism, <see cref="Linphone.SubscriptionState.None">
		/// Linphone.SubscriptionState.None</see> is returned. 
		/// </para>
		/// </summary>
		/// <returns>the current <see cref="Linphone.SubscriptionState">
		/// Linphone.SubscriptionState</see> </returns>
		public Linphone.SubscriptionState SubscriptionState
		{
			get
			{
				return linphone_event_get_subscription_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_to(IntPtr thiz);

		/// <summary>
		/// Get the &quot;to&quot; address of the subscription. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the &quot;to&quot; <see cref="Linphone.Address">
		/// Linphone.Address</see>.    </returns>
		public Linphone.Address To
		{
			get
			{
				IntPtr ptr = linphone_event_get_to(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_accept_publish(IntPtr thiz);

		/// <summary>
		/// Accept an incoming publish. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, error code otherwise </returns>
		public void AcceptPublish()
		{
			int exception_result = linphone_event_accept_publish(nativePtr);
			if (exception_result != 0) throw new LinphoneException("AcceptPublish returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_accept_subscription(IntPtr thiz);

		/// <summary>
		/// Accept an incoming subcription. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, error code otherwise </returns>
		public void AcceptSubscription()
		{
			int exception_result = linphone_event_accept_subscription(nativePtr);
			if (exception_result != 0) throw new LinphoneException("AcceptSubscription returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_event_add_custom_header(IntPtr thiz, string name, string val);

		/// <summary>
		/// Add a custom header to an outgoing susbscription or publish. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">header&apos;s name    </param>
		/// <param name="val">the header&apos;s value.    </param>
		public void AddCustomHeader(string name, string val)
		{
			linphone_event_add_custom_header(nativePtr, name, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_deny_publish(IntPtr thiz, int reason);

		/// <summary>
		/// Deny an incoming publish with given reason. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="reason">The <see cref="Linphone.Reason">Linphone.Reason</see> of
		/// denial.    </param>
		/// <returns>0 if successful, error code otherwise </returns>
		public void DenyPublish(Linphone.Reason reason)
		{
			int exception_result = linphone_event_deny_publish(nativePtr, (int)reason);
			if (exception_result != 0) throw new LinphoneException("DenyPublish returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_deny_subscription(IntPtr thiz, int reason);

		/// <summary>
		/// Deny an incoming subscription with given reason. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="reason">The <see cref="Linphone.Reason">Linphone.Reason</see> of
		/// denial.    </param>
		/// <returns>0 if successful, error code otherwise </returns>
		public void DenySubscription(Linphone.Reason reason)
		{
			int exception_result = linphone_event_deny_subscription(nativePtr, (int)reason);
			if (exception_result != 0) throw new LinphoneException("DenySubscription returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_get_custom_header(IntPtr thiz, string name);

		/// <summary>
		/// Obtain the value of a given header for an incoming subscription. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">header&apos;s name    </param>
		/// <returns>the header&apos;s value or null if such header doesn&apos;t exist.   
		/// </returns>
		public string GetCustomHeader(string name)
		{
			IntPtr stringPtr = linphone_event_get_custom_header(nativePtr, name);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_notify(IntPtr thiz, IntPtr body);

		/// <summary>
		/// Send a notification. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="body">an optional body containing the actual notification data.  
		/// </param>
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void Notify(Linphone.Content body)
		{
			int exception_result = linphone_event_notify(nativePtr, body != null ? body.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("Notify returned value" + exception_result);
			
			GC.KeepAlive(body);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_event_pause_publish(IntPtr thiz);

		/// <summary>
		/// Prevent an event from refreshing its publish. 
		/// <para>
		/// This is useful to let registrations to expire naturally (or) when the
		/// application wants to keep control on when refreshes are sent. The refreshing
		/// operations can be resumed with <see cref="Linphone.ProxyConfig.RefreshRegister()">
		/// Linphone.ProxyConfig.RefreshRegister()</see>. 
		/// </para>
		/// </summary>
		public void PausePublish()
		{
			linphone_event_pause_publish(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_refresh_publish(IntPtr thiz);

		/// <summary>
		/// Refresh an outgoing publish keeping the same body. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void RefreshPublish()
		{
			int exception_result = linphone_event_refresh_publish(nativePtr);
			if (exception_result != 0) throw new LinphoneException("RefreshPublish returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_refresh_subscribe(IntPtr thiz);

		/// <summary>
		/// Refresh an outgoing subscription keeping the same body. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void RefreshSubscribe()
		{
			int exception_result = linphone_event_refresh_subscribe(nativePtr);
			if (exception_result != 0) throw new LinphoneException("RefreshSubscribe returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_event_remove_custom_header(IntPtr thiz, string name);

		/// <summary>
		/// Remove custom header to an outgoing susbscription or publish. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">header&apos;s name    </param>
		public void RemoveCustomHeader(string name)
		{
			linphone_event_remove_custom_header(nativePtr, name);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_send_publish(IntPtr thiz, IntPtr body);

		/// <summary>
		/// Send a publish created by <see cref="Linphone.Core.CreatePublish()">
		/// Linphone.Core.CreatePublish()</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="body">the new data to be published    </param>
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void SendPublish(Linphone.Content body)
		{
			int exception_result = linphone_event_send_publish(nativePtr, body != null ? body.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("SendPublish returned value" + exception_result);
			
			GC.KeepAlive(body);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_send_subscribe(IntPtr thiz, IntPtr body);

		/// <summary>
		/// Send a subscription previously created by <see cref="Linphone.Core.CreateSubscribe()">
		/// Linphone.Core.CreateSubscribe()</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="body">optional content to attach with the subscription.    </param>
		/// <returns>0 if successful, -1 otherwise. </returns>
		public void SendSubscribe(Linphone.Content body)
		{
			int exception_result = linphone_event_send_subscribe(nativePtr, body != null ? body.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("SendSubscribe returned value" + exception_result);
			
			GC.KeepAlive(body);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_event_terminate(IntPtr thiz);

		/// <summary>
		/// Terminate an incoming or outgoing subscription that was previously acccepted,
		/// or a previous publication. 
		/// <para>
		/// The <see cref="Linphone.Event">Linphone.Event</see> shall not be used anymore
		/// after this operation. 
		/// </para>
		/// </summary>
		public void Terminate()
		{
			linphone_event_terminate(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_update_publish(IntPtr thiz, IntPtr body);

		/// <summary>
		/// Update (refresh) a publish. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="body">the new data to be published    </param>
		/// <returns>0 if successful, error code otherwise </returns>
		public void UpdatePublish(Linphone.Content body)
		{
			int exception_result = linphone_event_update_publish(nativePtr, body != null ? body.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("UpdatePublish returned value" + exception_result);
			
			GC.KeepAlive(body);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_update_subscribe(IntPtr thiz, IntPtr body);

		/// <summary>
		/// Update (refresh) an outgoing subscription, changing the body. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="body">an optional body to include in the subscription update, may
		/// be null.    </param>
		/// <returns>0 if successful, error code otherwise    </returns>
		public void UpdateSubscribe(Linphone.Content body)
		{
			int exception_result = linphone_event_update_subscribe(nativePtr, body != null ? body.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("UpdateSubscribe returned value" + exception_result);
			
			GC.KeepAlive(body);
			
		}
	}
	/// <summary>
	/// Object that represents an event that must be stored in database. 
	/// <para>
	/// For example, all chat related events are wrapped in an <see cref="Linphone.EventLog">
	/// Linphone.EventLog</see>, and many callbacks use this kind of type as parameter.
	/// Use <see cref="Linphone.EventLog.Type">Linphone.EventLog.Type</see> to get the
	/// <see cref="Linphone.EventLogType">Linphone.EventLogType</see> it refers to, and
	/// then you can use one of the accessor methods to get the underlying object, for
	/// example <see cref="Linphone.EventLog.ChatMessage">
	/// Linphone.EventLog.ChatMessage</see> for a <see cref="Linphone.ChatMessage">
	/// Linphone.ChatMessage</see>. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class EventLog : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_call_log(IntPtr thiz);

		/// <summary>
		/// Returns the call log of a conference call event. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The conference <see cref="Linphone.CallLog">Linphone.CallLog</see>.   
		/// </returns>
		public Linphone.CallLog CallLog
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_call_log(nativePtr);
				Linphone.CallLog obj = fromNativePtr<Linphone.CallLog>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_chat_message(IntPtr thiz);

		/// <summary>
		/// Returns the chat message of a conference chat message event. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The conference <see cref="Linphone.ChatMessage">
		/// Linphone.ChatMessage</see>.    </returns>
		public Linphone.ChatMessage ChatMessage
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_chat_message(nativePtr);
				Linphone.ChatMessage obj = fromNativePtr<Linphone.ChatMessage>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_conference_info(IntPtr thiz);

		/// <summary>
		/// Returns the conference info of a conference call event. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The conference <see cref="Linphone.ConferenceInfo">
		/// Linphone.ConferenceInfo</see>.    </returns>
		public Linphone.ConferenceInfo ConferenceInfo
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_conference_info(nativePtr);
				Linphone.ConferenceInfo obj = fromNativePtr<Linphone.ConferenceInfo>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_event_log_get_creation_time(IntPtr thiz);

		/// <summary>
		/// Returns the creation time of a event log. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The event creation time </returns>
		public long CreationTime
		{
			get
			{
				return linphone_event_log_get_creation_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_device_address(IntPtr thiz);

		/// <summary>
		/// Returns the device address of a conference participant device event. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The conference device <see cref="Linphone.Address">
		/// Linphone.Address</see>.    </returns>
		public Linphone.Address DeviceAddress
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_device_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_event_log_get_ephemeral_message_lifetime(IntPtr thiz);

		/// <summary>
		/// Returns the ephemeral message lifetime of a conference ephemeral message event. 
		/// <para>
		/// Ephemeral lifetime means the time before an ephemeral message which has been
		/// viewed gets deleted. 
		/// </para>
		/// </summary>
		/// <returns>The ephemeral message lifetime. </returns>
		public int EphemeralMessageLifetime
		{
			get
			{
				return linphone_event_log_get_ephemeral_message_lifetime(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_local_address(IntPtr thiz);

		/// <summary>
		/// Returns the local address of a conference event. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The local <see cref="Linphone.Address">Linphone.Address</see>.   
		/// </returns>
		public Linphone.Address LocalAddress
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_local_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_event_log_get_notify_id(IntPtr thiz);

		/// <summary>
		/// Returns the notify id of a conference notified event. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The conference notify id. </returns>
		public uint NotifyId
		{
			get
			{
				return linphone_event_log_get_notify_id(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_participant_address(IntPtr thiz);

		/// <summary>
		/// Returns the participant address of a conference participant event. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The conference participant <see cref="Linphone.Address">
		/// Linphone.Address</see>.    </returns>
		public Linphone.Address ParticipantAddress
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_participant_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_peer_address(IntPtr thiz);

		/// <summary>
		/// Returns the peer address of a conference event. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The peer <see cref="Linphone.Address">Linphone.Address</see>.   
		/// </returns>
		public Linphone.Address PeerAddress
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_peer_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_security_event_faulty_device_address(IntPtr thiz);

		/// <summary>
		/// Returns the faulty device address of a conference security event. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Address">Linphone.Address</see> of the faulty
		/// device.    </returns>
		public Linphone.Address SecurityEventFaultyDeviceAddress
		{
			get
			{
				IntPtr ptr = linphone_event_log_get_security_event_faulty_device_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SecurityEventType linphone_event_log_get_security_event_type(IntPtr thiz);

		/// <summary>
		/// Returns the type of security event. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.SecurityEventType">
		/// Linphone.SecurityEventType</see> type. </returns>
		public Linphone.SecurityEventType SecurityEventType
		{
			get
			{
				return linphone_event_log_get_security_event_type(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_event_log_get_subject(IntPtr thiz);

		/// <summary>
		/// Returns the subject of a conference subject event. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The conference subject.    </returns>
		public string Subject
		{
			get
			{
				IntPtr stringPtr = linphone_event_log_get_subject(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.EventLogType linphone_event_log_get_type(IntPtr thiz);

		/// <summary>
		/// Returns the type of a event log. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.EventLogType">Linphone.EventLogType</see> type
		/// </returns>
		public Linphone.EventLogType Type
		{
			get
			{
				return linphone_event_log_get_type(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_event_log_delete_from_database(IntPtr thiz);

		/// <summary>
		/// Delete event log from database. 
		/// <para>
		/// </para>
		/// </summary>
		public void DeleteFromDatabase()
		{
			linphone_event_log_delete_from_database(nativePtr);
			
			
						
		}
	}
	/// <summary>
	/// The factory is a singleton object devoted to the creation of all the objects of
	/// Liblinphone that cannot be created by <see cref="Linphone.Core">
	/// Linphone.Core</see> itself. 
	/// <para>
	/// It is also used to configure a few behaviors before creating the <see cref="Linphone.Core">
	/// Linphone.Core</see>, like the logs verbosity or collection. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Factory : LinphoneObject
	{
#if  __ANDROID__
		static Factory()
		{
			Java.Lang.JavaSystem.LoadLibrary("c++_shared");
			Java.Lang.JavaSystem.LoadLibrary("bctoolbox");
			Java.Lang.JavaSystem.LoadLibrary("ortp");
			Java.Lang.JavaSystem.LoadLibrary("mediastreamer2");
			Java.Lang.JavaSystem.LoadLibrary("linphone");
		}
#endif


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_clean();

		/// <summary>
		/// Clean the factory. 
		/// <para>
		/// This function is generally useless as the factory is unique per process,
		/// however calling this function at the end avoid getting reports from belle-sip
		/// leak detector about memory leaked in <see cref="Linphone.Factory.">
		/// Linphone.Factory.</see>. 
		/// </para>
		/// </summary>
		public static void Clean()
		{
			linphone_factory_clean();
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		/// <summary>
		/// Create the <see cref="Linphone.Factory">Linphone.Factory</see> if that has not
		/// been done and return a pointer on it. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer on the <see cref="Linphone.Factory">Linphone.Factory</see>  
		///  </returns>
		static public Linphone.Factory Instance
		{
			get
			{
				IntPtr ptr = linphone_factory_get();
				Linphone.Factory obj = fromNativePtr<Linphone.Factory>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_cache_dir(IntPtr thiz, string path);

		/// <summary>
		/// Set the directory where the application local cache is located. 
		/// <para>
		/// If the path is empty (default value), the path will be computed when calling
		/// <see cref="Linphone.Factory.DataDir">Linphone.Factory.DataDir</see> 
		/// </para>
		/// </summary>
		/// <param name="path">The path to the directory where the application local cache
		/// is located    </param>
		public string CacheDir
		{
			set
			{
				linphone_factory_set_cache_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_config_dir(IntPtr thiz, string path);

		/// <summary>
		/// Set the directory where the configurations are located. 
		/// <para>
		/// If the path is empty (default value), the path will be computed when calling
		/// <see cref="Linphone.Factory.ConfigDir">Linphone.Factory.ConfigDir</see> 
		/// </para>
		/// </summary>
		/// <param name="path">The path to the directory where the configurations are
		/// located    </param>
		public string ConfigDir
		{
			set
			{
				linphone_factory_set_config_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_data_dir(IntPtr thiz, string path);

		/// <summary>
		/// Set the directory where the application local data are located. 
		/// <para>
		/// If the path is empty (default value), the path will be computed when calling
		/// <see cref="Linphone.Factory.DataDir">Linphone.Factory.DataDir</see> 
		/// </para>
		/// </summary>
		/// <param name="path">The path to the directory where the application local data
		/// are located    </param>
		public string DataDir
		{
			set
			{
				linphone_factory_set_data_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_data_resources_dir(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_data_resources_dir(IntPtr thiz, string path);

		/// <summary>
		/// Get the directory where the data resources are located. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to the directory where the data resources are located   
		/// </returns>
		public string DataResourcesDir
		{
			get
			{
				IntPtr stringPtr = linphone_factory_get_data_resources_dir(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_factory_set_data_resources_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_dial_plans(IntPtr thiz);

		/// <summary>
		/// Returns a bctbx_list_t of all DialPlans. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of <see cref="Linphone.DialPlan">Linphone.DialPlan</see>     
		/// </returns>
		public IEnumerable<Linphone.DialPlan> DialPlans
		{
			get
			{
				return MarshalBctbxList<Linphone.DialPlan>(linphone_factory_get_dial_plans(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_download_dir(IntPtr thiz, string path);

		/// <summary>
		/// Set the directory where downloads are located. 
		/// <para>
		/// If the path is empty (default value), the path will be computed when calling
		/// <see cref="Linphone.Factory.DownloadDir">Linphone.Factory.DownloadDir</see> 
		/// </para>
		/// </summary>
		/// <param name="path">The path to the directory where downloads are located   
		/// </param>
		public string DownloadDir
		{
			set
			{
				linphone_factory_set_download_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_image_resources_dir(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_image_resources_dir(IntPtr thiz, string path);

		/// <summary>
		/// Get the directory where the image resources are located. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to the directory where the image resources are located   
		/// </returns>
		public string ImageResourcesDir
		{
			get
			{
				IntPtr stringPtr = linphone_factory_get_image_resources_dir(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_factory_set_image_resources_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_factory_is_cache_dir_set(IntPtr thiz);

		/// <summary>
		/// Test if cache dir has been set. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if cache dir has been set. </returns>
		public bool IsCacheDirSet
		{
			get
			{
				return linphone_factory_is_cache_dir_set(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_factory_is_config_dir_set(IntPtr thiz);

		/// <summary>
		/// Test if config dir has been set. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if config dir has been set. </returns>
		public bool IsConfigDirSet
		{
			get
			{
				return linphone_factory_is_config_dir_set(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_factory_is_data_dir_set(IntPtr thiz);

		/// <summary>
		/// Test if data dir has been set. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if data dir has been set. </returns>
		public bool IsDataDirSet
		{
			get
			{
				return linphone_factory_is_data_dir_set(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_factory_is_database_storage_available(IntPtr thiz);

		/// <summary>
		/// Indicates if the storage in database is available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the database storage is available, false otherwise </returns>
		public bool IsDatabaseStorageAvailable
		{
			get
			{
				return linphone_factory_is_database_storage_available(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_factory_is_download_dir_set(IntPtr thiz);

		/// <summary>
		/// Test if download dir has been set. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if download dir has been set. </returns>
		public bool IsDownloadDirSet
		{
			get
			{
				return linphone_factory_is_download_dir_set(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_factory_is_imdn_available(IntPtr thiz);

		/// <summary>
		/// Indicates if IMDN are available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if IDMN are available </returns>
		public bool IsImdnAvailable
		{
			get
			{
				return linphone_factory_is_imdn_available(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_factory_is_qrcode_available(IntPtr thiz);

		/// <summary>
		/// Indicates if the QRCode feature is available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if QRCodes can be used </returns>
		public bool IsQrcodeAvailable
		{
			get
			{
				return linphone_factory_is_qrcode_available(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_liblinphone_plugins_dir(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_liblinphone_plugins_dir(IntPtr thiz, string path);

		/// <summary>
		/// Get the directory where the liblinphone plugins are located. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to the directory where the liblinphone plugins are located,
		/// or null if it has not been set.    </returns>
		public string LiblinphonePluginsDir
		{
			get
			{
				IntPtr stringPtr = linphone_factory_get_liblinphone_plugins_dir(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_factory_set_liblinphone_plugins_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_log_collection_path(IntPtr thiz, string path);

		/// <summary>
		/// Sets the log collection path. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="path">the path of the logs    </param>
		public string LogCollectionPath
		{
			set
			{
				linphone_factory_set_log_collection_path(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_msplugins_dir(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_msplugins_dir(IntPtr thiz, string path);

		/// <summary>
		/// Get the directory where the mediastreamer2 plugins are located. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to the directory where the mediastreamer2 plugins are
		/// located, or null if it has not been set.    </returns>
		public string MspluginsDir
		{
			get
			{
				IntPtr stringPtr = linphone_factory_get_msplugins_dir(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_factory_set_msplugins_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_recommended_video_definitions(IntPtr thiz);

		/// <summary>
		/// Get the recommended list of standard video definitions. 
		/// <para>
		/// This list is suitable for a widest set of hardware for all video codec
		/// implementations, and thus excludes some very high definition formats that are
		/// unlikely to work unless specific hardware or codecs are used. 
		/// </para>
		/// </summary>
		/// <returns>A list of video definitions.      </returns>
		public IEnumerable<Linphone.VideoDefinition> RecommendedVideoDefinitions
		{
			get
			{
				return MarshalBctbxList<Linphone.VideoDefinition>(linphone_factory_get_recommended_video_definitions(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_ring_resources_dir(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_ring_resources_dir(IntPtr thiz, string path);

		/// <summary>
		/// Get the directory where the ring resources are located. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to the directory where the ring resources are located   
		/// </returns>
		public string RingResourcesDir
		{
			get
			{
				IntPtr stringPtr = linphone_factory_get_ring_resources_dir(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_factory_set_ring_resources_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_sound_resources_dir(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_sound_resources_dir(IntPtr thiz, string path);

		/// <summary>
		/// Get the directory where the sound resources are located. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to the directory where the sound resources are located   
		/// </returns>
		public string SoundResourcesDir
		{
			get
			{
				IntPtr stringPtr = linphone_factory_get_sound_resources_dir(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_factory_set_sound_resources_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_supported_video_definitions(IntPtr thiz);

		/// <summary>
		/// Get the list of standard video definitions supported by Linphone. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of video definitions.      </returns>
		public IEnumerable<Linphone.VideoDefinition> SupportedVideoDefinitions
		{
			get
			{
				return MarshalBctbxList<Linphone.VideoDefinition>(linphone_factory_get_supported_video_definitions(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_top_resources_dir(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_set_top_resources_dir(IntPtr thiz, string path);

		/// <summary>
		/// Get the top directory where the resources are located. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The path to the top directory where the resources are located   
		/// </returns>
		public string TopResourcesDir
		{
			get
			{
				IntPtr stringPtr = linphone_factory_get_top_resources_dir(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_factory_set_top_resources_dir(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_compute_ha1_for_algorithm(IntPtr thiz, string userid, string password, string realm, string algorithm);

		/// <summary>
		/// Computes the hashed version of the password given the user ID and the realm,
		/// using given algorithm. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="userid">the username or user ID to use.    </param>
		/// <param name="password">the password to hash.    </param>
		/// <param name="realm">the real to use.    </param>
		/// <param name="algorithm">the algorithm to use (MD5 or SHA-256).    </param>
		/// <returns>the generated hash if it succeeded, null otherwise.       </returns>
		public string ComputeHa1ForAlgorithm(string userid, string password, string realm, string algorithm)
		{
			IntPtr stringPtr = linphone_factory_compute_ha1_for_algorithm(nativePtr, userid, password, realm, algorithm);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_address(IntPtr thiz, string addr);

		/// <summary>
		/// Parse a string holding a SIP URI and create the according <see cref="Linphone.Address">
		/// Linphone.Address</see> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="addr">A string holding the SIP URI to parse.    </param>
		/// <returns>A new <see cref="Linphone.Address">Linphone.Address</see>.   
		/// </returns>
		public Linphone.Address CreateAddress(string addr)
		{
			IntPtr ptr = linphone_factory_create_address(nativePtr, addr);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_auth_info(IntPtr thiz, string username, string userid, string passwd, string ha1, string realm, string domain);

		/// <summary>
		/// Creates a <see cref="Linphone.AuthInfo">Linphone.AuthInfo</see> object. 
		/// <para>
		/// The object can be created empty, that is with all arguments set to null.
		/// Username, userid, password, realm and domain can be set later using specific
		/// methods. At the end, username and passwd (or ha1) are required. 
		/// </para>
		/// </summary>
		/// <param name="username">The username that needs to be authenticated    </param>
		/// <param name="userid">The userid used for authenticating (use null if you
		/// don&apos;t know what it is)    </param>
		/// <param name="passwd">The password in clear text    </param>
		/// <param name="ha1">The ha1-encrypted password if password is not given in clear
		/// text.    </param>
		/// <param name="realm">The authentication domain (which can be larger than the sip
		/// domain. Unfortunately many SIP servers don&apos;t use this parameter.   
		/// </param>
		/// <param name="domain">The SIP domain for which this authentication information
		/// is valid, if it has to be restricted for a single SIP domain.    </param>
		/// <returns>A <see cref="Linphone.AuthInfo">Linphone.AuthInfo</see> object.
		/// linphone_auth_info_destroy must be used to destroy it when no longer needed.
		/// The <see cref="Linphone.Core">Linphone.Core</see> makes a copy of <see cref="Linphone.AuthInfo">
		/// Linphone.AuthInfo</see> passed through <see cref="Linphone.Core.AddAuthInfo()">
		/// Linphone.Core.AddAuthInfo()</see>.    </returns>
		public Linphone.AuthInfo CreateAuthInfo(string username, string userid, string passwd, string ha1, string realm, string domain)
		{
			IntPtr ptr = linphone_factory_create_auth_info(nativePtr, username, userid, passwd, ha1, realm, domain);
			Linphone.AuthInfo returnVal = fromNativePtr<Linphone.AuthInfo>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_auth_info_2(IntPtr thiz, string username, string userid, string passwd, string ha1, string realm, string domain, string algorithm);

		/// <summary>
		/// Creates a <see cref="Linphone.AuthInfo">Linphone.AuthInfo</see> object. 
		/// <para>
		/// The object can be created empty, that is with all arguments set to null.
		/// Username, userid, password, realm and domain can be set later using specific
		/// methods. At the end, username and passwd (or ha1) are required. 
		/// </para>
		/// </summary>
		/// <param name="username">The username that needs to be authenticated    </param>
		/// <param name="userid">The userid used for authenticating (use null if you
		/// don&apos;t know what it is)    </param>
		/// <param name="passwd">The password in clear text    </param>
		/// <param name="ha1">The ha1-encrypted password if password is not given in clear
		/// text.    </param>
		/// <param name="realm">The authentication domain (which can be larger than the sip
		/// domain. Unfortunately many SIP servers don&apos;t use this parameter.   
		/// </param>
		/// <param name="domain">The SIP domain for which this authentication information
		/// is valid, if it has to be restricted for a single SIP domain.    </param>
		/// <param name="algorithm">The algorithm for encrypting password.    </param>
		/// <returns>A <see cref="Linphone.AuthInfo">Linphone.AuthInfo</see> object.
		/// linphone_auth_info_destroy must be used to destroy it when no longer needed.
		/// The <see cref="Linphone.Core">Linphone.Core</see> makes a copy of <see cref="Linphone.AuthInfo">
		/// Linphone.AuthInfo</see> passed through <see cref="Linphone.Core.AddAuthInfo()">
		/// Linphone.Core.AddAuthInfo()</see>.    </returns>
		public Linphone.AuthInfo CreateAuthInfo(string username, string userid, string passwd, string ha1, string realm, string domain, string algorithm)
		{
			IntPtr ptr = linphone_factory_create_auth_info_2(nativePtr, username, userid, passwd, ha1, realm, domain, algorithm);
			Linphone.AuthInfo returnVal = fromNativePtr<Linphone.AuthInfo>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_buffer(IntPtr thiz);

		/// <summary>
		/// Creates an object <see cref="Linphone.Buffer">Linphone.Buffer</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Buffer">Linphone.Buffer</see>    </returns>
		public Linphone.Buffer CreateBuffer()
		{
			IntPtr ptr = linphone_factory_create_buffer(nativePtr);
			Linphone.Buffer returnVal = fromNativePtr<Linphone.Buffer>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_buffer_from_data(IntPtr thiz, uint data, long size);

		/// <summary>
		/// Creates an object <see cref="Linphone.Buffer">Linphone.Buffer</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="data">the data to set in the buffer    </param>
		/// <param name="size">the size of the data </param>
		/// <returns>a <see cref="Linphone.Buffer">Linphone.Buffer</see>    </returns>
		public Linphone.Buffer CreateBufferFromData(uint data, long size)
		{
			IntPtr ptr = linphone_factory_create_buffer_from_data(nativePtr, data, size);
			Linphone.Buffer returnVal = fromNativePtr<Linphone.Buffer>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_buffer_from_string(IntPtr thiz, string data);

		/// <summary>
		/// Creates an object <see cref="Linphone.Buffer">Linphone.Buffer</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="data">the data to set in the buffer    </param>
		/// <returns>a <see cref="Linphone.Buffer">Linphone.Buffer</see>    </returns>
		public Linphone.Buffer CreateBufferFromString(string data)
		{
			IntPtr ptr = linphone_factory_create_buffer_from_string(nativePtr, data);
			Linphone.Buffer returnVal = fromNativePtr<Linphone.Buffer>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_conference_info(IntPtr thiz);

		/// <summary>
		/// Creates an object <see cref="Linphone.ConferenceInfo">
		/// Linphone.ConferenceInfo</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.ConferenceInfo">Linphone.ConferenceInfo</see>   
		/// </returns>
		public Linphone.ConferenceInfo CreateConferenceInfo()
		{
			IntPtr ptr = linphone_factory_create_conference_info(nativePtr);
			Linphone.ConferenceInfo returnVal = fromNativePtr<Linphone.ConferenceInfo>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_conference_info_from_icalendar_content(IntPtr thiz, IntPtr content);

		/// <summary>
		/// Creates an object <see cref="Linphone.ConferenceInfo">
		/// Linphone.ConferenceInfo</see> from an Icalendar <see cref="Linphone.Content">
		/// Linphone.Content</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="content">the Icalendar <see cref="Linphone.Content">
		/// Linphone.Content</see>    </param>
		/// <returns>a <see cref="Linphone.ConferenceInfo">Linphone.ConferenceInfo</see>
		/// created from an Icalendar <see cref="Linphone.Content">Linphone.Content</see>  
		///  </returns>
		public Linphone.ConferenceInfo CreateConferenceInfoFromIcalendarContent(Linphone.Content content)
		{
			IntPtr ptr = linphone_factory_create_conference_info_from_icalendar_content(nativePtr, content != null ? content.nativePtr : IntPtr.Zero);
			Linphone.ConferenceInfo returnVal = fromNativePtr<Linphone.ConferenceInfo>(ptr, false);
			
			GC.KeepAlive(content);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_config(IntPtr thiz, string path);

		/// <summary>
		/// Creates an object <see cref="Linphone.Config">Linphone.Config</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="path">the path of the config    </param>
		/// <returns>a <see cref="Linphone.Config">Linphone.Config</see>    </returns>
		public Linphone.Config CreateConfig(string path)
		{
			IntPtr ptr = linphone_factory_create_config(nativePtr, path);
			Linphone.Config returnVal = fromNativePtr<Linphone.Config>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_config_from_string(IntPtr thiz, string data);

		/// <summary>
		/// Creates an object <see cref="Linphone.Config">Linphone.Config</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="data">the config data    </param>
		/// <returns>a <see cref="Linphone.Config">Linphone.Config</see>    </returns>
		public Linphone.Config CreateConfigFromString(string data)
		{
			IntPtr ptr = linphone_factory_create_config_from_string(nativePtr, data);
			Linphone.Config returnVal = fromNativePtr<Linphone.Config>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_config_with_factory(IntPtr thiz, string path, string factoryPath);

		/// <summary>
		/// Creates an object <see cref="Linphone.Config">Linphone.Config</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="path">the path of the config    </param>
		/// <param name="factoryPath">the path of the factory    </param>
		/// <returns>a <see cref="Linphone.Config">Linphone.Config</see>    </returns>
		public Linphone.Config CreateConfigWithFactory(string path, string factoryPath)
		{
			IntPtr ptr = linphone_factory_create_config_with_factory(nativePtr, path, factoryPath);
			Linphone.Config returnVal = fromNativePtr<Linphone.Config>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_content(IntPtr thiz);

		/// <summary>
		/// Creates an object <see cref="Linphone.Content">Linphone.Content</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Content">Linphone.Content</see>    </returns>
		public Linphone.Content CreateContent()
		{
			IntPtr ptr = linphone_factory_create_content(nativePtr);
			Linphone.Content returnVal = fromNativePtr<Linphone.Content>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_content_from_file(IntPtr thiz, string filePath);

		/// <summary>
		/// Creates a file object of <see cref="Linphone.Content">Linphone.Content</see>
		/// from a file path. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filePath">the path of the file    </param>
		/// <returns>a <see cref="Linphone.Content">Linphone.Content</see> which can be
		/// used as a file    </returns>
		public Linphone.Content CreateContentFromFile(string filePath)
		{
			IntPtr ptr = linphone_factory_create_content_from_file(nativePtr, filePath);
			Linphone.Content returnVal = fromNativePtr<Linphone.Content>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_core_3(IntPtr thiz, string configPath, string factoryConfigPath, IntPtr systemContext);

		/// <summary>
		/// Instantiate a <see cref="Linphone.Core">Linphone.Core</see> object. 
		/// <para>
		/// The <see cref="Linphone.Core">Linphone.Core</see> object is the primary handle
		/// for doing all phone actions. It should be unique within your application. The
		/// <see cref="Linphone.Core">Linphone.Core</see> object is not started
		/// automatically, you need to call <see cref="Linphone.Core.Start()">
		/// Linphone.Core.Start()</see> to that effect. The returned <see cref="Linphone.Core">
		/// Linphone.Core</see> will be in <see cref="Linphone.GlobalState">
		/// Linphone.GlobalState</see> Ready. Core ressources can be released using <see cref="Linphone.Core.Stop()">
		/// Linphone.Core.Stop()</see> which is strongly encouraged on garbage collected
		/// languages. 
		/// </para>
		/// </summary>
		/// <param name="configPath">A path to a config file. If it does not exists it will
		/// be created. The config file is used to store all settings, proxies... so that
		/// all these settings become persistent over the life of the <see cref="Linphone.Core">
		/// Linphone.Core</see> object. It is allowed to set a null config file. In that
		/// case <see cref="Linphone.Core">Linphone.Core</see> will not store any settings.
		///    </param>
		/// <param name="factoryConfigPath">A path to a read-only config file that can be
		/// used to store hard-coded preferences such as proxy settings or internal
		/// preferences. The settings in this factory file always override the ones in the
		/// normal config file. It is optional, use null if unneeded.    </param>
		/// <param name="systemContext">A pointer to a system object required by the core
		/// to operate. Currently it is required to pass an android Context on android,
		/// pass null on other platforms.    </param>
		/// <returns>a <see cref="Linphone.Core">Linphone.Core</see> object    </returns>
		/// <remarks>See : linphone_core_new_with_config_3() </remarks>
		public Linphone.Core CreateCore(string configPath, string factoryConfigPath, IntPtr systemContext)
		{
			IntPtr ptr = linphone_factory_create_core_3(nativePtr, configPath, factoryConfigPath, systemContext);
			Linphone.Core returnVal = fromNativePtr<Linphone.Core>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_core_with_config_3(IntPtr thiz, IntPtr config, IntPtr systemContext);

		/// <summary>
		/// Instantiate a <see cref="Linphone.Core">Linphone.Core</see> object with a given
		/// LinphoneConfig. 
		/// <para>
		/// The <see cref="Linphone.Core">Linphone.Core</see> object is the primary handle
		/// for doing all phone actions. It should be unique within your application. The
		/// <see cref="Linphone.Core">Linphone.Core</see> object is not started
		/// automatically, you need to call <see cref="Linphone.Core.Start()">
		/// Linphone.Core.Start()</see> to that effect. The returned <see cref="Linphone.Core">
		/// Linphone.Core</see> will be in <see cref="Linphone.GlobalState">
		/// Linphone.GlobalState</see> Ready. Core ressources can be released using <see cref="Linphone.Core.Stop()">
		/// Linphone.Core.Stop()</see> which is strongly encouraged on garbage collected
		/// languages. 
		/// </para>
		/// </summary>
		/// <param name="config">A <see cref="Linphone.Config">Linphone.Config</see> object
		/// holding the configuration for the <see cref="Linphone.Core">Linphone.Core</see>
		/// to be instantiated.    </param>
		/// <param name="systemContext">A pointer to a system object required by the core
		/// to operate. Currently it is required to pass an android Context on android,
		/// pass null on other platforms.    </param>
		/// <returns>a <see cref="Linphone.Core">Linphone.Core</see> object    </returns>
		/// <remarks>See : <see cref="Linphone.Factory.CreateCore()">
		/// Linphone.Factory.CreateCore()</see> </remarks>
		public Linphone.Core CreateCoreWithConfig(Linphone.Config config, IntPtr systemContext)
		{
			IntPtr ptr = linphone_factory_create_core_with_config_3(nativePtr, config != null ? config.nativePtr : IntPtr.Zero, systemContext);
			Linphone.Core returnVal = fromNativePtr<Linphone.Core>(ptr, false);
			
			GC.KeepAlive(config);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_digest_authentication_policy(IntPtr thiz);

		/// <summary>
		/// Create a <see cref="Linphone.DigestAuthenticationPolicy">
		/// Linphone.DigestAuthenticationPolicy</see> object. 
		/// <para>
		/// The <see cref="Linphone.DigestAuthenticationPolicy">
		/// Linphone.DigestAuthenticationPolicy</see> object which is used to configure a
		/// policy for digest authentication, such as allowing MD5 or mode without
		/// qop=auth. 
		/// </para>
		/// </summary>
		/// <returns>a new <see cref="Linphone.DigestAuthenticationPolicy">
		/// Linphone.DigestAuthenticationPolicy</see> .    </returns>
		public Linphone.DigestAuthenticationPolicy CreateDigestAuthenticationPolicy()
		{
			IntPtr ptr = linphone_factory_create_digest_authentication_policy(nativePtr);
			Linphone.DigestAuthenticationPolicy returnVal = fromNativePtr<Linphone.DigestAuthenticationPolicy>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_error_info(IntPtr thiz);

		/// <summary>
		/// Creates an object LinphoneErrorInfo. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.ErrorInfo">Linphone.ErrorInfo</see> object.   
		/// </returns>
		public Linphone.ErrorInfo CreateErrorInfo()
		{
			IntPtr ptr = linphone_factory_create_error_info(nativePtr);
			Linphone.ErrorInfo returnVal = fromNativePtr<Linphone.ErrorInfo>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_friend_phone_number(IntPtr thiz, string phoneNumber, string label);

		/// <summary>
		/// Creates a new <see cref="Linphone.FriendPhoneNumber">
		/// Linphone.FriendPhoneNumber</see> objects. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">The phone number.    </param>
		/// <param name="label">the type of phone number, for example &quot;home&quot;,
		/// &quot;cell&quot;, etc. Use null or empty for no label.    </param>
		/// <returns>The newly created <see cref="Linphone.FriendPhoneNumber">
		/// Linphone.FriendPhoneNumber</see> object.    </returns>
		public Linphone.FriendPhoneNumber CreateFriendPhoneNumber(string phoneNumber, string label)
		{
			IntPtr ptr = linphone_factory_create_friend_phone_number(nativePtr, phoneNumber, label);
			Linphone.FriendPhoneNumber returnVal = fromNativePtr<Linphone.FriendPhoneNumber>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_participant_device_identity(IntPtr thiz, IntPtr address, string name);

		/// <summary>
		/// Create a <see cref="Linphone.ParticipantDeviceIdentity">
		/// Linphone.ParticipantDeviceIdentity</see> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address"><see cref="Linphone.Address">Linphone.Address</see>
		/// object.    </param>
		/// <param name="name">the name given to the device.    </param>
		/// <returns>A new <see cref="Linphone.ParticipantDeviceIdentity">
		/// Linphone.ParticipantDeviceIdentity</see>.    </returns>
		public Linphone.ParticipantDeviceIdentity CreateParticipantDeviceIdentity(Linphone.Address address, string name)
		{
			IntPtr ptr = linphone_factory_create_participant_device_identity(nativePtr, address != null ? address.nativePtr : IntPtr.Zero, name);
			Linphone.ParticipantDeviceIdentity returnVal = fromNativePtr<Linphone.ParticipantDeviceIdentity>(ptr, false);
			
			GC.KeepAlive(address);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_participant_info(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Creates an object <see cref="Linphone.ConferenceInfo">
		/// Linphone.ConferenceInfo</see> from an Icalendar <see cref="Linphone.Content">
		/// Linphone.Content</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address">the <see cref="Linphone.Address">Linphone.Address</see>
		/// of the participant    </param>
		/// <returns>a <see cref="Linphone.ParticipantInfo">Linphone.ParticipantInfo</see> 
		///   </returns>
		public Linphone.ParticipantInfo CreateParticipantInfo(Linphone.Address address)
		{
			IntPtr ptr = linphone_factory_create_participant_info(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			Linphone.ParticipantInfo returnVal = fromNativePtr<Linphone.ParticipantInfo>(ptr, false);
			
			GC.KeepAlive(address);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_qrcode(IntPtr thiz, string code, uint width, uint height, uint margin);

		/// <summary>
		/// Creates a Bitmap QRCode and return it into an object <see cref="Linphone.Content">
		/// Linphone.Content</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="code">The code to be generated into an image. It must not be
		/// empty.    </param>
		/// <param name="width">The requested width of the QRCode image. It will be 100 if
		/// 0. </param>
		/// <param name="height">The requested height of the QRCode image. It will be 100
		/// if 0. </param>
		/// <param name="margin">The requested margin of the QRCode image. </param>
		/// <returns>a <see cref="Linphone.Content">Linphone.Content</see>    </returns>
		public Linphone.Content CreateQrcode(string code, uint width, uint height, uint margin)
		{
			IntPtr ptr = linphone_factory_create_qrcode(nativePtr, code, width, height, margin);
			Linphone.Content returnVal = fromNativePtr<Linphone.Content>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_range(IntPtr thiz);

		/// <summary>
		/// Creates an object LinphoneRange. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Range">Linphone.Range</see> object.    </returns>
		public Linphone.Range CreateRange()
		{
			IntPtr ptr = linphone_factory_create_range(nativePtr);
			Linphone.Range returnVal = fromNativePtr<Linphone.Range>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_signal_information(IntPtr thiz);

		/// <summary>
		/// Creates an object <see cref="Linphone.SignalInformation">
		/// Linphone.SignalInformation</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.SignalInformation">
		/// Linphone.SignalInformation</see>    </returns>
		public Linphone.SignalInformation CreateSignalInformation()
		{
			IntPtr ptr = linphone_factory_create_signal_information(nativePtr);
			Linphone.SignalInformation returnVal = fromNativePtr<Linphone.SignalInformation>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_transports(IntPtr thiz);

		/// <summary>
		/// Creates an object LinphoneTransports. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Transports">Linphone.Transports</see> object.   
		/// </returns>
		public Linphone.Transports CreateTransports()
		{
			IntPtr ptr = linphone_factory_create_transports(nativePtr);
			Linphone.Transports returnVal = fromNativePtr<Linphone.Transports>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_tunnel_config(IntPtr thiz);

		/// <summary>
		/// Creates an object <see cref="Linphone.TunnelConfig">
		/// Linphone.TunnelConfig</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.TunnelConfig">Linphone.TunnelConfig</see>   
		/// </returns>
		public Linphone.TunnelConfig CreateTunnelConfig()
		{
			IntPtr ptr = linphone_factory_create_tunnel_config(nativePtr);
			Linphone.TunnelConfig returnVal = fromNativePtr<Linphone.TunnelConfig>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_vcard(IntPtr thiz);

		/// <summary>
		/// Create an empty <see cref="Linphone.Vcard">Linphone.Vcard</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a new <see cref="Linphone.Vcard">Linphone.Vcard</see>.    </returns>
		public Linphone.Vcard CreateVcard()
		{
			IntPtr ptr = linphone_factory_create_vcard(nativePtr);
			Linphone.Vcard returnVal = fromNativePtr<Linphone.Vcard>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_video_activation_policy(IntPtr thiz);

		/// <summary>
		/// Creates an object LinphoneVideoActivationPolicy. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.VideoActivationPolicy">
		/// Linphone.VideoActivationPolicy</see> object.    </returns>
		public Linphone.VideoActivationPolicy CreateVideoActivationPolicy()
		{
			IntPtr ptr = linphone_factory_create_video_activation_policy(nativePtr);
			Linphone.VideoActivationPolicy returnVal = fromNativePtr<Linphone.VideoActivationPolicy>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_video_definition(IntPtr thiz, uint width, uint height);

		/// <summary>
		/// Create a <see cref="Linphone.VideoDefinition">Linphone.VideoDefinition</see>
		/// from a given width and height. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="width">The width of the created video definition </param>
		/// <param name="height">The height of the created video definition </param>
		/// <returns>A new <see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see> object    </returns>
		public Linphone.VideoDefinition CreateVideoDefinition(uint width, uint height)
		{
			IntPtr ptr = linphone_factory_create_video_definition(nativePtr, width, height);
			Linphone.VideoDefinition returnVal = fromNativePtr<Linphone.VideoDefinition>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_video_definition_from_name(IntPtr thiz, string name);

		/// <summary>
		/// Create a <see cref="Linphone.VideoDefinition">Linphone.VideoDefinition</see>
		/// from a given standard definition name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">The standard definition name of the video definition to
		/// create    </param>
		/// <returns>A new <see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see> object    </returns>
		public Linphone.VideoDefinition CreateVideoDefinitionFromName(string name)
		{
			IntPtr ptr = linphone_factory_create_video_definition_from_name(nativePtr, name);
			Linphone.VideoDefinition returnVal = fromNativePtr<Linphone.VideoDefinition>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_video_source_descriptor(IntPtr thiz);

		/// <summary>
		/// Creates an object <see cref="Linphone.VideoSourceDescriptor">
		/// Linphone.VideoSourceDescriptor</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.VideoSourceDescriptor">
		/// Linphone.VideoSourceDescriptor</see>    </returns>
		public Linphone.VideoSourceDescriptor CreateVideoSourceDescriptor()
		{
			IntPtr ptr = linphone_factory_create_video_source_descriptor(nativePtr);
			Linphone.VideoSourceDescriptor returnVal = fromNativePtr<Linphone.VideoSourceDescriptor>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_factory_enable_log_collection(IntPtr thiz, int state);

		/// <summary>
		/// Enables or disables log collection. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="state">the <see cref="Linphone.LogCollectionState">
		/// Linphone.LogCollectionState</see> for log collection </param>
		public void EnableLogCollection(Linphone.LogCollectionState state)
		{
			linphone_factory_enable_log_collection(nativePtr, (int)state);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_cache_dir(IntPtr thiz, IntPtr context);

		/// <summary>
		/// Get the cache path. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="context">used to compute path. Can be null. JavaPlatformHelper on
		/// Android and char *appGroupId on iOS with shared core.    </param>
		/// <returns>The cache path    </returns>
		public string GetCacheDir(IntPtr context)
		{
			IntPtr stringPtr = linphone_factory_get_cache_dir(nativePtr, context);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_config_dir(IntPtr thiz, IntPtr context);

		/// <summary>
		/// Get the config path. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="context">used to compute path. Can be null. JavaPlatformHelper on
		/// Android and char *appGroupId on iOS with shared core.    </param>
		/// <returns>The config path    </returns>
		public string GetConfigDir(IntPtr context)
		{
			IntPtr stringPtr = linphone_factory_get_config_dir(nativePtr, context);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_data_dir(IntPtr thiz, IntPtr context);

		/// <summary>
		/// Get the data path. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="context">used to compute path. Can be null. JavaPlatformHelper on
		/// Android and char *appGroupId on iOS with shared core.    </param>
		/// <returns>The data path    </returns>
		public string GetDataDir(IntPtr context)
		{
			IntPtr stringPtr = linphone_factory_get_data_dir(nativePtr, context);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get_download_dir(IntPtr thiz, IntPtr context);

		/// <summary>
		/// Get the download path. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="context">used to compute path. Can be null. JavaPlatformHelper on
		/// Android and char *appGroupId on iOS with shared core.    </param>
		/// <returns>The download path    </returns>
		public string GetDownloadDir(IntPtr context)
		{
			IntPtr stringPtr = linphone_factory_get_download_dir(nativePtr, context);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_factory_is_chatroom_backend_available(IntPtr thiz, int chatroomBackend);

		/// <summary>
		/// Indicates if the given LinphoneChatRoomBackend is available. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="chatroomBackend">the <see cref="Linphone.ChatRoomBackend">
		/// Linphone.ChatRoomBackend</see> </param>
		/// <returns>true if the chatroom backend is available, false otherwise </returns>
		public bool IsChatroomBackendAvailable(Linphone.ChatRoomBackend chatroomBackend)
		{
			bool returnVal = linphone_factory_is_chatroom_backend_available(nativePtr, (int)chatroomBackend) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_factory_set_vfs_encryption(IntPtr thiz, uint encryptionModule, uint secret, long secretSize);

		/// <summary>
		/// Select encryption module and set secret material to encrypt the files. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="encryptionModule">One of the available encryption module for VFS,
		/// pick in the LINPHONE_VFS_ENCRYPTION_* list if set to _UNSET, default bctoolbox
		/// VFS is switch to Standard one </param>
		/// <param name="secret">the secret material used to encrypt the files, can be null
		/// for the _PLAIN module    </param>
		/// <param name="secretSize">size of the secret</param>
		/// <returns>true if everything went well, false if it appears that the given
		/// secret is unable to decrypt existing configuration </returns>
		public bool SetVfsEncryption(uint encryptionModule, uint secret, long secretSize)
		{
			bool returnVal = linphone_factory_set_vfs_encryption(nativePtr, encryptionModule, secret, secretSize) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_factory_write_qrcode_file(IntPtr thiz, string filePath, string code, uint width, uint height, uint margin);

		/// <summary>
		/// Creates a QRCode and write it into a JPEG file specified by file_path (only if
		/// build with JPEG). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filePath">The file where to write the QRCode JPEG image.   
		/// </param>
		/// <param name="code">The code to be generated into an image. It must not be
		/// empty.    </param>
		/// <param name="width">The requested width of the QRCode image. It will be 100 if
		/// 0. </param>
		/// <param name="height">The requested height of the QRCode image. It will be 100
		/// if 0. </param>
		/// <param name="margin">The requested margin of the QRCode image. </param>
		/// <returns>0 if successful, -2 if JPEG is not supported, -1 otherwise </returns>
		public int WriteQrcodeFile(string filePath, string code, uint width, uint height, uint margin)
		{
			int returnVal = linphone_factory_write_qrcode_file(nativePtr, filePath, code, width, height, margin);
			
			
						return returnVal;
		}
	}
	/// <summary>
	/// This object is used to store a SIP address. 
	/// <para>
	/// <see cref="Linphone.Friend">Linphone.Friend</see> is mainly used to implement
	/// an adressbook feature, and are used as data for the <see cref="Linphone.MagicSearch">
	/// Linphone.MagicSearch</see> object. If your proxy supports it, you can also use
	/// it to subscribe to presence information.
	/// The objects are stored in a <see cref="Linphone.FriendList">
	/// Linphone.FriendList</see> which are in turn stored inside the <see cref="Linphone.Core">
	/// Linphone.Core</see>. They can be stored inside a database if the path to it is
	/// configured, otherwise they will be lost after the <see cref="Linphone.Core">
	/// Linphone.Core</see> is destroyed.
	/// Thanks to the vCard plugin, you can also store more information like phone
	/// numbers, organization, etc... 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Friend : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_friend_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private FriendListener listener;

		public FriendListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_friend_cbs(linphone_factory_get());
					listener = fromNativePtr<FriendListener>(nativeListener, false, true);
					linphone_friend_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_friend_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_new_from_vcard(IntPtr vcard);

		/// <summary>
		/// Contructor same as linphone_friend_new + <see cref="Linphone.Friend.Address">
		/// Linphone.Friend.Address</see> 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="vcard">a <see cref="Linphone.Vcard">Linphone.Vcard</see> object   
		/// </param>
		/// <returns>a new <see cref="Linphone.Friend">Linphone.Friend</see> which has its
		/// vCard attribute initialized from the given vCard. This can be get by <see cref="Linphone.Friend.Vcard">
		/// Linphone.Friend.Vcard</see>.    </returns>
		public static Linphone.Friend NewFromVcard(Linphone.Vcard vcard)
		{
			IntPtr ptr = linphone_friend_new_from_vcard(vcard != null ? vcard.nativePtr : IntPtr.Zero);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, false);
			
			GC.KeepAlive(vcard);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_set_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Get address of this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Note : the <see cref="Linphone.Address">Linphone.Address</see> object
		/// returned is hold by the LinphoneFriend, however calling several time this
		/// function may return different objects. </remarks>
		/// <returns>the <see cref="Linphone.Address">Linphone.Address</see>.    </returns>
		public Linphone.Address Address
		{
			get
			{
				IntPtr ptr = linphone_friend_get_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				int exception_result = linphone_friend_set_address(nativePtr, value.nativePtr);
				if (exception_result != 0) throw new LinphoneException("Address setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_addresses(IntPtr thiz);

		/// <summary>
		/// Returns a list of <see cref="Linphone.Address">Linphone.Address</see> for this
		/// friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of <see cref="Linphone.Address">Linphone.Address</see>.     
		/// </returns>
		public IEnumerable<Linphone.Address> Addresses
		{
			get
			{
				return MarshalBctbxList<Linphone.Address>(linphone_friend_get_addresses(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_get_capabilities(IntPtr thiz);

		/// <summary>
		/// Returns the capabilities associated to this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>an int representing the capabilities of the friend </returns>
		public int Capabilities
		{
			get
			{
				return linphone_friend_get_capabilities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConsolidatedPresence linphone_friend_get_consolidated_presence(IntPtr thiz);

		/// <summary>
		/// Get the consolidated presence of a friend. 
		/// <para>
		/// It will return the &quot;most open&quot; presence found if more than one
		/// presence model are found. 
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.ConsolidatedPresence">
		/// Linphone.ConsolidatedPresence</see> of the friend </returns>
		public Linphone.ConsolidatedPresence ConsolidatedPresence
		{
			get
			{
				return linphone_friend_get_consolidated_presence(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_core(IntPtr thiz);

		/// <summary>
		/// Returns the <see cref="Linphone.Core">Linphone.Core</see> object managing this
		/// friend, if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Core">Linphone.Core</see> object associated.  
		///  </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_friend_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SubscribePolicy linphone_friend_get_inc_subscribe_policy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_set_inc_subscribe_policy(IntPtr thiz, int policy);

		/// <summary>
		/// get current subscription policy for this <see cref="Linphone.Friend">
		/// Linphone.Friend</see> 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.SubscribePolicy">
		/// Linphone.SubscribePolicy</see> enum </returns>
		public Linphone.SubscribePolicy IncSubscribePolicy
		{
			get
			{
				return linphone_friend_get_inc_subscribe_policy(nativePtr);
			}
			set
			{
				int exception_result = linphone_friend_set_inc_subscribe_policy(nativePtr, (int)value);
				if (exception_result != 0) throw new LinphoneException("IncSubscribePolicy setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_is_presence_received(IntPtr thiz);

		/// <summary>
		/// Tells whether we already received presence information for a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if presence information has been received for the friend, false
		/// otherwise. </returns>
		public bool IsPresenceReceived
		{
			get
			{
				return linphone_friend_is_presence_received(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_job_title(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_set_job_title(IntPtr thiz, string jobTitle);

		/// <summary>
		/// Gets the contact&apos;s job title from it&apos;s vCard. 
		/// <para>
		/// It&apos;s a shortcut to <see cref="Linphone.Friend.Vcard">
		/// Linphone.Friend.Vcard</see> and <see cref="Linphone.Vcard.JobTitle">
		/// Linphone.Vcard.JobTitle</see>. 
		/// </para>
		/// </summary>
		/// <returns>the job_title set if any &amp; vCard is available, null otherwise.   
		/// </returns>
		public string JobTitle
		{
			get
			{
				IntPtr stringPtr = linphone_friend_get_job_title(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_set_job_title(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_set_name(IntPtr thiz, string name);

		/// <summary>
		/// Get the display name for this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The display name of this friend.    </returns>
		public string Name
		{
			get
			{
				IntPtr stringPtr = linphone_friend_get_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_friend_set_name(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Name setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_native_uri(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_set_native_uri(IntPtr thiz, string nativeUri);

		/// <summary>
		/// Gets the contact&apos;s native URI. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the native URI set if any, null otherwise.    </returns>
		public string NativeUri
		{
			get
			{
				IntPtr stringPtr = linphone_friend_get_native_uri(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_set_native_uri(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_organization(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_set_organization(IntPtr thiz, string organization);

		/// <summary>
		/// Gets the contact&apos;s organization from it&apos;s vCard. 
		/// <para>
		/// It&apos;s a shortcut to <see cref="Linphone.Friend.Vcard">
		/// Linphone.Friend.Vcard</see> and <see cref="Linphone.Vcard.Organization">
		/// Linphone.Vcard.Organization</see>. 
		/// </para>
		/// </summary>
		/// <returns>the organization set if any &amp; vCard is available, null otherwise. 
		///   </returns>
		public string Organization
		{
			get
			{
				IntPtr stringPtr = linphone_friend_get_organization(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_set_organization(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_phone_numbers(IntPtr thiz);

		/// <summary>
		/// Returns a list of phone numbers for this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of phone numbers as string.         </returns>
		public IEnumerable<string> PhoneNumbers
		{
			get
			{
				return MarshalStringArray(linphone_friend_get_phone_numbers(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_phone_numbers_with_label(IntPtr thiz);

		/// <summary>
		/// Returns a list of <see cref="Linphone.FriendPhoneNumber">
		/// Linphone.FriendPhoneNumber</see> for this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of phone numbers as string.         </returns>
		public IEnumerable<Linphone.FriendPhoneNumber> PhoneNumbersWithLabel
		{
			get
			{
				return MarshalBctbxList<Linphone.FriendPhoneNumber>(linphone_friend_get_phone_numbers_with_label(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_photo(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_set_photo(IntPtr thiz, string pictureUri);

		/// <summary>
		/// Gets the contact&apos;s picture URI. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the picture URI set if any, null otherwise.    </returns>
		public string Photo
		{
			get
			{
				IntPtr stringPtr = linphone_friend_get_photo(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_set_photo(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_presence_model(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_set_presence_model(IntPtr thiz, IntPtr presence);

		/// <summary>
		/// Get the presence model of a friend. 
		/// <para>
		/// If a friend has more than one SIP address and phone number, this method will
		/// return the most recent presence model using <see cref="Linphone.PresenceModel.Timestamp">
		/// Linphone.PresenceModel.Timestamp</see>. 
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.PresenceModel">Linphone.PresenceModel</see>
		/// object, or null if the friend do not have presence information (in which case
		/// he is considered offline).    </returns>
		public Linphone.PresenceModel PresenceModel
		{
			get
			{
				IntPtr ptr = linphone_friend_get_presence_model(nativePtr);
				Linphone.PresenceModel obj = fromNativePtr<Linphone.PresenceModel>(ptr, true);
				return obj;
			}
			set
			{
				linphone_friend_set_presence_model(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_ref_key(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_set_ref_key(IntPtr thiz, string key);

		/// <summary>
		/// Get the reference key of a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The reference key of the friend.    </returns>
		public string RefKey
		{
			get
			{
				IntPtr stringPtr = linphone_friend_get_ref_key(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_set_ref_key(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_get_starred(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_set_starred(IntPtr thiz, char isStarred);

		/// <summary>
		/// Gets if the friend is to be considered as important for the user. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the contact is a user&apos;s favorite, false otherwise.
		/// </returns>
		public bool Starred
		{
			get
			{
				return linphone_friend_get_starred(nativePtr) != 0;
			}
			set
			{
				linphone_friend_set_starred(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_subscribes_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_enable_subscribes(IntPtr thiz, char enable);

		/// <summary>
		/// get subscription flag value 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>returns true is subscription is activated for this friend </returns>
		public bool SubscribesEnabled
		{
			get
			{
				return linphone_friend_subscribes_enabled(nativePtr) != 0;
			}
			set
			{
				int exception_result = linphone_friend_enable_subscribes(nativePtr, value ? (char)1 : (char)0);
				if (exception_result != 0) throw new LinphoneException("SubscribesEnabled setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SubscriptionState linphone_friend_get_subscription_state(IntPtr thiz);

		/// <summary>
		/// Get subscription state of a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.SubscriptionState">
		/// Linphone.SubscriptionState</see> enum </returns>
		public Linphone.SubscriptionState SubscriptionState
		{
			get
			{
				return linphone_friend_get_subscription_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_vcard(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_set_vcard(IntPtr thiz, IntPtr vcard);

		/// <summary>
		/// Returns the vCard object associated to this friend, if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Vcard">Linphone.Vcard</see> or null.   
		/// </returns>
		public Linphone.Vcard Vcard
		{
			get
			{
				IntPtr ptr = linphone_friend_get_vcard(nativePtr);
				Linphone.Vcard obj = fromNativePtr<Linphone.Vcard>(ptr, true);
				return obj;
			}
			set
			{
				linphone_friend_set_vcard(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_add_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Adds an address in this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address"><see cref="Linphone.Address">Linphone.Address</see>
		/// object    </param>
		public void AddAddress(Linphone.Address address)
		{
			linphone_friend_add_address(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(address);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_add_phone_number(IntPtr thiz, string phoneNumber);

		/// <summary>
		/// Adds a phone number in this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">number to add    </param>
		public void AddPhoneNumber(string phoneNumber)
		{
			linphone_friend_add_phone_number(nativePtr, phoneNumber);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_add_phone_number_with_label(IntPtr thiz, IntPtr phoneNumber);

		/// <summary>
		/// Adds a <see cref="Linphone.FriendPhoneNumber">Linphone.FriendPhoneNumber</see>
		/// to this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">the <see cref="Linphone.FriendPhoneNumber">
		/// Linphone.FriendPhoneNumber</see> to add    </param>
		public void AddPhoneNumberWithLabel(Linphone.FriendPhoneNumber phoneNumber)
		{
			linphone_friend_add_phone_number_with_label(nativePtr, phoneNumber != null ? phoneNumber.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(phoneNumber);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_create_vcard(IntPtr thiz, string name);

		/// <summary>
		/// Creates a vCard object associated to this friend if there isn&apos;t one yet
		/// and if the full name is available, either by the parameter or the one in the
		/// friend&apos;s SIP URI. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">The full name of the friend or null to use the one from the
		/// friend&apos;s SIP URI    </param>
		/// <returns>true if the vCard has been created, false if it wasn&apos;t possible
		/// (for exemple if name and the friend&apos;s SIP URI are null or if the
		/// friend&apos;s SIP URI doesn&apos;t have a display name), or if there is already
		/// one vcard </returns>
		public bool CreateVcard(string name)
		{
			bool returnVal = linphone_friend_create_vcard(nativePtr, name) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_done(IntPtr thiz);

		/// <summary>
		/// Commits modification made to the friend configuration. 
		/// <para>
		/// </para>
		/// </summary>
		public void Done()
		{
			linphone_friend_done(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_edit(IntPtr thiz);

		/// <summary>
		/// Starts editing a friend configuration. 
		/// <para>
		/// Because friend configuration must be consistent, applications MUST call <see cref="Linphone.Friend.Edit()">
		/// Linphone.Friend.Edit()</see> before doing any attempts to modify friend
		/// configuration (such as <see cref="Linphone.Friend.Address">
		/// Linphone.Friend.Address</see> or <see cref="Linphone.Friend.IncSubscribePolicy">
		/// Linphone.Friend.IncSubscribePolicy</see>). Once the modifications are done,
		/// then the application must call <see cref="Linphone.Friend.Done()">
		/// Linphone.Friend.Done()</see> to commit the changes. 
		/// </para>
		/// </summary>
		public void Edit()
		{
			linphone_friend_edit(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_friend_get_capability_version(IntPtr thiz, int capability);

		/// <summary>
		/// Returns the version of a friend&apos;s capbility. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability"><see cref="Linphone.FriendCapability">
		/// Linphone.FriendCapability</see> object </param>
		/// <returns>the version of a friend&apos;s capbility. </returns>
		public float GetCapabilityVersion(Linphone.FriendCapability capability)
		{
			float returnVal = linphone_friend_get_capability_version(nativePtr, (int)capability);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_get_presence_model_for_uri_or_tel(IntPtr thiz, string uriOrTel);

		/// <summary>
		/// Get the presence model for a specific SIP URI or phone number of a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uriOrTel">The SIP URI or phone number for which to get the
		/// presence model    </param>
		/// <returns>A <see cref="Linphone.PresenceModel">Linphone.PresenceModel</see>
		/// object, or null if the friend do not have presence information for this SIP URI
		/// or phone number.    </returns>
		public Linphone.PresenceModel GetPresenceModelForUriOrTel(string uriOrTel)
		{
			IntPtr ptr = linphone_friend_get_presence_model_for_uri_or_tel(nativePtr, uriOrTel);
			Linphone.PresenceModel returnVal = fromNativePtr<Linphone.PresenceModel>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_has_capability(IntPtr thiz, int capability);

		/// <summary>
		/// Returns whether or not a friend has a capbility. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability"><see cref="Linphone.FriendCapability">
		/// Linphone.FriendCapability</see> object </param>
		/// <returns>whether or not a friend has a capbility </returns>
		public bool HasCapability(Linphone.FriendCapability capability)
		{
			bool returnVal = linphone_friend_has_capability(nativePtr, (int)capability) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_has_capability_with_version(IntPtr thiz, int capability, float version);

		/// <summary>
		/// Returns whether or not a friend has a capbility with a given version. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability"><see cref="Linphone.FriendCapability">
		/// Linphone.FriendCapability</see> object </param>
		/// <param name="version">the version to test </param>
		/// <returns>whether or not a friend has a capbility with a given version or -1.0
		/// if friend has not capability. </returns>
		public bool HasCapabilityWithVersion(Linphone.FriendCapability capability, float version)
		{
			bool returnVal = linphone_friend_has_capability_with_version(nativePtr, (int)capability, version) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_has_capability_with_version_or_more(IntPtr thiz, int capability, float version);

		/// <summary>
		/// Returns whether or not a friend has a capbility with a given version or more. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability"><see cref="Linphone.FriendCapability">
		/// Linphone.FriendCapability</see> object </param>
		/// <param name="version">the version to test </param>
		/// <returns>whether or not a friend has a capbility with a given version or more.
		/// </returns>
		public bool HasCapabilityWithVersionOrMore(Linphone.FriendCapability capability, float version)
		{
			bool returnVal = linphone_friend_has_capability_with_version_or_more(nativePtr, (int)capability, version) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_has_phone_number(IntPtr thiz, string phoneNumber);

		/// <summary>
		/// Returns whether a friend contains the given phone number. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">the phone number to search for    </param>
		/// <returns>true if found, false otherwise </returns>
		public bool HasPhoneNumber(string phoneNumber)
		{
			bool returnVal = linphone_friend_has_phone_number(nativePtr, phoneNumber) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_in_list(IntPtr thiz);

		/// <summary>
		/// Check that the given friend is in a friend list. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the friend is in a friend list, false otherwise. </returns>
		public bool InList()
		{
			bool returnVal = linphone_friend_in_list(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_remove(IntPtr thiz);

		/// <summary>
		/// Removes a friend from it&apos;s friend list and from the rc if exists. 
		/// <para>
		/// </para>
		/// </summary>
		public void Remove()
		{
			linphone_friend_remove(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_remove_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Removes an address in this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address"><see cref="Linphone.Address">Linphone.Address</see>
		/// object    </param>
		public void RemoveAddress(Linphone.Address address)
		{
			linphone_friend_remove_address(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(address);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_remove_phone_number(IntPtr thiz, string phoneNumber);

		/// <summary>
		/// Removes a phone number in this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">number to remove    </param>
		public void RemovePhoneNumber(string phoneNumber)
		{
			linphone_friend_remove_phone_number(nativePtr, phoneNumber);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_remove_phone_number_with_label(IntPtr thiz, IntPtr phoneNumber);

		/// <summary>
		/// Removes a <see cref="Linphone.FriendPhoneNumber">
		/// Linphone.FriendPhoneNumber</see> from this friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">the <see cref="Linphone.FriendPhoneNumber">
		/// Linphone.FriendPhoneNumber</see> to remove    </param>
		public void RemovePhoneNumberWithLabel(Linphone.FriendPhoneNumber phoneNumber)
		{
			linphone_friend_remove_phone_number_with_label(nativePtr, phoneNumber != null ? phoneNumber.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(phoneNumber);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_save(IntPtr thiz, IntPtr core);

		/// <summary>
		/// Saves a friend either in database if configured, otherwise in linphonerc. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="core">the linphone core    </param>
		public void Save(Linphone.Core core)
		{
			linphone_friend_save(nativePtr, core != null ? core.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(core);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_set_presence_model_for_uri_or_tel(IntPtr thiz, string uriOrTel, IntPtr presence);

		/// <summary>
		/// Set the presence model for a specific SIP URI or phone number of a friend. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uriOrTel">The SIP URI or phone number for which to set the
		/// presence model    </param>
		/// <param name="presence">The <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object to set    </param>
		public void SetPresenceModelForUriOrTel(string uriOrTel, Linphone.PresenceModel presence)
		{
			linphone_friend_set_presence_model_for_uri_or_tel(nativePtr, uriOrTel, presence != null ? presence.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(presence);
			
		}
	}
	/// <summary>
	/// This object representing a list of <see cref="Linphone.Friend">
	/// Linphone.Friend</see>. 
	/// <para>
	/// You can use it to store contacts locally or synchronize them through CardDAV
	/// protocol. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class FriendList : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_friend_list_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private FriendListListener listener;

		public FriendListListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_friend_list_cbs(linphone_factory_get());
					listener = fromNativePtr<FriendListListener>(nativeListener, false, true);
					linphone_friend_list_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_friend_list_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_core(IntPtr thiz);

		/// <summary>
		/// Returns the <see cref="Linphone.Core">Linphone.Core</see> object attached to
		/// this LinphoneFriendList. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Core">Linphone.Core</see> object    </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_friend_list_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_list_database_storage_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_enable_database_storage(IntPtr thiz, char enable);

		/// <summary>
		/// Gets whether this friend list and it&apos;s friends will be stored in DB or
		/// not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Whether the list and it&apos;s friends will be saved in database or
		/// not </returns>
		public bool DatabaseStorageEnabled
		{
			get
			{
				return linphone_friend_list_database_storage_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_friend_list_enable_database_storage(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_display_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_set_display_name(IntPtr thiz, string displayName);

		/// <summary>
		/// Get the display name of the friend list. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The display name of the friend list.    </returns>
		public string DisplayName
		{
			get
			{
				IntPtr stringPtr = linphone_friend_list_get_display_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_list_set_display_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_friends(IntPtr thiz);

		/// <summary>
		/// Retrieves the list of <see cref="Linphone.Friend">Linphone.Friend</see> from
		/// this LinphoneFriendList. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of <see cref="Linphone.Friend">Linphone.Friend</see>     
		/// </returns>
		public IEnumerable<Linphone.Friend> Friends
		{
			get
			{
				return MarshalBctbxList<Linphone.Friend>(linphone_friend_list_get_friends(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_list_is_subscription_bodyless(IntPtr thiz);

		/// <summary>
		/// Get wheter the subscription of the friend list is bodyless or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Wheter the subscription of the friend list is bodyless or not.
		/// </returns>
		public bool IsSubscriptionBodyless
		{
			get
			{
				return linphone_friend_list_is_subscription_bodyless(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_rls_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_set_rls_address(IntPtr thiz, IntPtr rlsAddr);

		/// <summary>
		/// Get the RLS (Resource List Server) URI associated with the friend list to
		/// subscribe to these friends presence. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The RLS URI as <see cref="Linphone.Address">Linphone.Address</see>
		/// associated with the friend list.    </returns>
		public Linphone.Address RlsAddress
		{
			get
			{
				IntPtr ptr = linphone_friend_list_get_rls_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				linphone_friend_list_set_rls_address(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_rls_uri(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_set_rls_uri(IntPtr thiz, string rlsUri);

		/// <summary>
		/// Get the RLS (Resource List Server) URI associated with the friend list to
		/// subscribe to these friends presence. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The RLS URI associated with the friend list.    </returns>
		/// deprecated : 27/10/2020. Use <see cref="Linphone.FriendList.RlsAddress">
		/// Linphone.FriendList.RlsAddress</see> instead. 
		public string RlsUri
		{
			get
			{
				IntPtr stringPtr = linphone_friend_list_get_rls_uri(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_list_set_rls_uri(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_set_subscription_bodyless(IntPtr thiz, char bodyless);

		/// <summary>
		/// Set wheter the subscription of the friend list is bodyless or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="bodyless">boolean telling if the subscription of the friend list
		/// is bodyless or not. </param>
		public bool SubscriptionBodyless
		{
			set
			{
				linphone_friend_list_set_subscription_bodyless(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_friend_list_subscriptions_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_enable_subscriptions(IntPtr thiz, char enabled);

		/// <summary>
		/// Gets whether subscription to NOTIFYs are enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Whether subscriptions are enabled or not </returns>
		public bool SubscriptionsEnabled
		{
			get
			{
				return linphone_friend_list_subscriptions_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_friend_list_enable_subscriptions(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.FriendListType linphone_friend_list_get_type(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_set_type(IntPtr thiz, int type);

		/// <summary>
		/// Get the <see cref="Linphone.FriendListType">Linphone.FriendListType</see> of a
		/// friend list. 
		/// <para>
		/// </para>
		/// </summary>
		public Linphone.FriendListType Type
		{
			get
			{
				return linphone_friend_list_get_type(nativePtr);
			}
			set
			{
				linphone_friend_list_set_type(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_get_uri(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_set_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Get the URI associated with the friend list. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The URI associated with the friend list.    </returns>
		public string Uri
		{
			get
			{
				IntPtr stringPtr = linphone_friend_list_get_uri(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_list_set_uri(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.FriendListStatus linphone_friend_list_add_friend(IntPtr thiz, IntPtr linphoneFriend);

		/// <summary>
		/// Add a friend to a friend list. 
		/// <para>
		/// If or when a remote CardDAV server will be attached to the list, the friend
		/// will be sent to the server. 
		/// </para>
		/// </summary>
		/// <param name="linphoneFriend"><see cref="Linphone.Friend">Linphone.Friend</see>
		/// object to add to the friend list.    </param>
		/// <returns><see cref="Linphone.FriendListStatus.OK">
		/// Linphone.FriendListStatus.OK</see> if successfully added, <see cref="Linphone.FriendListStatus.InvalidFriend">
		/// Linphone.FriendListStatus.InvalidFriend</see> if the friend is not valid.
		/// </returns>
		public Linphone.FriendListStatus AddFriend(Linphone.Friend linphoneFriend)
		{
			Linphone.FriendListStatus returnVal = linphone_friend_list_add_friend(nativePtr, linphoneFriend != null ? linphoneFriend.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(linphoneFriend);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.FriendListStatus linphone_friend_list_add_local_friend(IntPtr thiz, IntPtr linphoneFriend);

		/// <summary>
		/// Add a friend to a friend list. 
		/// <para>
		/// The friend will never be sent to a remote CardDAV server. Warning! <see cref="Linphone.Friend">
		/// Linphone.Friend</see> added this way will be removed on the next
		/// synchronization, and the callback contact_deleted will be called. 
		/// </para>
		/// </summary>
		/// <param name="linphoneFriend"><see cref="Linphone.Friend">Linphone.Friend</see>
		/// object to add to the friend list.    </param>
		/// <returns><see cref="Linphone.FriendListStatus.OK">
		/// Linphone.FriendListStatus.OK</see> if successfully added, <see cref="Linphone.FriendListStatus.InvalidFriend">
		/// Linphone.FriendListStatus.InvalidFriend</see> if the friend is not valid.
		/// </returns>
		public Linphone.FriendListStatus AddLocalFriend(Linphone.Friend linphoneFriend)
		{
			Linphone.FriendListStatus returnVal = linphone_friend_list_add_local_friend(nativePtr, linphoneFriend != null ? linphoneFriend.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(linphoneFriend);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_export_friends_as_vcard4_file(IntPtr thiz, string vcardFile);

		/// <summary>
		/// Creates and export <see cref="Linphone.Friend">Linphone.Friend</see> objects
		/// from <see cref="Linphone.FriendList">Linphone.FriendList</see> to a file using
		/// vCard 4 format. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="vcardFile">the path to a file that will contain the vCards   
		/// </param>
		public void ExportFriendsAsVcard4File(string vcardFile)
		{
			linphone_friend_list_export_friends_as_vcard4_file(nativePtr, vcardFile);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_find_friend_by_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Find a friend in the friend list using a LinphoneAddress. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address"><see cref="Linphone.Address">Linphone.Address</see>
		/// object of the friend we want to search for.    </param>
		/// <returns>A <see cref="Linphone.Friend">Linphone.Friend</see> if found, null
		/// otherwise.    </returns>
		public Linphone.Friend FindFriendByAddress(Linphone.Address address)
		{
			IntPtr ptr = linphone_friend_list_find_friend_by_address(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
			GC.KeepAlive(address);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_find_friend_by_phone_number(IntPtr thiz, string phoneNumber);

		/// <summary>
		/// Find a friend in the friend list using a phone number. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">a string of the phone number for which we want to
		/// find a friend.    </param>
		/// <returns>A <see cref="Linphone.Friend">Linphone.Friend</see> if found, null
		/// otherwise.    </returns>
		public Linphone.Friend FindFriendByPhoneNumber(string phoneNumber)
		{
			IntPtr ptr = linphone_friend_list_find_friend_by_phone_number(nativePtr, phoneNumber);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_find_friend_by_ref_key(IntPtr thiz, string refKey);

		/// <summary>
		/// Find a friend in the friend list using a ref key. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="refKey">The ref key string of the friend we want to search for.   
		/// </param>
		/// <returns>A <see cref="Linphone.Friend">Linphone.Friend</see> if found, null
		/// otherwise.    </returns>
		public Linphone.Friend FindFriendByRefKey(string refKey)
		{
			IntPtr ptr = linphone_friend_list_find_friend_by_ref_key(nativePtr, refKey);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_find_friend_by_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Find a friend in the friend list using an URI string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri">A string containing the URI of the friend we want to search
		/// for.    </param>
		/// <returns>A <see cref="Linphone.Friend">Linphone.Friend</see> if found, null
		/// otherwise.    </returns>
		public Linphone.Friend FindFriendByUri(string uri)
		{
			IntPtr ptr = linphone_friend_list_find_friend_by_uri(nativePtr, uri);
			Linphone.Friend returnVal = fromNativePtr<Linphone.Friend>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_find_friends_by_address(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Find all friends in the friend list using a LinphoneAddress. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address"><see cref="Linphone.Address">Linphone.Address</see>
		/// object of the friends we want to search for.    </param>
		/// <returns>A list of <see cref="Linphone.Friend">Linphone.Friend</see> if found,
		/// null otherwise.      </returns>
		public IEnumerable<Linphone.Friend> FindFriendsByAddress(Linphone.Address address)
		{
			IEnumerable<Linphone.Friend> returnVal = MarshalBctbxList<Linphone.Friend>(linphone_friend_list_find_friends_by_address(nativePtr, address != null ? address.nativePtr : IntPtr.Zero), true);
			
			GC.KeepAlive(address);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_list_find_friends_by_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Find all friends in the friend list using an URI string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="uri">A string containing the URI of the friends we want to search
		/// for.    </param>
		/// <returns>A list of <see cref="Linphone.Friend">Linphone.Friend</see> if found,
		/// null otherwise.      </returns>
		public IEnumerable<Linphone.Friend> FindFriendsByUri(string uri)
		{
			IEnumerable<Linphone.Friend> returnVal = MarshalBctbxList<Linphone.Friend>(linphone_friend_list_find_friends_by_uri(nativePtr, uri), true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_list_import_friends_from_vcard4_buffer(IntPtr thiz, string vcardBuffer);

		/// <summary>
		/// Creates and adds <see cref="Linphone.Friend">Linphone.Friend</see> objects to
		/// <see cref="Linphone.FriendList">Linphone.FriendList</see> from a buffer that
		/// contains the vCard(s) to parse. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="vcardBuffer">the buffer that contains the vCard(s) to parse   
		/// </param>
		/// <returns>the amount of linphone friends created </returns>
		public int ImportFriendsFromVcard4Buffer(string vcardBuffer)
		{
			int returnVal = linphone_friend_list_import_friends_from_vcard4_buffer(nativePtr, vcardBuffer);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_friend_list_import_friends_from_vcard4_file(IntPtr thiz, string vcardFile);

		/// <summary>
		/// Creates and adds <see cref="Linphone.Friend">Linphone.Friend</see> objects to
		/// <see cref="Linphone.FriendList">Linphone.FriendList</see> from a file that
		/// contains the vCard(s) to parse. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="vcardFile">the path to a file that contains the vCard(s) to parse 
		///   </param>
		/// <returns>the amount of linphone friends created </returns>
		public int ImportFriendsFromVcard4File(string vcardFile)
		{
			int returnVal = linphone_friend_list_import_friends_from_vcard4_file(nativePtr, vcardFile);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_notify_presence(IntPtr thiz, IntPtr presence);

		/// <summary>
		/// Notify our presence to all the friends in the friend list that have subscribed
		/// to our presence directly (not using a RLS). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="presence"><see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object.    </param>
		public void NotifyPresence(Linphone.PresenceModel presence)
		{
			linphone_friend_list_notify_presence(nativePtr, presence != null ? presence.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(presence);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.FriendListStatus linphone_friend_list_remove_friend(IntPtr thiz, IntPtr linphoneFriend);

		/// <summary>
		/// Remove a friend from a friend list. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="linphoneFriend"><see cref="Linphone.Friend">Linphone.Friend</see>
		/// object to remove from the friend list.    </param>
		/// <returns><see cref="Linphone.FriendListStatus.OK">
		/// Linphone.FriendListStatus.OK</see> if removed successfully, <see cref="Linphone.FriendListStatus.NonExistentFriend">
		/// Linphone.FriendListStatus.NonExistentFriend</see> if the friend is not in the
		/// list. </returns>
		public Linphone.FriendListStatus RemoveFriend(Linphone.Friend linphoneFriend)
		{
			Linphone.FriendListStatus returnVal = linphone_friend_list_remove_friend(nativePtr, linphoneFriend != null ? linphoneFriend.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(linphoneFriend);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_synchronize_friends_from_server(IntPtr thiz);

		/// <summary>
		/// Starts a CardDAV synchronization using value set using
		/// linphone_friend_list_set_uri. 
		/// <para>
		/// </para>
		/// </summary>
		public void SynchronizeFriendsFromServer()
		{
			linphone_friend_list_synchronize_friends_from_server(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_update_dirty_friends(IntPtr thiz);

		/// <summary>
		/// Goes through all the <see cref="Linphone.Friend">Linphone.Friend</see> that are
		/// dirty and does a CardDAV PUT to update the server. 
		/// <para>
		/// </para>
		/// </summary>
		public void UpdateDirtyFriends()
		{
			linphone_friend_list_update_dirty_friends(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_update_revision(IntPtr thiz, int revision);

		/// <summary>
		/// Sets the revision from the last synchronization. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="revision">The revision </param>
		public void UpdateRevision(int revision)
		{
			linphone_friend_list_update_revision(nativePtr, revision);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_list_update_subscriptions(IntPtr thiz);

		/// <summary>
		/// Update presence subscriptions for the entire list. 
		/// <para>
		/// Calling this function is necessary when list subscriptions are enabled, ie when
		/// a RLS presence server is used. 
		/// </para>
		/// </summary>
		public void UpdateSubscriptions()
		{
			linphone_friend_list_update_subscriptions(nativePtr);
			
			
						
		}
	}
	/// <summary>
	/// Object that represents a <see cref="Linphone.Friend">
	/// Linphone.Friend</see>&apos;s phone number. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class FriendPhoneNumber : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_phone_number_get_label(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_phone_number_set_label(IntPtr thiz, string label);

		/// <summary>
		/// Gets the label associated to this phone number. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the label set if any, null otherwise.    </returns>
		public string Label
		{
			get
			{
				IntPtr stringPtr = linphone_friend_phone_number_get_label(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_phone_number_set_label(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_phone_number_get_phone_number(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_friend_phone_number_set_phone_number(IntPtr thiz, string number);

		/// <summary>
		/// Gets the phone number. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the phone number stored.    </returns>
		public string PhoneNumber
		{
			get
			{
				IntPtr stringPtr = linphone_friend_phone_number_get_phone_number(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_friend_phone_number_set_phone_number(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_friend_phone_number_clone(IntPtr thiz);

		/// <summary>
		/// Clones a phone number. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The newly created <see cref="Linphone.FriendPhoneNumber">
		/// Linphone.FriendPhoneNumber</see> object.    </returns>
		public Linphone.FriendPhoneNumber Clone()
		{
			IntPtr ptr = linphone_friend_phone_number_clone(nativePtr);
			Linphone.FriendPhoneNumber returnVal = fromNativePtr<Linphone.FriendPhoneNumber>(ptr, false);
			
						return returnVal;
		}
	}
	/// <summary>
	/// Object representing a chain of protocol headers. 
	/// <para>
	/// It provides read/write access to the headers of the underlying protocol. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Headers : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_headers_add(IntPtr thiz, string name, string val);

		/// <summary>
		/// Add given header name and corresponding value. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the header&apos;s name    </param>
		/// <param name="val">the header&apos;s value    </param>
		public void Add(string name, string val)
		{
			linphone_headers_add(nativePtr, name, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_headers_get_value(IntPtr thiz, string headerName);

		/// <summary>
		/// Search for a given header name and return its value. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">the header&apos;s name    </param>
		/// <returns>the header&apos;s value or null if not found.    </returns>
		public string GetValue(string headerName)
		{
			IntPtr stringPtr = linphone_headers_get_value(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_headers_remove(IntPtr thiz, string name);

		/// <summary>
		/// Add given header name and corresponding value. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the header&apos;s name    </param>
		public void Remove(string name)
		{
			linphone_headers_remove(nativePtr, name);
			
			
						
		}
	}
	/// <summary>
	/// Policy to use to send/receive instant messaging composing/delivery/display
	/// notifications. 
	/// <para>
	/// The sending of this information is done as in the RFCs 3994 (is_composing) and
	/// 5438 (imdn delivered/displayed). 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ImNotifPolicy : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_recv_imdn_delivered(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_recv_imdn_delivered(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether imdn delivered notifications are being notified when received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether imdn delivered notifications are being
		/// notified when received. </returns>
		public bool RecvImdnDelivered
		{
			get
			{
				return linphone_im_notif_policy_get_recv_imdn_delivered(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_recv_imdn_delivered(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_recv_imdn_delivery_error(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_recv_imdn_delivery_error(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether imdn delivery error notifications are being notified when
		/// received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether imdn delivery error notifications are
		/// being notified when received. </returns>
		public bool RecvImdnDeliveryError
		{
			get
			{
				return linphone_im_notif_policy_get_recv_imdn_delivery_error(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_recv_imdn_delivery_error(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_recv_imdn_displayed(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_recv_imdn_displayed(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether imdn displayed notifications are being notified when received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether imdn displayed notifications are being
		/// notified when received. </returns>
		public bool RecvImdnDisplayed
		{
			get
			{
				return linphone_im_notif_policy_get_recv_imdn_displayed(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_recv_imdn_displayed(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_recv_is_composing(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_recv_is_composing(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether is_composing notifications are being notified when received. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether is_composing notifications are being
		/// notified when received. </returns>
		public bool RecvIsComposing
		{
			get
			{
				return linphone_im_notif_policy_get_recv_is_composing(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_recv_is_composing(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_send_imdn_delivered(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_send_imdn_delivered(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether imdn delivered notifications are being sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether imdn delivered notifications are being
		/// sent. </returns>
		public bool SendImdnDelivered
		{
			get
			{
				return linphone_im_notif_policy_get_send_imdn_delivered(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_send_imdn_delivered(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_send_imdn_delivery_error(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_send_imdn_delivery_error(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether imdn delivery error notifications are being sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether imdn delivery error notifications are
		/// being sent. </returns>
		public bool SendImdnDeliveryError
		{
			get
			{
				return linphone_im_notif_policy_get_send_imdn_delivery_error(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_send_imdn_delivery_error(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_send_imdn_displayed(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_send_imdn_displayed(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether imdn displayed notifications are being sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether imdn displayed notifications are being
		/// sent. </returns>
		public bool SendImdnDisplayed
		{
			get
			{
				return linphone_im_notif_policy_get_send_imdn_displayed(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_send_imdn_displayed(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_im_notif_policy_get_send_is_composing(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_set_send_is_composing(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether is_composing notifications are being sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether is_composing notifications are being
		/// sent. </returns>
		public bool SendIsComposing
		{
			get
			{
				return linphone_im_notif_policy_get_send_is_composing(nativePtr) != 0;
			}
			set
			{
				linphone_im_notif_policy_set_send_is_composing(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_clear(IntPtr thiz);

		/// <summary>
		/// Clear an IM notif policy (deactivate all receiving and sending of
		/// notifications). 
		/// <para>
		/// Note: Error IMDN must be enabled for Lime recovery mechanism 
		/// </para>
		/// </summary>
		public void Clear()
		{
			linphone_im_notif_policy_clear(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_im_notif_policy_enable_all(IntPtr thiz);

		/// <summary>
		/// Enable all receiving and sending of notifications. 
		/// <para>
		/// </para>
		/// </summary>
		public void EnableAll()
		{
			linphone_im_notif_policy_enable_all(nativePtr);
			
			
						
		}
	}
	/// <summary>
	/// Object representing an informational message sent or received by the core. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class InfoMessage : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_info_message_get_content(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_info_message_set_content(IntPtr thiz, IntPtr content);

		/// <summary>
		/// Returns the info message&apos;s content as a <see cref="Linphone.Content">
		/// Linphone.Content</see> structure. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Content">Linphone.Content</see> object.   
		/// </returns>
		public Linphone.Content Content
		{
			get
			{
				IntPtr ptr = linphone_info_message_get_content(nativePtr);
				Linphone.Content obj = fromNativePtr<Linphone.Content>(ptr, true);
				return obj;
			}
			set
			{
				linphone_info_message_set_content(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_info_message_add_header(IntPtr thiz, string name, string val);

		/// <summary>
		/// Add a header to an info message to be sent. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the header&apos;name    </param>
		/// <param name="val">the header&apos;s value    </param>
		public void AddHeader(string name, string val)
		{
			linphone_info_message_add_header(nativePtr, name, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_info_message_get_header(IntPtr thiz, string name);

		/// <summary>
		/// Obtain a header value from a received info message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the header&apos;name    </param>
		/// <returns>the corresponding header&apos;s value, or null if not exists.   
		/// </returns>
		public string GetHeader(string name)
		{
			IntPtr stringPtr = linphone_info_message_get_header(nativePtr, name);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
	}
	/// <summary>
	/// Object that represents a Linphone Ldap. 
	/// <para>
	/// Use a <see cref="Linphone.LdapParams">Linphone.LdapParams</see> object to
	/// configure it. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Ldap : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_ldap_new_with_params(IntPtr lc, IntPtr parameters);

		/// <summary>
		/// Create a new <see cref="Linphone.Ldap">Linphone.Ldap</see>, associate it with
		/// the <see cref="Linphone.LdapParams">Linphone.LdapParams</see> and store it into
		/// the configuration file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="lc">The <see cref="Linphone.Core">Linphone.Core</see> object.   
		/// </param>
		/// <param name="parameters">The <see cref="Linphone.LdapParams">
		/// Linphone.LdapParams</see> object.    </param>
		/// <returns>The newly created <see cref="Linphone.Ldap">Linphone.Ldap</see>
		/// object.       </returns>
		public static Linphone.Ldap NewWithParams(Linphone.Core lc, Linphone.LdapParams parameters)
		{
			IntPtr ptr = linphone_ldap_new_with_params(lc != null ? lc.nativePtr : IntPtr.Zero, parameters != null ? parameters.nativePtr : IntPtr.Zero);
			Linphone.Ldap returnVal = fromNativePtr<Linphone.Ldap>(ptr, false);
			
			GC.KeepAlive(lc);
GC.KeepAlive(parameters);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_ldap_get_core(IntPtr thiz);

		/// <summary>
		/// Get the <see cref="Linphone.Core">Linphone.Core</see> object to which is
		/// associated the <see cref="Linphone.Ldap">Linphone.Ldap</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Core">Linphone.Core</see> object to which is
		/// associated the <see cref="Linphone.Ldap">Linphone.Ldap</see>.    </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_ldap_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_ldap_get_index(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_set_index(IntPtr thiz, int index);

		/// <summary>
		/// Get the index of the <see cref="Linphone.Ldap">Linphone.Ldap</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The index of the Ldap </returns>
		public int Index
		{
			get
			{
				return linphone_ldap_get_index(nativePtr);
			}
			set
			{
				linphone_ldap_set_index(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_ldap_get_params(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_set_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Get the <see cref="Linphone.LdapParams">Linphone.LdapParams</see> as read-only
		/// object. 
		/// <para>
		/// To make changes, clone the returned object using <see cref="Linphone.LdapParams.Clone()">
		/// Linphone.LdapParams.Clone()</see> method, make your changes on it and apply
		/// them using with <see cref="Linphone.Ldap.Params">Linphone.Ldap.Params</see>. 
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.LdapParams">Linphone.LdapParams</see> attached
		/// to this ldap.    </returns>
		public Linphone.LdapParams Params
		{
			get
			{
				IntPtr ptr = linphone_ldap_get_params(nativePtr);
				Linphone.LdapParams obj = fromNativePtr<Linphone.LdapParams>(ptr, true);
				return obj;
			}
			set
			{
				linphone_ldap_set_params(nativePtr, value.nativePtr);
				
			}
		}
	}
	/// <summary>
	/// Object that is used to set the different parameters of a <see cref="Linphone.Ldap">
	/// Linphone.Ldap</see>. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class LdapParams : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.LdapAuthMethod linphone_ldap_params_get_auth_method(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_auth_method(IntPtr thiz, int authMethod);

		/// <summary>
		/// Get the authentification method. 
		/// <para>
		/// Check <see cref="Linphone.LdapAuthMethod">Linphone.LdapAuthMethod</see> for
		/// authentification values.
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.LdapAuthMethod">Linphone.LdapAuthMethod</see>.
		/// </returns>
		public Linphone.LdapAuthMethod AuthMethod
		{
			get
			{
				return linphone_ldap_params_get_auth_method(nativePtr);
			}
			set
			{
				linphone_ldap_params_set_auth_method(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_ldap_params_get_base_object(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_base_object(IntPtr thiz, string baseObject);

		/// <summary>
		/// Get the BaseObject. 
		/// <para>
		/// It is a specification for LDAP Search Scopes that specifies that the Search
		/// Request should only be performed against the entry specified as the search base
		/// DN. No entries above it will be considered. This field is required.
		/// </para>
		/// </summary>
		/// <returns>The specification.    </returns>
		public string BaseObject
		{
			get
			{
				IntPtr stringPtr = linphone_ldap_params_get_base_object(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_ldap_params_set_base_object(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_ldap_params_get_bind_dn(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_bind_dn(IntPtr thiz, string bindDn);

		/// <summary>
		/// Get the Bind DN to use for bindings. 
		/// <para>
		/// The bindDN DN is the credential that is used to authenticate against an LDAP.
		/// If empty, the connection will be Anonymous. eg:
		/// cn=ausername,ou=people,dc=bc,dc=com
		/// </para>
		/// </summary>
		/// <returns>The Bind DN to use for bindings.    </returns>
		public string BindDn
		{
			get
			{
				IntPtr stringPtr = linphone_ldap_params_get_bind_dn(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_ldap_params_set_bind_dn(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.LdapDebugLevel linphone_ldap_params_get_debug_level(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_debug_level(IntPtr thiz, int level);

		/// <summary>
		/// Return the debug verbosity level. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.LdapDebugLevel">Linphone.LdapDebugLevel</see>
		/// debug level. </returns>
		public Linphone.LdapDebugLevel DebugLevel
		{
			get
			{
				return linphone_ldap_params_get_debug_level(nativePtr);
			}
			set
			{
				linphone_ldap_params_set_debug_level(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_ldap_params_get_delay(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_delay(IntPtr thiz, int delay);

		/// <summary>
		/// Get the delay between each search in milliseconds. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The delay in milliseconds. </returns>
		public int Delay
		{
			get
			{
				return linphone_ldap_params_get_delay(nativePtr);
			}
			set
			{
				linphone_ldap_params_set_delay(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_ldap_params_get_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_enabled(IntPtr thiz, char enable);

		/// <summary>
		/// Return if the configuration is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Enable or not the LDAP configuration. </returns>
		public bool Enabled
		{
			get
			{
				return linphone_ldap_params_get_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_ldap_params_set_enabled(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_ldap_params_get_filter(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_filter(IntPtr thiz, string filter);

		/// <summary>
		/// Get the search is based on this filter to search contacts. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The filter to use.    </returns>
		public string Filter
		{
			get
			{
				IntPtr stringPtr = linphone_ldap_params_get_filter(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_ldap_params_set_filter(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_ldap_params_get_max_results(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_max_results(IntPtr thiz, int maxResults);

		/// <summary>
		/// Get the max results when requesting searches. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The max results when requesting searches. </returns>
		public int MaxResults
		{
			get
			{
				return linphone_ldap_params_get_max_results(nativePtr);
			}
			set
			{
				linphone_ldap_params_set_max_results(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_ldap_params_get_min_chars(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_min_chars(IntPtr thiz, int minChars);

		/// <summary>
		/// Get the minimum characters needed for doing a search on LDAP servers. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The minimum characters needed by a search. </returns>
		public int MinChars
		{
			get
			{
				return linphone_ldap_params_get_min_chars(nativePtr);
			}
			set
			{
				linphone_ldap_params_set_min_chars(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_ldap_params_get_name_attribute(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_name_attribute(IntPtr thiz, string nameAttribute);

		/// <summary>
		/// Get the attributes to build Name Friend, separated by a comma and the first is
		/// the highest priority. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The comma separated attributes for the search.    </returns>
		public string NameAttribute
		{
			get
			{
				IntPtr stringPtr = linphone_ldap_params_get_name_attribute(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_ldap_params_set_name_attribute(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_ldap_params_get_password(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_password(IntPtr thiz, string password);

		/// <summary>
		/// Get the password to pass to server when binding. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The password to pass to server when binding.    </returns>
		public string Password
		{
			get
			{
				IntPtr stringPtr = linphone_ldap_params_get_password(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_ldap_params_set_password(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_ldap_params_sal_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_enable_sal(IntPtr thiz, char enable);

		/// <summary>
		/// Return if the dns resolution is done by Linphone using Sal. 
		/// <para>
		/// It will pass an IP to LDAP. By doing that, the TLS negociation could not check
		/// the hostname. You may deactivate the verifications if wanted to force the
		/// connection.
		/// </para>
		/// </summary>
		/// <returns>Enable or not the use of sal. </returns>
		public bool SalEnabled
		{
			get
			{
				return linphone_ldap_params_sal_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_ldap_params_enable_sal(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_ldap_params_get_server(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_server(IntPtr thiz, string server);

		/// <summary>
		/// Get the LDAP Server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>LDAP Server address.    </returns>
		public string Server
		{
			get
			{
				IntPtr stringPtr = linphone_ldap_params_get_server(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_ldap_params_set_server(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.LdapCertVerificationMode linphone_ldap_params_get_server_certificates_verification_mode(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_server_certificates_verification_mode(IntPtr thiz, int verifyServerCertificates);

		/// <summary>
		/// Return whether the tls server certificate must be verified when connecting to a
		/// LDAP server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The TLS verification mode from <see cref="Linphone.LdapCertVerificationMode">
		/// Linphone.LdapCertVerificationMode</see> </returns>
		public Linphone.LdapCertVerificationMode ServerCertificatesVerificationMode
		{
			get
			{
				return linphone_ldap_params_get_server_certificates_verification_mode(nativePtr);
			}
			set
			{
				linphone_ldap_params_set_server_certificates_verification_mode(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_ldap_params_get_sip_attribute(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_sip_attribute(IntPtr thiz, string sipAttribute);

		/// <summary>
		/// Get the attributes to build the SIP username in address of Friend. 
		/// <para>
		/// Attributes are separated by a comma.
		/// </para>
		/// </summary>
		/// <returns>The comma separated attributes for building Friend.    </returns>
		public string SipAttribute
		{
			get
			{
				IntPtr stringPtr = linphone_ldap_params_get_sip_attribute(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_ldap_params_set_sip_attribute(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_ldap_params_get_sip_domain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_sip_domain(IntPtr thiz, string sipDomain);

		/// <summary>
		/// Get the domain to the sip address(sip:username@domain). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The SIP domain for the friend.    </returns>
		public string SipDomain
		{
			get
			{
				IntPtr stringPtr = linphone_ldap_params_get_sip_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_ldap_params_set_sip_domain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_ldap_params_get_timeout(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_timeout(IntPtr thiz, int timeout);

		/// <summary>
		/// Get the timeout for requests in seconds. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The timeout in seconds. </returns>
		public int Timeout
		{
			get
			{
				return linphone_ldap_params_get_timeout(nativePtr);
			}
			set
			{
				linphone_ldap_params_set_timeout(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_ldap_params_get_timeout_tls_ms(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_timeout_tls_ms(IntPtr thiz, int timeout);

		/// <summary>
		/// Get the timeout for TLS connection in milliseconds. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The timeout in milliseconds. </returns>
		public int TimeoutTlsMs
		{
			get
			{
				return linphone_ldap_params_get_timeout_tls_ms(nativePtr);
			}
			set
			{
				linphone_ldap_params_set_timeout_tls_ms(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_ldap_params_tls_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_enable_tls(IntPtr thiz, char enable);

		/// <summary>
		/// Return if transactions are encrypted by LDAP over TLS(StartTLS). 
		/// <para>
		/// You must use \&apos;ldap\&apos; scheme. \&apos;ldaps\&apos; for LDAP over SSL
		/// is non-standardized and deprecated. StartTLS in an extension to the LDAP
		/// protocol which uses the TLS protocol to encrypt communication. It works by
		/// establishing a normal - i.e. unsecured - connection with the LDAP server before
		/// a handshake negotiation between the server and the web services is carried out.
		/// Here, the server sends its certificate to prove its identity before the secure
		/// connection is established.
		/// </para>
		/// </summary>
		/// <returns>Enable or not the use of TLS. </returns>
		public bool TlsEnabled
		{
			get
			{
				return linphone_ldap_params_tls_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_ldap_params_enable_tls(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_ldap_params_check(IntPtr thiz);

		/// <summary>
		/// Check parameters and return what are wrong. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.LdapCheck">Linphone.LdapCheck</see> values.
		/// LinphoneLdapCheckOk if everything is ok. </returns>
		public int Check()
		{
			int returnVal = linphone_ldap_params_check(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_ldap_params_clone(IntPtr thiz);

		/// <summary>
		/// Instantiate a new <see cref="Linphone.LdapParams">Linphone.LdapParams</see>
		/// with values from source. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The newly created <see cref="Linphone.LdapParams">
		/// Linphone.LdapParams</see> object.    </returns>
		public Linphone.LdapParams Clone()
		{
			IntPtr ptr = linphone_ldap_params_clone(nativePtr);
			Linphone.LdapParams returnVal = fromNativePtr<Linphone.LdapParams>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_ldap_params_get_custom_value(IntPtr thiz, string key);

		/// <summary>
		/// Get the value from field. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key string.    </param>
		/// <returns>The Value associated to the key.    </returns>
		public string GetCustomValue(string key)
		{
			IntPtr stringPtr = linphone_ldap_params_get_custom_value(nativePtr, key);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_ldap_params_set_custom_value(IntPtr thiz, string key, string val);

		/// <summary>
		/// Set custom field. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="key">The key string.    </param>
		/// <param name="val">The value string.    </param>
		public void SetCustomValue(string key, string val)
		{
			linphone_ldap_params_set_custom_value(nativePtr, key, val);
			
			
						
		}
	}
	/// <summary>
	/// Singleton class giving access to logging features. 
	/// <para>
	/// It supports custom domain, writing into a file as well as several verbosity
	/// levels. The <see cref="Linphone.LoggingServiceListener">
	/// Linphone.LoggingServiceListener</see> listener allows you to be notified each
	/// time a log is printed.
	/// As the <see cref="Linphone.LoggingService">Linphone.LoggingService</see> is a
	/// singleton, use <see cref="Linphone.LoggingService.">
	/// Linphone.LoggingService.</see> to get it. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class LoggingService : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_logging_service_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_logging_service_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_logging_service_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private LoggingServiceListener listener;

		public LoggingServiceListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_logging_service_cbs(linphone_factory_get());
					listener = fromNativePtr<LoggingServiceListener>(nativeListener, false, true);
					linphone_logging_service_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_logging_service_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_logging_service_get();

		/// <summary>
		/// Gets the singleton logging service object. 
		/// <para>
		/// The singleton is automatically instantiated if it hasn&apos;t been done yet.
		/// </para>
		/// </summary>
		/// <returns>A pointer on the <see cref="Linphone.LoggingService">
		/// Linphone.LoggingService</see> singleton.    </returns>
		static public Linphone.LoggingService Instance
		{
			get
			{
				IntPtr ptr = linphone_logging_service_get();
				Linphone.LoggingService obj = fromNativePtr<Linphone.LoggingService>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_logging_service_get_domain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_set_domain(IntPtr thiz, string domain);

		/// <summary>
		/// Get the domain where application logs are written (for example with <see cref="Linphone.LoggingService.Message()">
		/// Linphone.LoggingService.Message()</see>). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The domain where application logs are written.    </returns>
		public string Domain
		{
			get
			{
				IntPtr stringPtr = linphone_logging_service_get_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_logging_service_set_domain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_set_log_level(IntPtr thiz, int level);

		/// <summary>
		/// Set the verbosity of the log. 
		/// <para>
		/// For instance, a level of <see cref="Linphone.LogLevel.Message">
		/// Linphone.LogLevel.Message</see> will let pass fatal, error, warning and
		/// message-typed messages whereas trace and debug messages will be dumped out. 
		/// </para>
		/// </summary>
		/// <param name="level">the <see cref="Linphone.LogLevel">Linphone.LogLevel</see>
		/// to set </param>
		public Linphone.LogLevel LogLevel
		{
			set
			{
				linphone_logging_service_set_log_level(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_logging_service_get_log_level_mask(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_set_log_level_mask(IntPtr thiz, uint mask);

		/// <summary>
		/// Gets the log level mask. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the log level mask </returns>
		public uint LogLevelMask
		{
			get
			{
				return linphone_logging_service_get_log_level_mask(nativePtr);
			}
			set
			{
				linphone_logging_service_set_log_level_mask(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_enable_stack_trace_dumps(IntPtr thiz, char enable);

		/// <summary>
		/// Allow Linphone to set handlers for catching exceptions and write the stack
		/// trace into log. 
		/// <para>
		/// Available for Windows. It keeps old handlers. 
		/// </para>
		/// </summary>
		/// <param name="enable">if true global handlers will be prepend by the logger
		/// handlers. By default, it is false. </param>
		public bool StackTraceDumpsEnabled
		{
			set
			{
				linphone_logging_service_enable_stack_trace_dumps(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_debug(IntPtr thiz, string message);

		/// <summary>
		/// Write a LinphoneLogLevelDebug message to the logs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The log message.    </param>
		public void Debug(string message)
		{
			linphone_logging_service_debug(nativePtr, message);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_error(IntPtr thiz, string message);

		/// <summary>
		/// Write a LinphoneLogLevelError message to the logs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The log message.    </param>
		public void Error(string message)
		{
			linphone_logging_service_error(nativePtr, message);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_fatal(IntPtr thiz, string message);

		/// <summary>
		/// Write a LinphoneLogLevelFatal message to the logs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The log message.    </param>
		public void Fatal(string message)
		{
			linphone_logging_service_fatal(nativePtr, message);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_message(IntPtr thiz, string message);

		/// <summary>
		/// Write a LinphoneLogLevelMessage message to the logs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The log message.    </param>
		public void Message(string message)
		{
			linphone_logging_service_message(nativePtr, message);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_set_log_file(IntPtr thiz, string dir, string filename, long maxSize);

		/// <summary>
		/// Enables logging in a file. 
		/// <para>
		/// That function enables an internal log handler that writes log messages in
		/// log-rotated files.
		/// </para>
		/// </summary>
		/// <param name="dir">Directory where to create the distinct parts of the log.   
		/// </param>
		/// <param name="filename">Name of the log file.    </param>
		/// <param name="maxSize">The maximal size of each part of the log. The log
		/// rotating is triggered each time the currently opened log part reach that limit.
		/// </param>
		public void SetLogFile(string dir, string filename, long maxSize)
		{
			linphone_logging_service_set_log_file(nativePtr, dir, filename, maxSize);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_trace(IntPtr thiz, string message);

		/// <summary>
		/// Write a LinphoneLogLevelTrace message to the logs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The log message.    </param>
		public void Trace(string message)
		{
			linphone_logging_service_trace(nativePtr, message);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_logging_service_warning(IntPtr thiz, string message);

		/// <summary>
		/// Write a LinphoneLogLevelWarning message to the logs. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="message">The log message.    </param>
		public void Warning(string message)
		{
			linphone_logging_service_warning(nativePtr, message);
			
			
						
		}
	}
	/// <summary>
	/// A <see cref="Linphone.MagicSearch">Linphone.MagicSearch</see> is used to do
	/// specifics searchs. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class MagicSearch : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_magic_search_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_magic_search_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_magic_search_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private MagicSearchListener listener;

		public MagicSearchListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_magic_search_cbs(linphone_factory_get());
					listener = fromNativePtr<MagicSearchListener>(nativeListener, false, true);
					linphone_magic_search_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_magic_search_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_magic_search_get_delimiter(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_set_delimiter(IntPtr thiz, string delimiter);

		/// <summary>
		/// Get the delimiter used for the search. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the delimiter used to find matched filter word    </returns>
		public string Delimiter
		{
			get
			{
				IntPtr stringPtr = linphone_magic_search_get_delimiter(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_magic_search_set_delimiter(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_magic_search_get_last_search(IntPtr thiz);

		/// <summary>
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>sorted list of         </returns>
		public IEnumerable<Linphone.SearchResult> LastSearch
		{
			get
			{
				return MarshalBctbxList<Linphone.SearchResult>(linphone_magic_search_get_last_search(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_magic_search_get_limited_search(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_set_limited_search(IntPtr thiz, char limited);

		/// <summary>
		/// Return whether or not the search is limited. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the search is limited, false otherwise </returns>
		public bool LimitedSearch
		{
			get
			{
				return linphone_magic_search_get_limited_search(nativePtr) != 0;
			}
			set
			{
				linphone_magic_search_set_limited_search(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_magic_search_get_max_weight(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_set_max_weight(IntPtr thiz, uint weight);

		/// <summary>
		/// Get the maximum value used to calculate the weight in search. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the maximum value used to calculate the weight in search </returns>
		public uint MaxWeight
		{
			get
			{
				return linphone_magic_search_get_max_weight(nativePtr);
			}
			set
			{
				linphone_magic_search_set_max_weight(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_magic_search_get_min_weight(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_set_min_weight(IntPtr thiz, uint weight);

		/// <summary>
		/// Get the minimum value used to calculate the weight in search. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the minimum value used to calculate the weight in search </returns>
		public uint MinWeight
		{
			get
			{
				return linphone_magic_search_get_min_weight(nativePtr);
			}
			set
			{
				linphone_magic_search_set_min_weight(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_magic_search_get_search_limit(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_set_search_limit(IntPtr thiz, uint limit);

		/// <summary>
		/// Get the number of maximum search result the search will return. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the number of the maximum <see cref="Linphone.SearchResult">
		/// Linphone.SearchResult</see> which will be returned </returns>
		public uint SearchLimit
		{
			get
			{
				return linphone_magic_search_get_search_limit(nativePtr);
			}
			set
			{
				linphone_magic_search_set_search_limit(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_magic_search_get_use_delimiter(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_set_use_delimiter(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether the delimiter is being used for the search. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>if the delimiter search is used </returns>
		public bool UseDelimiter
		{
			get
			{
				return linphone_magic_search_get_use_delimiter(nativePtr) != 0;
			}
			set
			{
				linphone_magic_search_set_use_delimiter(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_magic_search_get_contact_list_from_filter(IntPtr thiz, string filter, string domain);

		/// <summary>
		/// Create a sorted list of SearchResult from SipUri, Contact name, Contact
		/// displayname, Contact phone number, which match with a filter word The last item
		/// list will be an address formed with &quot;filter&quot; if a proxy config exist
		/// During the first search, a cache is created and used for the next search Use
		/// <see cref="Linphone.MagicSearch.ResetSearchCache()">
		/// Linphone.MagicSearch.ResetSearchCache()</see> to begin a new search. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filter">word we search    </param>
		/// <param name="domain">domain which we want to search only   
		/// </param>
		/// <returns>sorted list of         </returns>
		/// deprecated : 22/03/2022 Use <see cref="Linphone.MagicSearch.Contacts">
		/// Linphone.MagicSearch.Contacts</see> instead. 
		public IEnumerable<Linphone.SearchResult> GetContactListFromFilter(string filter, string domain)
		{
			IEnumerable<Linphone.SearchResult> returnVal = MarshalBctbxList<Linphone.SearchResult>(linphone_magic_search_get_contact_list_from_filter(nativePtr, filter, domain), false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_get_contact_list_from_filter_async(IntPtr thiz, string filter, string domain);

		/// <summary>
		/// Create a sorted list of SearchResult asynchronous from SipUri, Contact name,
		/// Contact displayname, Contact phone number, which match with a filter word The
		/// last item list will be an address formed with &quot;filter&quot; if a proxy
		/// config exist During the first search, a cache is created and used for the next
		/// search Use <see cref="Linphone.MagicSearch.ResetSearchCache()">
		/// Linphone.MagicSearch.ResetSearchCache()</see> to begin a new search. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="filter">word we search    </param>
		/// <param name="domain">domain which we want to search only    null or
		/// &quot;&quot; for searching in all contact &quot;*&quot; for searching in
		/// contact with sip SipUri &quot;yourdomain&quot; for searching in contact from
		/// &quot;yourdomain&quot; domain </param>
		/// deprecated : 22/03/2022 Use <see cref="Linphone.MagicSearch.ContactsAsync">
		/// Linphone.MagicSearch.ContactsAsync</see> instead. 
		public void GetContactListFromFilterAsync(string filter, string domain)
		{
			linphone_magic_search_get_contact_list_from_filter_async(nativePtr, filter, domain);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_magic_search_get_contacts(IntPtr thiz, string filter, string domain, int sourceFlags);

		/// <summary>
		/// Create a sorted list of SearchResult which match with a filter word, from
		/// SipUri in this order : Contact&apos;s display name, address username, address
		/// domain and phone number. 
		/// <para>
		/// The last item list will be an address formed with &quot;filter&quot; if a proxy
		/// config exist and requested in sourceFlags During the first search, a cache is
		/// created and used for the next search Use <see cref="Linphone.MagicSearch.ResetSearchCache()">
		/// Linphone.MagicSearch.ResetSearchCache()</see> to begin a new search 
		/// </para>
		/// </summary>
		/// <param name="filter">word we search    </param>
		/// <param name="domain">domain which we want to search only   
		/// </param>
		/// <param name="sourceFlags">Flags that specify where to search : <see cref="Linphone.MagicSearchSource">
		/// Linphone.MagicSearchSource</see> </param>
		/// <returns>sorted list of         </returns>
		/// deprecated : 08/04/2022 Use <see cref="Linphone.MagicSearch.ContactsList">
		/// Linphone.MagicSearch.ContactsList</see> instead. 
		public IEnumerable<Linphone.SearchResult> GetContacts(string filter, string domain, int sourceFlags)
		{
			IEnumerable<Linphone.SearchResult> returnVal = MarshalBctbxList<Linphone.SearchResult>(linphone_magic_search_get_contacts(nativePtr, filter, domain, sourceFlags), false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_get_contacts_async(IntPtr thiz, string filter, string domain, int sourceFlags);

		/// <summary>
		/// This is the asynchronous version of <see cref="Linphone.MagicSearch.Contacts">
		/// Linphone.MagicSearch.Contacts</see>. 
		/// <para>
		/// Create a sorted list of SearchResult which match with a filter word, from
		/// SipUri in this order : Contact&apos;s display name, address username, address
		/// domain and phone number. The last item list will be an address formed with
		/// &quot;filter&quot; if a proxy config exist and requested in sourceFlags During
		/// the first search, a cache is created and used for the next search Use <see cref="Linphone.MagicSearch.ResetSearchCache()">
		/// Linphone.MagicSearch.ResetSearchCache()</see> to begin a new search 
		/// </para>
		/// </summary>
		/// <param name="filter">word we search    </param>
		/// <param name="domain">domain which we want to search only   
		/// </param>
		/// <param name="sourceFlags">Flags that specify where to search : <see cref="Linphone.MagicSearchSource">
		/// Linphone.MagicSearchSource</see> </param>
		/// deprecated : 08/04/2022 Use <see cref="Linphone.MagicSearch.ContactsListAsync">
		/// Linphone.MagicSearch.ContactsListAsync</see> instead. 
		public void GetContactsAsync(string filter, string domain, int sourceFlags)
		{
			linphone_magic_search_get_contacts_async(nativePtr, filter, domain, sourceFlags);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_magic_search_get_contacts_list(IntPtr thiz, string filter, string domain, int sourceFlags, int aggregation);

		/// <summary>
		/// Create a sorted list of SearchResult which match with a filter word, from
		/// SipUri in this order : Contact&apos;s display name, address username, address
		/// domain and phone number. 
		/// <para>
		/// The last item list will be an address formed with &quot;filter&quot; if a proxy
		/// config exist and requested in sourceFlags During the first search, a cache is
		/// created and used for the next search Use <see cref="Linphone.MagicSearch.ResetSearchCache()">
		/// Linphone.MagicSearch.ResetSearchCache()</see> to begin a new search 
		/// </para>
		/// </summary>
		/// <param name="filter">word we search    </param>
		/// <param name="domain">domain which we want to search only   
		/// </param>
		/// <param name="sourceFlags">Flags that specify where to search : <see cref="Linphone.MagicSearchSource">
		/// Linphone.MagicSearchSource</see> </param>
		/// <param name="aggregation">a <see cref="Linphone.MagicSearchAggregation">
		/// Linphone.MagicSearchAggregation</see> mode to indicate how to merge results
		/// </param>
		/// <returns>sorted list of         </returns>
		public IEnumerable<Linphone.SearchResult> GetContactsList(string filter, string domain, int sourceFlags, Linphone.MagicSearchAggregation aggregation)
		{
			IEnumerable<Linphone.SearchResult> returnVal = MarshalBctbxList<Linphone.SearchResult>(linphone_magic_search_get_contacts_list(nativePtr, filter, domain, sourceFlags, (int)aggregation), false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_get_contacts_list_async(IntPtr thiz, string filter, string domain, int sourceFlags, int aggregation);

		/// <summary>
		/// This is the asynchronous version of <see cref="Linphone.MagicSearch.Contacts">
		/// Linphone.MagicSearch.Contacts</see>. 
		/// <para>
		/// Create a sorted list of SearchResult which match with a filter word, from
		/// SipUri in this order : Contact&apos;s display name, address username, address
		/// domain and phone number. The last item list will be an address formed with
		/// &quot;filter&quot; if a proxy config exist and requested in sourceFlags During
		/// the first search, a cache is created and used for the next search Use <see cref="Linphone.MagicSearch.ResetSearchCache()">
		/// Linphone.MagicSearch.ResetSearchCache()</see> to begin a new search 
		/// </para>
		/// </summary>
		/// <param name="filter">word we search    </param>
		/// <param name="domain">domain which we want to search only   
		/// </param>
		/// <param name="sourceFlags">Flags that specify where to search : <see cref="Linphone.MagicSearchSource">
		/// Linphone.MagicSearchSource</see> </param>
		/// <param name="aggregation">a <see cref="Linphone.MagicSearchAggregation">
		/// Linphone.MagicSearchAggregation</see> mode to indicate how to merge results
		/// </param>
		public void GetContactsListAsync(string filter, string domain, int sourceFlags, Linphone.MagicSearchAggregation aggregation)
		{
			linphone_magic_search_get_contacts_list_async(nativePtr, filter, domain, sourceFlags, (int)aggregation);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_magic_search_reset_search_cache(IntPtr thiz);

		/// <summary>
		/// Reset the cache to begin a new search. 
		/// <para>
		/// </para>
		/// </summary>
		public void ResetSearchCache()
		{
			linphone_magic_search_reset_search_cache(nativePtr);
			
			
						
		}
	}
	/// <summary>
	/// Policy to use to pass through NATs/firewalls. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class NatPolicy : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_nat_policy_get_core(IntPtr thiz);

		/// <summary>
		/// Returns the <see cref="Linphone.Core">Linphone.Core</see> object managing this
		/// nat policy, if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Core">Linphone.Core</see> object associated.  
		///  </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_nat_policy_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_ice_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_ice(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether ICE is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether ICE is enabled. </returns>
		public bool IceEnabled
		{
			get
			{
				return linphone_nat_policy_ice_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_ice(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_nat_policy_get_nat_v4_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_set_nat_v4_address(IntPtr thiz, string v4Address);

		/// <summary>
		/// Get the mandatory v4 IP address to use with this NAT policy as server-reflexive
		/// candidate for ICE. 
		/// <para>
		/// Used when STUN or TURN are enabled. 
		/// </para>
		/// </summary>
		/// <returns>the nat v4 address.    </returns>
		public string NatV4Address
		{
			get
			{
				IntPtr stringPtr = linphone_nat_policy_get_nat_v4_address(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_nat_policy_set_nat_v4_address(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_nat_policy_get_nat_v6_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_set_nat_v6_address(IntPtr thiz, string v4Address);

		/// <summary>
		/// Get the mandatory v6 IP address to use with this NAT policy as server-reflexive
		/// candidate for ICE. 
		/// <para>
		/// Used when STUN or TURN are enabled. 
		/// </para>
		/// </summary>
		/// <returns>the nat v4 address.    </returns>
		public string NatV6Address
		{
			get
			{
				IntPtr stringPtr = linphone_nat_policy_get_nat_v6_address(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_nat_policy_set_nat_v6_address(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_stun_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_stun(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether STUN is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether STUN is enabled. </returns>
		public bool StunEnabled
		{
			get
			{
				return linphone_nat_policy_stun_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_stun(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_nat_policy_get_stun_server(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_set_stun_server(IntPtr thiz, string stunServer);

		/// <summary>
		/// Get the STUN/TURN server to use with this NAT policy. 
		/// <para>
		/// Used when STUN or TURN are enabled. 
		/// </para>
		/// </summary>
		/// <returns>The STUN server used by this NAT policy.    </returns>
		public string StunServer
		{
			get
			{
				IntPtr stringPtr = linphone_nat_policy_get_stun_server(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_nat_policy_set_stun_server(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_nat_policy_get_stun_server_username(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_set_stun_server_username(IntPtr thiz, string username);

		/// <summary>
		/// Get the username used to authenticate with the STUN/TURN server. 
		/// <para>
		/// The authentication will search for a <see cref="Linphone.AuthInfo">
		/// Linphone.AuthInfo</see> with this username. If it is not set the username of
		/// the currently used <see cref="Linphone.ProxyConfig">Linphone.ProxyConfig</see>
		/// is used to search for a LinphoneAuthInfo. 
		/// </para>
		/// </summary>
		/// <returns>The username used to authenticate with the STUN/TURN server.   
		/// </returns>
		public string StunServerUsername
		{
			get
			{
				IntPtr stringPtr = linphone_nat_policy_get_stun_server_username(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_nat_policy_set_stun_server_username(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_tcp_turn_transport_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_tcp_turn_transport(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether TCP TURN transport is enabled. 
		/// <para>
		/// Used when TURN is enabled. 
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether TCP TURN transport is enabled. </returns>
		public bool TcpTurnTransportEnabled
		{
			get
			{
				return linphone_nat_policy_tcp_turn_transport_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_tcp_turn_transport(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_tls_turn_transport_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_tls_turn_transport(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether TLS TURN transport is enabled. 
		/// <para>
		/// Used when TURN is enabled. 
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether TLS TURN transport is enabled. </returns>
		public bool TlsTurnTransportEnabled
		{
			get
			{
				return linphone_nat_policy_tls_turn_transport_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_tls_turn_transport(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_turn_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_turn(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether TURN is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether TURN is enabled. </returns>
		public bool TurnEnabled
		{
			get
			{
				return linphone_nat_policy_turn_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_turn(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_udp_turn_transport_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_udp_turn_transport(IntPtr thiz, char enable);

		/// <summary>
		/// Tells whether UDP TURN transport is enabled. 
		/// <para>
		/// Used when TURN is enabled. 
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether UDP TURN transport is enabled. </returns>
		public bool UdpTurnTransportEnabled
		{
			get
			{
				return linphone_nat_policy_udp_turn_transport_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_udp_turn_transport(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_nat_policy_upnp_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_enable_upnp(IntPtr thiz, char enable);

		/// <summary>
		/// Tell whether uPnP is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Boolean value telling whether uPnP is enabled. </returns>
		public bool UpnpEnabled
		{
			get
			{
				return linphone_nat_policy_upnp_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_nat_policy_enable_upnp(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_clear(IntPtr thiz);

		/// <summary>
		/// Clear a NAT policy (deactivate all protocols and unset the STUN server). 
		/// <para>
		/// </para>
		/// </summary>
		public void Clear()
		{
			linphone_nat_policy_clear(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_nat_policy_clone(IntPtr thiz);

		/// <summary>
		/// Clone an existing <see cref="Linphone.NatPolicy">Linphone.NatPolicy</see>
		/// object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A clone of the original <see cref="Linphone.NatPolicy">
		/// Linphone.NatPolicy</see> object.    </returns>
		public Linphone.NatPolicy Clone()
		{
			IntPtr ptr = linphone_nat_policy_clone(nativePtr);
			Linphone.NatPolicy returnVal = fromNativePtr<Linphone.NatPolicy>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_nat_policy_resolve_stun_server(IntPtr thiz);

		/// <summary>
		/// Start a STUN server DNS resolution. 
		/// <para>
		/// </para>
		/// </summary>
		public void ResolveStunServer()
		{
			linphone_nat_policy_resolve_stun_server(nativePtr);
			
			
						
		}
	}
	/// <summary>
	/// Identifies a member of a <see cref="Linphone.Conference">
	/// Linphone.Conference</see> or <see cref="Linphone.ChatRoom">
	/// Linphone.ChatRoom</see>. 
	/// <para>
	/// A participant is identified by it&apos;s SIP address. It can have many <see cref="Linphone.ParticipantDevice">
	/// Linphone.ParticipantDevice</see>. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Participant : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_get_address(IntPtr thiz);

		/// <summary>
		/// Get the address of a conference participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Address">Linphone.Address</see> of the
		/// participant    </returns>
		public Linphone.Address Address
		{
			get
			{
				IntPtr ptr = linphone_participant_get_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_participant_get_creation_time(IntPtr thiz);

		/// <summary>
		/// Get the timestamp of the creation of the participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>time of creation of the participant as returned by time(nullptr). For
		/// UNIX based systems it is the number of seconds since 00:00hours of the 1st of
		/// January 1970 </returns>
		public long CreationTime
		{
			get
			{
				return linphone_participant_get_creation_time(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_get_devices(IntPtr thiz);

		/// <summary>
		/// Gets the list of devices from a chat room&apos;s participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>List of devices.         </returns>
		public IEnumerable<Linphone.ParticipantDevice> Devices
		{
			get
			{
				return MarshalBctbxList<Linphone.ParticipantDevice>(linphone_participant_get_devices(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_participant_is_admin(IntPtr thiz);

		/// <summary>
		/// Tells whether a conference participant is an administrator of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether the participant is an administrator
		/// </returns>
		public bool IsAdmin
		{
			get
			{
				return linphone_participant_is_admin(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_participant_is_focus(IntPtr thiz);

		/// <summary>
		/// Tells whether a conference participant is the focus of the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether the participant is a focus of a
		/// conference </returns>
		public bool IsFocus
		{
			get
			{
				return linphone_participant_is_focus(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ParticipantRole linphone_participant_get_role(IntPtr thiz);

		/// <summary>
		/// Get the role of the participant within the conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>role within the conference <see cref="Linphone.ParticipantRole">
		/// Linphone.ParticipantRole</see> </returns>
		public Linphone.ParticipantRole Role
		{
			get
			{
				return linphone_participant_get_role(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomSecurityLevel linphone_participant_get_security_level(IntPtr thiz);

		/// <summary>
		/// Get the security level of a participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.ChatRoomSecurityLevel">
		/// Linphone.ChatRoomSecurityLevel</see> of the participant </returns>
		public Linphone.ChatRoomSecurityLevel SecurityLevel
		{
			get
			{
				return linphone_participant_get_security_level(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_find_device_2(IntPtr thiz, IntPtr call);

		/// <summary>
		/// Find a device in the list of devices from a chat room&apos;s participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="call">A <see cref="Linphone.Call">Linphone.Call</see> object   
		/// </param>
		/// <returns>a <see cref="Linphone.ParticipantDevice">
		/// Linphone.ParticipantDevice</see> or null if not found.    </returns>
		public Linphone.ParticipantDevice FindDevice(Linphone.Call call)
		{
			IntPtr ptr = linphone_participant_find_device_2(nativePtr, call != null ? call.nativePtr : IntPtr.Zero);
			Linphone.ParticipantDevice returnVal = fromNativePtr<Linphone.ParticipantDevice>(ptr, true);
			
			GC.KeepAlive(call);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_find_device(IntPtr thiz, IntPtr address);

		/// <summary>
		/// Find a device in the list of devices from a chat room&apos;s participant. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="address">A <see cref="Linphone.Address">Linphone.Address</see>
		/// object    </param>
		/// <returns>a <see cref="Linphone.ParticipantDevice">
		/// Linphone.ParticipantDevice</see> or null if not found.    </returns>
		public Linphone.ParticipantDevice FindDevice(Linphone.Address address)
		{
			IntPtr ptr = linphone_participant_find_device(nativePtr, address != null ? address.nativePtr : IntPtr.Zero);
			Linphone.ParticipantDevice returnVal = fromNativePtr<Linphone.ParticipantDevice>(ptr, true);
			
			GC.KeepAlive(address);
			return returnVal;
		}
	}
	/// <summary>
	/// This object represents a unique device for a member of a <see cref="Linphone.Conference">
	/// Linphone.Conference</see> or <see cref="Linphone.ChatRoom">
	/// Linphone.ChatRoom</see>. 
	/// <para>
	/// Devices are identified by the gruu parameter inside the <see cref="Linphone.Address">
	/// Linphone.Address</see> which can be obtained by <see cref="Linphone.ParticipantDevice.Address">
	/// Linphone.ParticipantDevice.Address</see>. It is specially usefull to know the
	/// security level of each device inside an end-to-end encrypted <see cref="Linphone.ChatRoom">
	/// Linphone.ChatRoom</see>.
	/// You can get a list of all <see cref="Linphone.ParticipantDevice">
	/// Linphone.ParticipantDevice</see> using <see cref="Linphone.Participant.Devices">
	/// Linphone.Participant.Devices</see>. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ParticipantDevice : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_participant_device_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private ParticipantDeviceListener listener;

		public ParticipantDeviceListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_participant_device_cbs(linphone_factory_get());
					listener = fromNativePtr<ParticipantDeviceListener>(nativeListener, false, true);
					linphone_participant_device_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_participant_device_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_get_address(IntPtr thiz);

		/// <summary>
		/// Get the address of a participant&apos;s device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Address">Linphone.Address</see> of the
		/// participant&apos;s device    </returns>
		public Linphone.Address Address
		{
			get
			{
				IntPtr ptr = linphone_participant_device_get_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ParticipantDeviceDisconnectionMethod linphone_participant_device_get_disconnection_method(IntPtr thiz);

		/// <summary>
		/// Get the disconnection method. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>disconnection method <see cref="Linphone.ParticipantDeviceDisconnectionMethod">
		/// Linphone.ParticipantDeviceDisconnectionMethod</see> </returns>
		public Linphone.ParticipantDeviceDisconnectionMethod DisconnectionMethod
		{
			get
			{
				return linphone_participant_device_get_disconnection_method(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_get_disconnection_reason(IntPtr thiz);

		/// <summary>
		/// Get the disconnection reason. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>disconnection reason    </returns>
		public string DisconnectionReason
		{
			get
			{
				IntPtr stringPtr = linphone_participant_device_get_disconnection_reason(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_participant_device_is_in_conference(IntPtr thiz);

		/// <summary>
		/// Return whether the participant device is in a conference or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a boolean to state whether the device is in a conference </returns>
		public bool IsInConference
		{
			get
			{
				return linphone_participant_device_is_in_conference(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_participant_device_get_is_muted(IntPtr thiz);

		/// <summary>
		/// Return whether the participant device is muted or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the participant device is muted, false otherwise. </returns>
		public bool IsMuted
		{
			get
			{
				return linphone_participant_device_get_is_muted(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_participant_device_get_is_speaking(IntPtr thiz);

		/// <summary>
		/// Return whether the participant device is speaking or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the participant device is speaking, false otherwise. </returns>
		public bool IsSpeaking
		{
			get
			{
				return linphone_participant_device_get_is_speaking(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ParticipantDeviceJoiningMethod linphone_participant_device_get_joining_method(IntPtr thiz);

		/// <summary>
		/// Get the joining method or it the device is the focus owner. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>joining method or focus owner <see cref="Linphone.ParticipantDeviceJoiningMethod">
		/// Linphone.ParticipantDeviceJoiningMethod</see> </returns>
		public Linphone.ParticipantDeviceJoiningMethod JoiningMethod
		{
			get
			{
				return linphone_participant_device_get_joining_method(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_get_name(IntPtr thiz);

		/// <summary>
		/// Return the name of the device or null. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the name of the device or null.    </returns>
		public string Name
		{
			get
			{
				IntPtr stringPtr = linphone_participant_device_get_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_get_native_video_window_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_participant_device_set_native_video_window_id(IntPtr thiz, IntPtr windowId);

		/// <summary>
		/// Get window ID. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the window ID of the device    </returns>
		public IntPtr NativeVideoWindowId
		{
			get
			{
				return linphone_participant_device_get_native_video_window_id(nativePtr);
			}
			set
			{
				linphone_participant_device_set_native_video_window_id(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatRoomSecurityLevel linphone_participant_device_get_security_level(IntPtr thiz);

		/// <summary>
		/// Get the security level of a participant&apos;s device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.ChatRoomSecurityLevel">
		/// Linphone.ChatRoomSecurityLevel</see> of the device </returns>
		public Linphone.ChatRoomSecurityLevel SecurityLevel
		{
			get
			{
				return linphone_participant_device_get_security_level(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ParticipantDeviceState linphone_participant_device_get_state(IntPtr thiz);

		/// <summary>
		/// Get the state of a participant device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.ParticipantDeviceState">
		/// Linphone.ParticipantDeviceState</see> of the device </returns>
		public Linphone.ParticipantDeviceState State
		{
			get
			{
				return linphone_participant_device_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_participant_device_get_time_of_disconnection(IntPtr thiz);

		/// <summary>
		/// Get the timestamp the device left a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>time of disconnection a conference as returned by time(nullptr). For
		/// UNIX based systems it is the number of seconds since 00:00hours of the 1st of
		/// January 1970 </returns>
		public long TimeOfDisconnection
		{
			get
			{
				return linphone_participant_device_get_time_of_disconnection(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_participant_device_get_time_of_joining(IntPtr thiz);

		/// <summary>
		/// Get the timestamp the device joined a conference. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>time of joining a conference as returned by time(nullptr). For UNIX
		/// based systems it is the number of seconds since 00:00hours of the 1st of
		/// January 1970 </returns>
		public long TimeOfJoining
		{
			get
			{
				return linphone_participant_device_get_time_of_joining(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_create_native_video_window_id(IntPtr thiz);

		/// <summary>
		/// Create a window ID and return it. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the window ID of the device    </returns>
		public IntPtr CreateNativeVideoWindowId()
		{
			IntPtr returnVal = linphone_participant_device_create_native_video_window_id(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_participant_device_get_ssrc(IntPtr thiz, int streamType);

		/// <summary>
		/// Get the audio stream SSRC of the device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="streamType">A <see cref="Linphone.StreamType">
		/// Linphone.StreamType</see> </param>
		/// <returns>the audio stream SSRC of the device </returns>
		public uint GetSsrc(Linphone.StreamType streamType)
		{
			uint returnVal = linphone_participant_device_get_ssrc(nativePtr, (int)streamType);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_participant_device_get_stream_availability(IntPtr thiz, int streamType);

		/// <summary>
		/// Get the stream availability of the device. 
		/// <para>
		/// The availability information represents whether a given stream type is
		/// currently available to be presented in the conference for a <see cref="Linphone.ParticipantDevice">
		/// Linphone.ParticipantDevice</see> 
		/// </para>
		/// </summary>
		/// <param name="streamType">A <see cref="Linphone.StreamType">
		/// Linphone.StreamType</see> </param>
		/// <returns>true if the stream of type stream_type is available for device, false
		/// otherwise </returns>
		public bool GetStreamAvailability(Linphone.StreamType streamType)
		{
			bool returnVal = linphone_participant_device_get_stream_availability(nativePtr, (int)streamType) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.MediaDirection linphone_participant_device_get_stream_capability(IntPtr thiz, int streamType);

		/// <summary>
		/// Get the stream capability of the device. 
		/// <para>
		/// The capability information represents the capability for the #ParticipantDevice
		/// to handle a given stream type (audio, video or text). 
		/// </para>
		/// </summary>
		/// <param name="streamType">A <see cref="Linphone.StreamType">
		/// Linphone.StreamType</see> </param>
		/// <returns>the capability of stream of type stream_type of the device <see cref="Linphone.MediaDirection">
		/// Linphone.MediaDirection</see> </returns>
		public Linphone.MediaDirection GetStreamCapability(Linphone.StreamType streamType)
		{
			Linphone.MediaDirection returnVal = linphone_participant_device_get_stream_capability(nativePtr, (int)streamType);
			
			
						return returnVal;
		}
	}
	/// <summary>
	/// This object is only used on server side for <see cref="Linphone.ChatRoom">
	/// Linphone.ChatRoom</see> with <see cref="Linphone.ChatRoomBackend.FlexisipChat">
	/// Linphone.ChatRoomBackend.FlexisipChat</see> backend. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ParticipantDeviceIdentity : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_identity_get_address(IntPtr thiz);

		/// <summary>
		/// Get the address of the participant device. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the address.    </returns>
		public Linphone.Address Address
		{
			get
			{
				IntPtr ptr = linphone_participant_device_identity_get_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_identity_get_capability_descriptor(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_participant_device_identity_set_capability_descriptor(IntPtr thiz, string capabilityDescriptor);

		/// <summary>
		/// Get the capability descriptor (currently +org.linphone.specs value) for this
		/// participant device identity. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the capability descriptor string. </returns>
		/// deprecated : 12/06/2023 Use <see cref="Linphone.ParticipantDeviceIdentity.CapabilityDescriptorList">
		/// Linphone.ParticipantDeviceIdentity.CapabilityDescriptorList</see> instead
		public string CapabilityDescriptor
		{
			get
			{
				IntPtr stringPtr = linphone_participant_device_identity_get_capability_descriptor(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_participant_device_identity_set_capability_descriptor(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_participant_device_identity_set_capability_descriptor_2(IntPtr thiz, IntPtr capabilityDescriptorList);

		/// <summary>
		/// Set the capability descriptor (currently +org.linphone.specs value) for this
		/// participant device identity. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capabilityDescriptorList">the capability descriptor list.     
		/// </param>
		public IEnumerable<string> CapabilityDescriptor2
		{
			set
			{
				linphone_participant_device_identity_set_capability_descriptor_2(nativePtr, StringArrayToBctbxList(value));
				CleanStringArrayPtrs();
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_device_identity_get_capability_descriptor_list(IntPtr thiz);

		/// <summary>
		/// Get the capability descriptor (currently +org.linphone.specs value) for this
		/// participant device identity. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the capability descriptor list.      </returns>
		public IEnumerable<string> CapabilityDescriptorList
		{
			get
			{
				return MarshalStringArray(linphone_participant_device_identity_get_capability_descriptor_list(nativePtr));
			}
		}
	}
	/// <summary>
	/// This object represents the delivery/display state of a given chat message for a
	/// given participant. 
	/// <para>
	/// It also contains a timestamp at which this participant state has changed.
	/// Use <see cref="Linphone.ChatMessage.ParticipantsByImdnState">
	/// Linphone.ChatMessage.ParticipantsByImdnState</see> to get all <see cref="Linphone.ParticipantImdnState">
	/// Linphone.ParticipantImdnState</see> for a given state. From there use <see cref="Linphone.ParticipantImdnState.Participant">
	/// Linphone.ParticipantImdnState.Participant</see> to get the <see cref="Linphone.Participant">
	/// Linphone.Participant</see> object if you need it. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ParticipantImdnState : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_imdn_state_get_participant(IntPtr thiz);

		/// <summary>
		/// Get the participant concerned by a LinphoneParticipantImdnState. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Participant">Linphone.Participant</see>
		/// concerned by the LinphoneParticipantImdnState    </returns>
		public Linphone.Participant Participant
		{
			get
			{
				IntPtr ptr = linphone_participant_imdn_state_get_participant(nativePtr);
				Linphone.Participant obj = fromNativePtr<Linphone.Participant>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ChatMessageState linphone_participant_imdn_state_get_state(IntPtr thiz);

		/// <summary>
		/// Get the chat message state the participant is in. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.ChatMessageState">
		/// Linphone.ChatMessageState</see> the participant is in </returns>
		public Linphone.ChatMessageState State
		{
			get
			{
				return linphone_participant_imdn_state_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_participant_imdn_state_get_state_change_time(IntPtr thiz);

		/// <summary>
		/// Get the timestamp at which a participant has reached the state described by a
		/// LinphoneParticipantImdnState. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The timestamp at which the participant has reached the state described
		/// in the LinphoneParticipantImdnState </returns>
		public long StateChangeTime
		{
			get
			{
				return linphone_participant_imdn_state_get_state_change_time(nativePtr);
			}
		}
	}
	/// <summary>
	/// Object defining all information related to a participant. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class ParticipantInfo : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_info_get_address(IntPtr thiz);

		/// <summary>
		/// Get the address of the object <see cref="Linphone.ParticipantInfo">
		/// Linphone.ParticipantInfo</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Address">Linphone.Address</see> of the <see cref="Linphone.ParticipantInfo">
		/// Linphone.ParticipantInfo</see> object.    </returns>
		public Linphone.Address Address
		{
			get
			{
				IntPtr ptr = linphone_participant_info_get_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ParticipantRole linphone_participant_info_get_role(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_participant_info_set_role(IntPtr thiz, int role);

		/// <summary>
		/// Get the role of the object <see cref="Linphone.ParticipantInfo">
		/// Linphone.ParticipantInfo</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.ParticipantRole">
		/// Linphone.ParticipantRole</see> of the <see cref="Linphone.ParticipantInfo">
		/// Linphone.ParticipantInfo</see> object.    </returns>
		public Linphone.ParticipantRole Role
		{
			get
			{
				return linphone_participant_info_get_role(nativePtr);
			}
			set
			{
				linphone_participant_info_set_role(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_participant_info_add_parameter(IntPtr thiz, string name, string val);

		/// <summary>
		/// Set the a custom parameter to object <see cref="Linphone.ParticipantInfo">
		/// Linphone.ParticipantInfo</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the name of the parameter.    </param>
		/// <param name="val">the value of the parameter.    </param>
		public void AddParameter(string name, string val)
		{
			linphone_participant_info_add_parameter(nativePtr, name, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_info_clone(IntPtr thiz);

		/// <summary>
		/// Clone an object <see cref="Linphone.ParticipantInfo">
		/// Linphone.ParticipantInfo</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the cloned <see cref="Linphone.ParticipantInfo">
		/// Linphone.ParticipantInfo</see> object.    </returns>
		public Linphone.ParticipantInfo Clone()
		{
			IntPtr ptr = linphone_participant_info_clone(nativePtr);
			Linphone.ParticipantInfo returnVal = fromNativePtr<Linphone.ParticipantInfo>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_participant_info_get_parameter_value(IntPtr thiz, string name);

		/// <summary>
		/// Get the value of a custom parameter of the object <see cref="Linphone.ParticipantInfo">
		/// Linphone.ParticipantInfo</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the name of the parameter.    </param>
		/// <returns>value the value of the parameter.    </returns>
		public string GetParameterValue(string name)
		{
			IntPtr stringPtr = linphone_participant_info_get_parameter_value(nativePtr, name);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_participant_info_has_parameter(IntPtr thiz, string name);

		/// <summary>
		/// Find whether a <see cref="Linphone.ParticipantInfo">
		/// Linphone.ParticipantInfo</see> has a parameter. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the name of the parameter.    </param>
		/// <returns>true if the parameter is present, false otherwise </returns>
		public bool HasParameter(string name)
		{
			bool returnVal = linphone_participant_info_has_parameter(nativePtr, name) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_participant_info_remove_parameter(IntPtr thiz, string name);

		/// <summary>
		/// Find the value of a custom parameter of the object <see cref="Linphone.ParticipantInfo">
		/// Linphone.ParticipantInfo</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the name of the parameter.    </param>
		public void RemoveParameter(string name)
		{
			linphone_participant_info_remove_parameter(nativePtr, name);
			
			
						
		}
	}
	/// <summary>
	/// Object representing an RTP payload type. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PayloadType : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_payload_type_get_channels(IntPtr thiz);

		/// <summary>
		/// Get the number of channels. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The number of channels. </returns>
		public int Channels
		{
			get
			{
				return linphone_payload_type_get_channels(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_payload_type_get_clock_rate(IntPtr thiz);

		/// <summary>
		/// Get the clock rate of a payload type. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The clock rate in Hz. </returns>
		public int ClockRate
		{
			get
			{
				return linphone_payload_type_get_clock_rate(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_payload_type_get_description(IntPtr thiz);

		/// <summary>
		/// Return a string describing a payload type. 
		/// <para>
		/// The format of the string is
		/// &lt;mime_type&gt;/&lt;clock_rate&gt;/&lt;channels&gt;. 
		/// </para>
		/// </summary>
		/// <returns>The description of the payload type.    </returns>
		public string Description
		{
			get
			{
				IntPtr stringPtr = linphone_payload_type_get_description(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_payload_type_get_encoder_description(IntPtr thiz);

		/// <summary>
		/// Get a description of the encoder used to provide a payload type. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The description of the encoder. Can be null if the payload type is not
		/// supported by Mediastreamer2.    </returns>
		public string EncoderDescription
		{
			get
			{
				IntPtr stringPtr = linphone_payload_type_get_encoder_description(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_payload_type_is_usable(IntPtr thiz);

		/// <summary>
		/// Check whether the payload is usable according the bandwidth targets set in the
		/// core. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the payload type is usable. </returns>
		public bool IsUsable
		{
			get
			{
				return linphone_payload_type_is_usable(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_payload_type_is_vbr(IntPtr thiz);

		/// <summary>
		/// Tells whether the specified payload type represents a variable bitrate codec. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if the payload type represents a VBR codec, false instead.
		/// </returns>
		public bool IsVbr
		{
			get
			{
				return linphone_payload_type_is_vbr(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_payload_type_get_mime_type(IntPtr thiz);

		/// <summary>
		/// Get the mime type. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The mime type.    </returns>
		public string MimeType
		{
			get
			{
				IntPtr stringPtr = linphone_payload_type_get_mime_type(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_payload_type_get_normal_bitrate(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_payload_type_set_normal_bitrate(IntPtr thiz, int bitrate);

		/// <summary>
		/// Get the normal bitrate in bits/s. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The normal bitrate in bits/s or -1 if an error has occured. </returns>
		public int NormalBitrate
		{
			get
			{
				return linphone_payload_type_get_normal_bitrate(nativePtr);
			}
			set
			{
				linphone_payload_type_set_normal_bitrate(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_payload_type_get_number(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_payload_type_set_number(IntPtr thiz, int number);

		/// <summary>
		/// Returns the payload type number assigned for this codec. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The number of the payload type. </returns>
		public int Number
		{
			get
			{
				return linphone_payload_type_get_number(nativePtr);
			}
			set
			{
				linphone_payload_type_set_number(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_payload_type_get_recv_fmtp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_payload_type_set_recv_fmtp(IntPtr thiz, string recvFmtp);

		/// <summary>
		/// Get the format parameters for incoming streams. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The format parameters as string.    </returns>
		public string RecvFmtp
		{
			get
			{
				IntPtr stringPtr = linphone_payload_type_get_recv_fmtp(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_payload_type_set_recv_fmtp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_payload_type_get_send_fmtp(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_payload_type_set_send_fmtp(IntPtr thiz, string sendFmtp);

		/// <summary>
		/// Get the format parameters for outgoing streams. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The format parameters as string.    </returns>
		public string SendFmtp
		{
			get
			{
				IntPtr stringPtr = linphone_payload_type_get_send_fmtp(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_payload_type_set_send_fmtp(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_payload_type_get_type(IntPtr thiz);

		/// <summary>
		/// Get the type of a payload type. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The type of the payload e.g. PAYLOAD_AUDIO_CONTINUOUS or
		/// PAYLOAD_VIDEO. </returns>
		public int Type
		{
			get
			{
				return linphone_payload_type_get_type(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_payload_type_clone(IntPtr thiz);

		/// <summary>
		/// Instantiates a new payload type with values from source. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The newly created <see cref="Linphone.PayloadType">
		/// Linphone.PayloadType</see> object.    </returns>
		public Linphone.PayloadType Clone()
		{
			IntPtr ptr = linphone_payload_type_clone(nativePtr);
			Linphone.PayloadType returnVal = fromNativePtr<Linphone.PayloadType>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_payload_type_enable(IntPtr thiz, char enabled);

		/// <summary>
		/// Enable/disable a payload type. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="enabled">Set true for enabling and false for disabling. </param>
		/// <returns>0 for success, -1 for failure. </returns>
		public int Enable(bool enabled)
		{
			int returnVal = linphone_payload_type_enable(nativePtr, enabled ? (char)1 : (char)0);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_payload_type_enabled(IntPtr thiz);

		/// <summary>
		/// Check whether a palyoad type is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if enabled, false if disabled. </returns>
		public bool Enabled()
		{
			bool returnVal = linphone_payload_type_enabled(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_payload_type_weak_equals(IntPtr thiz, IntPtr otherPayloadType);

		/// <summary>
		/// Compare two payload types, and returns true if they are equal. 
		/// <para>
		/// Parameters (fmtp strings) are not compared, hence the name &apos;weak
		/// equals&apos;. 
		/// </para>
		/// </summary>
		/// <param name="otherPayloadType">another <see cref="Linphone.PayloadType">
		/// Linphone.PayloadType</see> object    </param>
		/// <returns>true if the payload types are &quot;almost&quot; equals. </returns>
		public bool WeakEquals(Linphone.PayloadType otherPayloadType)
		{
			bool returnVal = linphone_payload_type_weak_equals(nativePtr, otherPayloadType != null ? otherPayloadType.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			GC.KeepAlive(otherPayloadType);
			return returnVal;
		}
	}
	/// <summary>
	/// Player interface. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Player : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_player_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_player_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_player_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private PlayerListener listener;

		public PlayerListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_player_cbs(linphone_factory_get());
					listener = fromNativePtr<PlayerListener>(nativeListener, false, true);
					linphone_player_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_player_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_player_get_core(IntPtr thiz);

		/// <summary>
		/// Returns the <see cref="Linphone.Core">Linphone.Core</see> object managing this
		/// player&apos;s call, if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.Core">Linphone.Core</see> object associated   
		/// </returns>
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_player_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_player_get_current_position(IntPtr thiz);

		/// <summary>
		/// Get the current position in the opened file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current position in the opened file </returns>
		public int CurrentPosition
		{
			get
			{
				return linphone_player_get_current_position(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_player_get_duration(IntPtr thiz);

		/// <summary>
		/// Get the duration of the opened file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The duration of the opened file </returns>
		public int Duration
		{
			get
			{
				return linphone_player_get_duration(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_player_get_is_video_available(IntPtr thiz);

		/// <summary>
		/// Returns whether the file has video and if it can be displayed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if file has video and it can be displayed, false otherwise
		/// </returns>
		public bool IsVideoAvailable
		{
			get
			{
				return linphone_player_get_is_video_available(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.PlayerState linphone_player_get_state(IntPtr thiz);

		/// <summary>
		/// Get the current state of a player. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current <see cref="Linphone.PlayerState">
		/// Linphone.PlayerState</see> of the player. </returns>
		public Linphone.PlayerState State
		{
			get
			{
				return linphone_player_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_player_get_volume_gain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_player_set_volume_gain(IntPtr thiz, float gain);

		/// <summary>
		/// Get the volume gain of the player. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Percentage of the gain. Valid values are in [ 0.0 : 1.0 ]. </returns>
		public float VolumeGain
		{
			get
			{
				return linphone_player_get_volume_gain(nativePtr);
			}
			set
			{
				linphone_player_set_volume_gain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_player_set_window_id(IntPtr thiz, IntPtr windowId);

		/// <summary>
		/// Sets a window id to be used to display video if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="windowId">The window id pointer to use.    </param>
		public IntPtr WindowId
		{
			set
			{
				linphone_player_set_window_id(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_player_close(IntPtr thiz);

		/// <summary>
		/// Close the opened file. 
		/// <para>
		/// </para>
		/// </summary>
		public void Close()
		{
			linphone_player_close(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_player_create_window_id(IntPtr thiz);

		/// <summary>
		/// Create a window id to be used to display video if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>window_id The window id pointer to use.    </returns>
		public IntPtr CreateWindowId()
		{
			IntPtr returnVal = linphone_player_create_window_id(nativePtr);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_player_open(IntPtr thiz, string filename);

		/// <summary>
		/// Open a file for playing. 
		/// <para>
		/// Actually, only WAVE and MKV/MKA file formats are supported and a limited set of
		/// codecs depending of the selected format. Here are the list of working
		/// combinations:
		/// </para>
		/// </summary>
		/// <param name="filename">The path to the file to open    </param>
		public void Open(string filename)
		{
			int exception_result = linphone_player_open(nativePtr, filename);
			if (exception_result != 0) throw new LinphoneException("Open returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_player_pause(IntPtr thiz);

		/// <summary>
		/// Pause the playing of a file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 on success, a negative value otherwise </returns>
		public void Pause()
		{
			int exception_result = linphone_player_pause(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Pause returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_player_seek(IntPtr thiz, int timeMs);

		/// <summary>
		/// Seek in an opened file. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="timeMs">The time we want to go to in the file (in milliseconds).
		/// </param>
		/// <returns>0 on success, a negative value otherwise. </returns>
		public void Seek(int timeMs)
		{
			int exception_result = linphone_player_seek(nativePtr, timeMs);
			if (exception_result != 0) throw new LinphoneException("Seek returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_player_start(IntPtr thiz);

		/// <summary>
		/// Start playing a file that has been opened with <see cref="Linphone.Player.Open()">
		/// Linphone.Player.Open()</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 on success, a negative value otherwise </returns>
		public void Start()
		{
			int exception_result = linphone_player_start(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Start returned value" + exception_result);
			
						
		}
	}
	/// <summary>
	/// Presence activity type holding information about a presence activity. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PresenceActivity : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_activity_get_description(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_activity_set_description(IntPtr thiz, string description);

		/// <summary>
		/// Gets the description of a presence activity. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer to the description string of the presence activity, or null
		/// if no description is specified.    </returns>
		public string Description
		{
			get
			{
				IntPtr stringPtr = linphone_presence_activity_get_description(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_activity_set_description(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Description setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.PresenceActivityType linphone_presence_activity_get_type(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_activity_set_type(IntPtr thiz, int acttype);

		/// <summary>
		/// Gets the activity type of a presence activity. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.PresenceActivityType">
		/// Linphone.PresenceActivityType</see> of the activity. </returns>
		public Linphone.PresenceActivityType Type
		{
			get
			{
				return linphone_presence_activity_get_type(nativePtr);
			}
			set
			{
				int exception_result = linphone_presence_activity_set_type(nativePtr, (int)value);
				if (exception_result != 0) throw new LinphoneException("Type setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_activity_to_string(IntPtr thiz);

		/// <summary>
		/// Gets the string representation of a presence activity. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer a dynamically allocated string representing the given
		/// activity.      </returns>
		/// The returned string is to be freed by calling ms_free(). 
		public override string ToString()
		{
			IntPtr stringPtr = linphone_presence_activity_to_string(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
	}
	/// <summary>
	/// Presence model type holding information about the presence of a person. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PresenceModel : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_new_with_activity(int activity, string description);

		/// <summary>
		/// Creates a presence model specifying an activity. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="activity">The <see cref="Linphone.PresenceActivityType">
		/// Linphone.PresenceActivityType</see> to set for the created presence model.
		/// </param>
		/// <param name="description">An additional description of the activity (mainly
		/// useful for the &apos;other&apos; activity). Set it to null to not add a
		/// description.    </param>
		/// <returns>The created <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see>, or null if an error occured.    </returns>
		/// <remarks>See : linphone_presence_model_new, <see cref="Linphone.PresenceModel.NewWithActivityAndNote()">
		/// Linphone.PresenceModel.NewWithActivityAndNote()</see></remarks>
		/// The created presence model has the activity specified in the parameters. 
		public static Linphone.PresenceModel NewWithActivity(Linphone.PresenceActivityType activity, string description)
		{
			IntPtr ptr = linphone_presence_model_new_with_activity((int)activity, description);
			Linphone.PresenceModel returnVal = fromNativePtr<Linphone.PresenceModel>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_new_with_activity_and_note(int activity, string description, string note, string lang);

		/// <summary>
		/// Creates a presence model specifying an activity and adding a note. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="activity">The <see cref="Linphone.PresenceActivityType">
		/// Linphone.PresenceActivityType</see> to set for the created presence model.
		/// </param>
		/// <param name="description">An additional description of the activity (mainly
		/// useful for the &apos;other&apos; activity). Set it to null to not add a
		/// description.    </param>
		/// <param name="note">An additional note giving additional information about the
		/// contact presence.    </param>
		/// <param name="lang">The language the note is written in. It can be set to null
		/// in order to not specify the language of the note.    </param>
		/// <returns>The created <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see>, or null if an error occured.    </returns>
		/// <remarks>See : <see cref="Linphone.PresenceModel.NewWithActivity()">
		/// Linphone.PresenceModel.NewWithActivity()</see>, <see cref="Linphone.PresenceModel.NewWithActivityAndNote()">
		/// Linphone.PresenceModel.NewWithActivityAndNote()</see></remarks>
		/// The created presence model has the activity and the note specified in the
		/// parameters. 
		public static Linphone.PresenceModel NewWithActivityAndNote(Linphone.PresenceActivityType activity, string description, string note, string lang)
		{
			IntPtr ptr = linphone_presence_model_new_with_activity_and_note((int)activity, description, note, lang);
			Linphone.PresenceModel returnVal = fromNativePtr<Linphone.PresenceModel>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_activity(IntPtr thiz);

		/// <summary>
		/// Gets the first activity of a presence model (there is usually only one). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.PresenceActivity">
		/// Linphone.PresenceActivity</see> object if successful, null otherwise.      
		/// </returns>
		public Linphone.PresenceActivity Activity
		{
			get
			{
				IntPtr ptr = linphone_presence_model_get_activity(nativePtr);
				Linphone.PresenceActivity obj = fromNativePtr<Linphone.PresenceActivity>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.PresenceBasicStatus linphone_presence_model_get_basic_status(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_set_basic_status(IntPtr thiz, int basicStatus);

		/// <summary>
		/// Gets the basic status of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.PresenceBasicStatus">
		/// Linphone.PresenceBasicStatus</see> of the <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object given as parameter. </returns>
		public Linphone.PresenceBasicStatus BasicStatus
		{
			get
			{
				return linphone_presence_model_get_basic_status(nativePtr);
			}
			set
			{
				int exception_result = linphone_presence_model_set_basic_status(nativePtr, (int)value);
				if (exception_result != 0) throw new LinphoneException("BasicStatus setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_get_capabilities(IntPtr thiz);

		/// <summary>
		/// Gets the capabilities of a <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the capabilities. </returns>
		public int Capabilities
		{
			get
			{
				return linphone_presence_model_get_capabilities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.ConsolidatedPresence linphone_presence_model_get_consolidated_presence(IntPtr thiz);

		/// <summary>
		/// Get the consolidated presence from a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.ConsolidatedPresence">
		/// Linphone.ConsolidatedPresence</see> corresponding to the presence model
		/// </returns>
		public Linphone.ConsolidatedPresence ConsolidatedPresence
		{
			get
			{
				return linphone_presence_model_get_consolidated_presence(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_contact(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_set_contact(IntPtr thiz, string contact);

		/// <summary>
		/// Gets the contact of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer to a dynamically allocated string containing the contact, or
		/// null if no contact is found.      </returns>
		/// The returned string is to be freed by calling ms_free(). 
		public string Contact
		{
			get
			{
				IntPtr stringPtr = linphone_presence_model_get_contact(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_model_set_contact(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Contact setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_presence_model_is_online(IntPtr thiz);

		/// <summary>
		/// Tells whether a presence model is considered online. 
		/// <para>
		/// It is any of theses cases:
		/// </para>
		/// </summary>
		public bool IsOnline
		{
			get
			{
				return linphone_presence_model_is_online(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_presence_model_get_latest_activity_timestamp(IntPtr thiz);

		/// <summary>
		/// Gets the latest activity timestamp of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The activity timestamp of the <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object or -1 if there is no activity (such as when
		/// status is Online). </returns>
		public long LatestActivityTimestamp
		{
			get
			{
				return linphone_presence_model_get_latest_activity_timestamp(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_model_get_nb_activities(IntPtr thiz);

		/// <summary>
		/// Gets the number of activities included in the presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The number of activities included in the <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object. </returns>
		public uint NbActivities
		{
			get
			{
				return linphone_presence_model_get_nb_activities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_model_get_nb_persons(IntPtr thiz);

		/// <summary>
		/// Gets the number of persons included in the presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The number of persons included in the <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object. </returns>
		public uint NbPersons
		{
			get
			{
				return linphone_presence_model_get_nb_persons(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_model_get_nb_services(IntPtr thiz);

		/// <summary>
		/// Gets the number of services included in the presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The number of services included in the <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object. </returns>
		public uint NbServices
		{
			get
			{
				return linphone_presence_model_get_nb_services(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_presentity(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_set_presentity(IntPtr thiz, IntPtr presentity);

		/// <summary>
		/// Gets the presentity of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer to a const <see cref="Linphone.Address">
		/// Linphone.Address</see>, or null if no contact is found.    </returns>
		public Linphone.Address Presentity
		{
			get
			{
				IntPtr ptr = linphone_presence_model_get_presentity(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				int exception_result = linphone_presence_model_set_presentity(nativePtr, value.nativePtr);
				if (exception_result != 0) throw new LinphoneException("Presentity setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern long linphone_presence_model_get_timestamp(IntPtr thiz);

		/// <summary>
		/// Gets the timestamp of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The timestamp of the <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object or -1 on error. </returns>
		public long Timestamp
		{
			get
			{
				return linphone_presence_model_get_timestamp(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_add_activity(IntPtr thiz, IntPtr activity);

		/// <summary>
		/// Adds an activity to a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="activity">The <see cref="Linphone.PresenceActivity">
		/// Linphone.PresenceActivity</see> object to add to the model.    </param>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void AddActivity(Linphone.PresenceActivity activity)
		{
			int exception_result = linphone_presence_model_add_activity(nativePtr, activity != null ? activity.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddActivity returned value" + exception_result);
			
			GC.KeepAlive(activity);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_add_note(IntPtr thiz, string noteContent, string lang);

		/// <summary>
		/// Adds a note to a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="noteContent">The note to be added to the presence model.   
		/// </param>
		/// <param name="lang">The language of the note to be added. Can be null if no
		/// language is to be specified for the note.    </param>
		/// <returns>0 if successful, a value &lt; 0 in case of error.</returns>
		/// Only one note for each language can be set, so e.g. setting a note for the
		/// &apos;fr&apos; language if there is only one will replace the existing one. 
		public void AddNote(string noteContent, string lang)
		{
			int exception_result = linphone_presence_model_add_note(nativePtr, noteContent, lang);
			if (exception_result != 0) throw new LinphoneException("AddNote returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_add_person(IntPtr thiz, IntPtr person);

		/// <summary>
		/// Adds a person to a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="person">The <see cref="Linphone.PresencePerson">
		/// Linphone.PresencePerson</see> object to add to the model.    </param>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void AddPerson(Linphone.PresencePerson person)
		{
			int exception_result = linphone_presence_model_add_person(nativePtr, person != null ? person.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddPerson returned value" + exception_result);
			
			GC.KeepAlive(person);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_add_service(IntPtr thiz, IntPtr service);

		/// <summary>
		/// Adds a service to a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="service">The <see cref="Linphone.PresenceService">
		/// Linphone.PresenceService</see> object to add to the model.    </param>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void AddService(Linphone.PresenceService service)
		{
			int exception_result = linphone_presence_model_add_service(nativePtr, service != null ? service.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddService returned value" + exception_result);
			
			GC.KeepAlive(service);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_clear_activities(IntPtr thiz);

		/// <summary>
		/// Clears the activities of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void ClearActivities()
		{
			int exception_result = linphone_presence_model_clear_activities(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearActivities returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_clear_notes(IntPtr thiz);

		/// <summary>
		/// Clears all the notes of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void ClearNotes()
		{
			int exception_result = linphone_presence_model_clear_notes(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearNotes returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_clear_persons(IntPtr thiz);

		/// <summary>
		/// Clears the persons of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void ClearPersons()
		{
			int exception_result = linphone_presence_model_clear_persons(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearPersons returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_clear_services(IntPtr thiz);

		/// <summary>
		/// Clears the services of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void ClearServices()
		{
			int exception_result = linphone_presence_model_clear_services(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearServices returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_presence_model_get_capability_version(IntPtr thiz, int capability);

		/// <summary>
		/// Returns the version of the capability of a <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">The <see cref="Linphone.FriendCapability">
		/// Linphone.FriendCapability</see> to test. </param>
		/// <returns>the version of the capability of a <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> or -1.0 if the model has not the capability.
		/// </returns>
		public float GetCapabilityVersion(Linphone.FriendCapability capability)
		{
			float returnVal = linphone_presence_model_get_capability_version(nativePtr, (int)capability);
			
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_note(IntPtr thiz, string lang);

		/// <summary>
		/// Gets the first note of a presence model (there is usually only one). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="lang">The language of the note to get. Can be null to get a note
		/// that has no language specified or to get the first note whatever language it is
		/// written into.    </param>
		/// <returns>A pointer to a <see cref="Linphone.PresenceNote">
		/// Linphone.PresenceNote</see> object if successful, null otherwise.    </returns>
		public Linphone.PresenceNote GetNote(string lang)
		{
			IntPtr ptr = linphone_presence_model_get_note(nativePtr, lang);
			Linphone.PresenceNote returnVal = fromNativePtr<Linphone.PresenceNote>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_nth_activity(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth activity of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the activity to get (the first activity having
		/// the index 0). </param>
		/// <returns>A pointer to a <see cref="Linphone.PresenceActivity">
		/// Linphone.PresenceActivity</see> object if successful, null otherwise.      
		/// </returns>
		public Linphone.PresenceActivity GetNthActivity(uint index)
		{
			IntPtr ptr = linphone_presence_model_get_nth_activity(nativePtr, index);
			Linphone.PresenceActivity returnVal = fromNativePtr<Linphone.PresenceActivity>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_nth_person(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth person of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the person to get (the first person having the
		/// index 0). </param>
		/// <returns>A pointer to a <see cref="Linphone.PresencePerson">
		/// Linphone.PresencePerson</see> object if successful, null otherwise.   
		/// </returns>
		public Linphone.PresencePerson GetNthPerson(uint index)
		{
			IntPtr ptr = linphone_presence_model_get_nth_person(nativePtr, index);
			Linphone.PresencePerson returnVal = fromNativePtr<Linphone.PresencePerson>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_model_get_nth_service(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth service of a presence model. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the service to get (the first service having
		/// the index 0). </param>
		/// <returns>A pointer to a <see cref="Linphone.PresenceService">
		/// Linphone.PresenceService</see> object if successful, null otherwise.   
		/// </returns>
		public Linphone.PresenceService GetNthService(uint index)
		{
			IntPtr ptr = linphone_presence_model_get_nth_service(nativePtr, index);
			Linphone.PresenceService returnVal = fromNativePtr<Linphone.PresenceService>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_presence_model_has_capability(IntPtr thiz, int capability);

		/// <summary>
		/// Returns whether or not the <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object has a given capability. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">The capability to test. </param>
		/// <returns>whether or not the <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object has a given capability. </returns>
		public bool HasCapability(Linphone.FriendCapability capability)
		{
			bool returnVal = linphone_presence_model_has_capability(nativePtr, (int)capability) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_presence_model_has_capability_with_version(IntPtr thiz, int capability, float version);

		/// <summary>
		/// Returns whether or not the <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object has a given capability with a certain
		/// version. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">The <see cref="Linphone.FriendCapability">
		/// Linphone.FriendCapability</see> to test. </param>
		/// <param name="version">The wanted version to test. </param>
		/// <returns>whether or not the <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object has a given capability with a certain
		/// version. </returns>
		public bool HasCapabilityWithVersion(Linphone.FriendCapability capability, float version)
		{
			bool returnVal = linphone_presence_model_has_capability_with_version(nativePtr, (int)capability, version) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_presence_model_has_capability_with_version_or_more(IntPtr thiz, int capability, float version);

		/// <summary>
		/// Returns whether or not the <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object has a given capability with a certain
		/// version or more. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">The <see cref="Linphone.FriendCapability">
		/// Linphone.FriendCapability</see> to test. </param>
		/// <param name="version">The wanted version to test. </param>
		/// <returns>whether or not the <see cref="Linphone.PresenceModel">
		/// Linphone.PresenceModel</see> object has a given capability with a certain
		/// version or more. </returns>
		public bool HasCapabilityWithVersionOrMore(Linphone.FriendCapability capability, float version)
		{
			bool returnVal = linphone_presence_model_has_capability_with_version_or_more(nativePtr, (int)capability, version) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_model_set_activity(IntPtr thiz, int activity, string description);

		/// <summary>
		/// Sets the activity of a presence model (limits to only one activity). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="activity">The <see cref="Linphone.PresenceActivityType">
		/// Linphone.PresenceActivityType</see> to set for the model. </param>
		/// <param name="description">An additional description of the activity to set for
		/// the model. Can be null if no additional description is to be added.    </param>
		/// <returns>0 if successful, a value &lt; 0 in case of error.</returns>
		/// WARNING: This function will modify the basic status of the model according to
		/// the activity being set. If you don&apos;t want the basic status to be modified
		/// automatically, you can use the combination of <see cref="Linphone.PresenceModel.BasicStatus">
		/// Linphone.PresenceModel.BasicStatus</see>, <see cref="Linphone.PresenceModel.ClearActivities()">
		/// Linphone.PresenceModel.ClearActivities()</see> and <see cref="Linphone.PresenceModel.AddActivity()">
		/// Linphone.PresenceModel.AddActivity()</see>. 
		public void SetActivity(Linphone.PresenceActivityType activity, string description)
		{
			int exception_result = linphone_presence_model_set_activity(nativePtr, (int)activity, description);
			if (exception_result != 0) throw new LinphoneException("SetActivity returned value" + exception_result);
			
						
		}
	}
	/// <summary>
	/// Presence note type holding information about a presence note. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PresenceNote : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_note_get_content(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_note_set_content(IntPtr thiz, string content);

		/// <summary>
		/// Gets the content of a presence note. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer to the content of the presence note.    </returns>
		public string Content
		{
			get
			{
				IntPtr stringPtr = linphone_presence_note_get_content(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_note_set_content(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Content setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_note_get_lang(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_note_set_lang(IntPtr thiz, string lang);

		/// <summary>
		/// Gets the language of a presence note. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer to the language string of the presence note, or null if no
		/// language is specified.    </returns>
		public string Lang
		{
			get
			{
				IntPtr stringPtr = linphone_presence_note_get_lang(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_note_set_lang(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Lang setter returned value " + exception_result);
			}
		}
	}
	/// <summary>
	/// Presence person holding information about a presence person. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PresencePerson : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_person_get_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_set_id(IntPtr thiz, string id);

		/// <summary>
		/// Gets the id of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer to a dynamically allocated string containing the id, or null
		/// in case of error.      </returns>
		/// The returned string is to be freed by calling ms_free(). 
		public string Id
		{
			get
			{
				IntPtr stringPtr = linphone_presence_person_get_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_person_set_id(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Id setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_person_get_nb_activities(IntPtr thiz);

		/// <summary>
		/// Gets the number of activities included in the presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The number of activities included in the <see cref="Linphone.PresencePerson">
		/// Linphone.PresencePerson</see> object. </returns>
		public uint NbActivities
		{
			get
			{
				return linphone_presence_person_get_nb_activities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_person_get_nb_activities_notes(IntPtr thiz);

		/// <summary>
		/// Gets the number of activities notes included in the presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The number of activities notes included in the <see cref="Linphone.PresencePerson">
		/// Linphone.PresencePerson</see> object. </returns>
		public uint NbActivitiesNotes
		{
			get
			{
				return linphone_presence_person_get_nb_activities_notes(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_person_get_nb_notes(IntPtr thiz);

		/// <summary>
		/// Gets the number of notes included in the presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The number of notes included in the <see cref="Linphone.PresencePerson">
		/// Linphone.PresencePerson</see> object. </returns>
		public uint NbNotes
		{
			get
			{
				return linphone_presence_person_get_nb_notes(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_add_activities_note(IntPtr thiz, IntPtr note);

		/// <summary>
		/// Adds an activities note to a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="note">The <see cref="Linphone.PresenceNote">
		/// Linphone.PresenceNote</see> object to add to the person.    </param>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void AddActivitiesNote(Linphone.PresenceNote note)
		{
			int exception_result = linphone_presence_person_add_activities_note(nativePtr, note != null ? note.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddActivitiesNote returned value" + exception_result);
			
			GC.KeepAlive(note);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_add_activity(IntPtr thiz, IntPtr activity);

		/// <summary>
		/// Adds an activity to a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="activity">The <see cref="Linphone.PresenceActivity">
		/// Linphone.PresenceActivity</see> object to add to the person.    </param>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void AddActivity(Linphone.PresenceActivity activity)
		{
			int exception_result = linphone_presence_person_add_activity(nativePtr, activity != null ? activity.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddActivity returned value" + exception_result);
			
			GC.KeepAlive(activity);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_add_note(IntPtr thiz, IntPtr note);

		/// <summary>
		/// Adds a note to a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="note">The <see cref="Linphone.PresenceNote">
		/// Linphone.PresenceNote</see> object to add to the person.    </param>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void AddNote(Linphone.PresenceNote note)
		{
			int exception_result = linphone_presence_person_add_note(nativePtr, note != null ? note.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddNote returned value" + exception_result);
			
			GC.KeepAlive(note);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_clear_activities(IntPtr thiz);

		/// <summary>
		/// Clears the activities of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void ClearActivities()
		{
			int exception_result = linphone_presence_person_clear_activities(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearActivities returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_clear_activities_notes(IntPtr thiz);

		/// <summary>
		/// Clears the activities notes of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void ClearActivitiesNotes()
		{
			int exception_result = linphone_presence_person_clear_activities_notes(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearActivitiesNotes returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_person_clear_notes(IntPtr thiz);

		/// <summary>
		/// Clears the notes of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void ClearNotes()
		{
			int exception_result = linphone_presence_person_clear_notes(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearNotes returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_person_get_nth_activities_note(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth activities note of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the activities note to get (the first note
		/// having the index 0). </param>
		/// <returns>A pointer to a <see cref="Linphone.PresenceNote">
		/// Linphone.PresenceNote</see> object if successful, null otherwise.    </returns>
		public Linphone.PresenceNote GetNthActivitiesNote(uint index)
		{
			IntPtr ptr = linphone_presence_person_get_nth_activities_note(nativePtr, index);
			Linphone.PresenceNote returnVal = fromNativePtr<Linphone.PresenceNote>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_person_get_nth_activity(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth activity of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the activity to get (the first activity having
		/// the index 0). </param>
		/// <returns>A pointer to a <see cref="Linphone.PresenceActivity">
		/// Linphone.PresenceActivity</see> object if successful, null otherwise.   
		/// </returns>
		public Linphone.PresenceActivity GetNthActivity(uint index)
		{
			IntPtr ptr = linphone_presence_person_get_nth_activity(nativePtr, index);
			Linphone.PresenceActivity returnVal = fromNativePtr<Linphone.PresenceActivity>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_person_get_nth_note(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth note of a presence person. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the note to get (the first note having the
		/// index 0). </param>
		/// <returns>A pointer to a <see cref="Linphone.PresenceNote">
		/// Linphone.PresenceNote</see> object if successful, null otherwise.    </returns>
		public Linphone.PresenceNote GetNthNote(uint index)
		{
			IntPtr ptr = linphone_presence_person_get_nth_note(nativePtr, index);
			Linphone.PresenceNote returnVal = fromNativePtr<Linphone.PresenceNote>(ptr, true);
			
						return returnVal;
		}
	}
	/// <summary>
	/// Presence service type holding information about a presence service. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PresenceService : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.PresenceBasicStatus linphone_presence_service_get_basic_status(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_service_set_basic_status(IntPtr thiz, int basicStatus);

		/// <summary>
		/// Gets the basic status of a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.PresenceBasicStatus">
		/// Linphone.PresenceBasicStatus</see> of the <see cref="Linphone.PresenceService">
		/// Linphone.PresenceService</see> object given as parameter. </returns>
		public Linphone.PresenceBasicStatus BasicStatus
		{
			get
			{
				return linphone_presence_service_get_basic_status(nativePtr);
			}
			set
			{
				int exception_result = linphone_presence_service_set_basic_status(nativePtr, (int)value);
				if (exception_result != 0) throw new LinphoneException("BasicStatus setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_service_get_contact(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_service_set_contact(IntPtr thiz, string contact);

		/// <summary>
		/// Gets the contact of a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer to a dynamically allocated string containing the contact, or
		/// null if no contact is found.      </returns>
		/// The returned string is to be freed by calling ms_free(). 
		public string Contact
		{
			get
			{
				IntPtr stringPtr = linphone_presence_service_get_contact(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_service_set_contact(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Contact setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_service_get_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_service_set_id(IntPtr thiz, string id);

		/// <summary>
		/// Gets the id of a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A pointer to a dynamically allocated string containing the id, or null
		/// in case of error.      </returns>
		/// The returned string is to be freed by calling ms_free(). 
		public string Id
		{
			get
			{
				IntPtr stringPtr = linphone_presence_service_get_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_presence_service_set_id(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Id setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_presence_service_get_nb_notes(IntPtr thiz);

		/// <summary>
		/// Gets the number of notes included in the presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The number of notes included in the <see cref="Linphone.PresenceService">
		/// Linphone.PresenceService</see> object. </returns>
		public uint NbNotes
		{
			get
			{
				return linphone_presence_service_get_nb_notes(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_service_get_service_descriptions(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_service_set_service_descriptions(IntPtr thiz, IntPtr descriptions);

		/// <summary>
		/// Gets the service descriptions of a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A   containing the services descriptions.   </returns>
		/// The returned string is to be freed. 
		public IEnumerable<string> ServiceDescriptions
		{
			get
			{
				return MarshalStringArray(linphone_presence_service_get_service_descriptions(nativePtr));
			}
			set
			{
				int exception_result = linphone_presence_service_set_service_descriptions(nativePtr, StringArrayToBctbxList(value));
				CleanStringArrayPtrs();
				if (exception_result != 0) throw new LinphoneException("ServiceDescriptions setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_service_add_note(IntPtr thiz, IntPtr note);

		/// <summary>
		/// Adds a note to a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="note">The <see cref="Linphone.PresenceNote">
		/// Linphone.PresenceNote</see> object to add to the service.    </param>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void AddNote(Linphone.PresenceNote note)
		{
			int exception_result = linphone_presence_service_add_note(nativePtr, note != null ? note.nativePtr : IntPtr.Zero);
			if (exception_result != 0) throw new LinphoneException("AddNote returned value" + exception_result);
			
			GC.KeepAlive(note);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_presence_service_clear_notes(IntPtr thiz);

		/// <summary>
		/// Clears the notes of a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, a value &lt; 0 in case of error. </returns>
		public void ClearNotes()
		{
			int exception_result = linphone_presence_service_clear_notes(nativePtr);
			if (exception_result != 0) throw new LinphoneException("ClearNotes returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_presence_service_get_nth_note(IntPtr thiz, uint index);

		/// <summary>
		/// Gets the nth note of a presence service. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="index">The index of the note to get (the first note having the
		/// index 0). </param>
		/// <returns>A pointer to a <see cref="Linphone.PresenceNote">
		/// Linphone.PresenceNote</see> object if successful, null otherwise.    </returns>
		public Linphone.PresenceNote GetNthNote(uint index)
		{
			IntPtr ptr = linphone_presence_service_get_nth_note(nativePtr, index);
			Linphone.PresenceNote returnVal = fromNativePtr<Linphone.PresenceNote>(ptr, true);
			
						return returnVal;
		}
	}
	/// <summary>
	/// Represents an account configuration to be used by <see cref="Linphone.Core">
	/// Linphone.Core</see>. 
	/// <para>
	/// In addition to the <see cref="Linphone.AuthInfo">Linphone.AuthInfo</see> that
	/// stores the credentials, you need to configure a <see cref="Linphone.ProxyConfig">
	/// Linphone.ProxyConfig</see> as well to be able to connect to a proxy server.
	/// A minimal proxy config consists of an identity address
	/// (sip:username@domain.tld) and the proxy server address, </para>
	/// </summary>
	/// <remarks>See : <see cref="Linphone.ProxyConfig.ServerAddr">
	/// Linphone.ProxyConfig.ServerAddr</see>.</remarks>
	/// If any, it will be stored inside the default configuration file, so it will
	/// survive the destruction of the <see cref="Linphone.Core">Linphone.Core</see>
	/// and be available at the next start.
	/// The account set with <see cref="Linphone.Core.DefaultProxyConfig">
	/// Linphone.Core.DefaultProxyConfig</see> will be used as default for outgoing
	/// calls &amp; chat messages unless specified otherwise.
	/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
	/// object instead 
	[StructLayout(LayoutKind.Sequential)]
	public class ProxyConfig : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_avpf_enabled(IntPtr thiz);

		/// <summary>
		/// Indicates whether AVPF/SAVPF is being used for calls using this proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>True if AVPF/SAVPF is enabled, false otherwise. </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public bool AvpfEnabled
		{
			get
			{
				return linphone_proxy_config_avpf_enabled(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.AVPFMode linphone_proxy_config_get_avpf_mode(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_avpf_mode(IntPtr thiz, int mode);

		/// <summary>
		/// Get enablement status of RTCP feedback (also known as AVPF profile). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the enablement mode, which can be <see cref="Linphone.AVPFMode.Default">
		/// Linphone.AVPFMode.Default</see> (use LinphoneCore&apos;s mode), <see cref="Linphone.AVPFMode.Enabled">
		/// Linphone.AVPFMode.Enabled</see> (avpf is enabled), or <see cref="Linphone.AVPFMode.Disabled">
		/// Linphone.AVPFMode.Disabled</see> (disabled). </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public Linphone.AVPFMode AvpfMode
		{
			get
			{
				return linphone_proxy_config_get_avpf_mode(nativePtr);
			}
			set
			{
				linphone_proxy_config_set_avpf_mode(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_proxy_config_get_avpf_rr_interval(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_avpf_rr_interval(IntPtr thiz, uint interval);

		/// <summary>
		/// Get the interval between regular RTCP reports when using AVPF/SAVPF. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The interval in seconds. </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public uint AvpfRrInterval
		{
			get
			{
				return linphone_proxy_config_get_avpf_rr_interval(nativePtr);
			}
			set
			{
				linphone_proxy_config_set_avpf_rr_interval(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_conference_factory_uri(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_conference_factory_uri(IntPtr thiz, string uri);

		/// <summary>
		/// Get the conference factory uri. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The uri of the conference factory.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public string ConferenceFactoryUri
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_conference_factory_uri(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_conference_factory_uri(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_contact(IntPtr thiz);

		/// <summary>
		/// Return the contact address of the proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.Address">Linphone.Address</see> correspong to
		/// the contact address of the proxy config.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public Linphone.Address Contact
		{
			get
			{
				IntPtr ptr = linphone_proxy_config_get_contact(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_contact_parameters(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_contact_parameters(IntPtr thiz, string contactParams);

		/// <summary>
		/// Returns the contact parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>previously set contact parameters.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public string ContactParameters
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_contact_parameters(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_contact_parameters(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_contact_uri_parameters(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_contact_uri_parameters(IntPtr thiz, string contactUriParams);

		/// <summary>
		/// Returns the contact URI parameters. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>previously set contact URI parameters.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public string ContactUriParameters
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_contact_uri_parameters(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_contact_uri_parameters(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_core(IntPtr thiz);

		/// <summary>
		/// Get the <see cref="Linphone.Core">Linphone.Core</see> object to which is
		/// associated the <see cref="Linphone.ProxyConfig">Linphone.ProxyConfig</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Core">Linphone.Core</see> object to which is
		/// associated the <see cref="Linphone.ProxyConfig">Linphone.ProxyConfig</see>.   
		/// </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public Linphone.Core Core
		{
			get
			{
				IntPtr ptr = linphone_proxy_config_get_core(nativePtr);
				Linphone.Core obj = fromNativePtr<Linphone.Core>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_dependency(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_dependency(IntPtr thiz, IntPtr dependsOn);

		/// <summary>
		/// Get the dependency of a <see cref="Linphone.ProxyConfig">
		/// Linphone.ProxyConfig</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The proxy config this one is dependent upon, or null if not marked
		/// dependent.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public Linphone.ProxyConfig Dependency
		{
			get
			{
				IntPtr ptr = linphone_proxy_config_get_dependency(nativePtr);
				Linphone.ProxyConfig obj = fromNativePtr<Linphone.ProxyConfig>(ptr, true);
				return obj;
			}
			set
			{
				linphone_proxy_config_set_dependency(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_get_dial_escape_plus(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_dial_escape_plus(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether or not the + should be replaced by 00. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>whether liblinphone should replace &quot;+&quot; by &quot;00&quot; in
		/// dialed numbers (passed to <see cref="Linphone.Core.Invite()">
		/// Linphone.Core.Invite()</see>). </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public bool DialEscapePlus
		{
			get
			{
				return linphone_proxy_config_get_dial_escape_plus(nativePtr) != 0;
			}
			set
			{
				linphone_proxy_config_set_dial_escape_plus(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_dial_prefix(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_dial_prefix(IntPtr thiz, string prefix);

		/// <summary>
		/// Gets the prefix set for this proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>dialing prefix.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public string DialPrefix
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_dial_prefix(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_dial_prefix(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_domain(IntPtr thiz);

		/// <summary>
		/// Get the domain name of the given proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The domain name of the proxy config.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public string Domain
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.Reason linphone_proxy_config_get_error(IntPtr thiz);

		/// <summary>
		/// Get the reason why registration failed when the proxy config state is
		/// LinphoneRegistrationFailed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Reason">Linphone.Reason</see> why registration
		/// failed for this proxy config. </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public Linphone.Reason Error
		{
			get
			{
				return linphone_proxy_config_get_error(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_error_info(IntPtr thiz);

		/// <summary>
		/// Get detailed information why registration failed when the proxy config state is
		/// LinphoneRegistrationFailed. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.ErrorInfo">Linphone.ErrorInfo</see> explaining
		/// why registration failed for this proxy config.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public Linphone.ErrorInfo ErrorInfo
		{
			get
			{
				IntPtr ptr = linphone_proxy_config_get_error_info(nativePtr);
				Linphone.ErrorInfo obj = fromNativePtr<Linphone.ErrorInfo>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_get_expires(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_expires(IntPtr thiz, int expires);

		/// <summary>
		/// Gets the proxy config expires. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the duration of registration. </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public int Expires
		{
			get
			{
				return linphone_proxy_config_get_expires(nativePtr);
			}
			set
			{
				linphone_proxy_config_set_expires(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_identity_address(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_set_identity_address(IntPtr thiz, IntPtr identity);

		/// <summary>
		/// Gets the identity addres of the proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the SIP identity that belongs to this proxy configuration.   
		/// </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public Linphone.Address IdentityAddress
		{
			get
			{
				IntPtr ptr = linphone_proxy_config_get_identity_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
			set
			{
				int exception_result = linphone_proxy_config_set_identity_address(nativePtr, value.nativePtr);
				if (exception_result != 0) throw new LinphoneException("IdentityAddress setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_idkey(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_idkey(IntPtr thiz, string idkey);

		/// <summary>
		/// Get the idkey property of a <see cref="Linphone.ProxyConfig">
		/// Linphone.ProxyConfig</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The idkey string, or null.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public string Idkey
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_idkey(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_idkey(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_is_push_notification_allowed(IntPtr thiz);

		/// <summary>
		/// Indicates whether to add to the contact parameters the push notification
		/// information. 
		/// <para>
		/// For IOS, it indicates to VOIP push notification. 
		/// </para>
		/// </summary>
		/// <returns>true if push notification informations should be added, false
		/// otherwise. </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public bool IsPushNotificationAllowed
		{
			get
			{
				return linphone_proxy_config_is_push_notification_allowed(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_is_push_notification_available(IntPtr thiz);

		/// <summary>
		/// Gets whether push notifications are available or not (Android &amp; iOS only). 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if push notifications are available, false otherwise </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public bool IsPushNotificationAvailable
		{
			get
			{
				return linphone_proxy_config_is_push_notification_available(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_is_remote_push_notification_allowed(IntPtr thiz);

		/// <summary>
		/// Indicates whether to add to the contact parameters the remote push notification
		/// information (IOS only). 
		/// <para>
		/// Default value is false. 
		/// </para>
		/// </summary>
		/// <returns>true if remote push notification informations should be added, false
		/// otherwise. </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public bool IsRemotePushNotificationAllowed
		{
			get
			{
				return linphone_proxy_config_is_remote_push_notification_allowed(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_nat_policy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_nat_policy(IntPtr thiz, IntPtr policy);

		/// <summary>
		/// Get The policy that is used to pass through NATs/firewalls when using this
		/// proxy config. 
		/// <para>
		/// If it is set to null, the default NAT policy from the core will be used
		/// instead. 
		/// </para>
		/// </summary>
		/// <returns><see cref="Linphone.NatPolicy">Linphone.NatPolicy</see> object in use.
		///    </returns>
		/// <remarks>See : <see cref="Linphone.Core.NatPolicy">
		/// Linphone.Core.NatPolicy</see> </remarks>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public Linphone.NatPolicy NatPolicy
		{
			get
			{
				IntPtr ptr = linphone_proxy_config_get_nat_policy(nativePtr);
				Linphone.NatPolicy obj = fromNativePtr<Linphone.NatPolicy>(ptr, true);
				return obj;
			}
			set
			{
				linphone_proxy_config_set_nat_policy(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_proxy_config_get_privacy(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_privacy(IntPtr thiz, uint privacy);

		/// <summary>
		/// Get default privacy policy for all calls routed through this proxy. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Privacy mode as LinphonePrivacyMask </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public uint Privacy
		{
			get
			{
				return linphone_proxy_config_get_privacy(nativePtr);
			}
			set
			{
				linphone_proxy_config_set_privacy(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_publish_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_enable_publish(IntPtr thiz, char enable);

		/// <summary>
		/// Gets if the PUBLISH is enabled. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if PUBLISH request is enabled for this proxy. </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public bool PublishEnabled
		{
			get
			{
				return linphone_proxy_config_publish_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_proxy_config_enable_publish(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_get_publish_expires(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_publish_expires(IntPtr thiz, int expires);

		/// <summary>
		/// get the publish expiration time in second. 
		/// <para>
		/// Default value is the registration expiration value. 
		/// </para>
		/// </summary>
		/// <returns>expires in second </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public int PublishExpires
		{
			get
			{
				return linphone_proxy_config_get_publish_expires(nativePtr);
			}
			set
			{
				linphone_proxy_config_set_publish_expires(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_push_notification_allowed(IntPtr thiz, char allow);

		/// <summary>
		/// Indicates whether to add to the contact parameters the push notification
		/// information. 
		/// <para>
		/// For IOS, it indicates to VOIP push notification. 
		/// </para>
		/// </summary>
		/// <param name="allow">true to allow push notification information, false
		/// otherwise. </param>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public bool PushNotificationAllowed
		{
			set
			{
				linphone_proxy_config_set_push_notification_allowed(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_push_notification_config(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_push_notification_config(IntPtr thiz, IntPtr pushCfg);

		/// <summary>
		/// Retrieves the push notification configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.PushNotificationConfig">
		/// Linphone.PushNotificationConfig</see>.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public Linphone.PushNotificationConfig PushNotificationConfig
		{
			get
			{
				IntPtr ptr = linphone_proxy_config_get_push_notification_config(nativePtr);
				Linphone.PushNotificationConfig obj = fromNativePtr<Linphone.PushNotificationConfig>(ptr, true);
				return obj;
			}
			set
			{
				linphone_proxy_config_set_push_notification_config(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_quality_reporting_collector(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_quality_reporting_collector(IntPtr thiz, string collector);

		/// <summary>
		/// Get the route of the collector end-point when using quality reporting. 
		/// <para>
		/// This SIP address should be used on server-side to process packets directly
		/// before discarding packets. Collector address should be a non existing account
		/// and will not receive any messages. If null, reports will be send to the proxy
		/// domain. 
		/// </para>
		/// </summary>
		/// <returns>The SIP address of the collector end-point.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public string QualityReportingCollector
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_quality_reporting_collector(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_quality_reporting_collector(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_quality_reporting_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_enable_quality_reporting(IntPtr thiz, char enable);

		/// <summary>
		/// Indicates whether quality statistics during call should be stored and sent to a
		/// collector according to RFC 6035. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>True if quality repotring is enabled, false otherwise. </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public bool QualityReportingEnabled
		{
			get
			{
				return linphone_proxy_config_quality_reporting_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_proxy_config_enable_quality_reporting(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_get_quality_reporting_interval(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_quality_reporting_interval(IntPtr thiz, int interval);

		/// <summary>
		/// Get the interval between interval reports when using quality reporting. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The interval in seconds, 0 means interval reports are disabled.
		/// </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public int QualityReportingInterval
		{
			get
			{
				return linphone_proxy_config_get_quality_reporting_interval(nativePtr);
			}
			set
			{
				linphone_proxy_config_set_quality_reporting_interval(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_realm(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_realm(IntPtr thiz, string realm);

		/// <summary>
		/// Get the realm of the given proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The realm of the proxy config.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public string Realm
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_realm(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_realm(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_ref_key(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_ref_key(IntPtr thiz, string refkey);

		/// <summary>
		/// Get the persistent reference key associated to the proxy config. 
		/// <para>
		/// The reference key can be for example an id to an external database. It is
		/// stored in the config file, thus can survive to process exits/restarts.
		/// </para>
		/// </summary>
		/// <returns>The reference key string that has been associated to the proxy config,
		/// or null if none has been associated.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public string RefKey
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_ref_key(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_proxy_config_set_ref_key(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_proxy_config_register_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_enable_register(IntPtr thiz, char enable);

		/// <summary>
		/// Returns whether the proxy config is enabled or not. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if registration to the proxy is enabled. </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public bool RegisterEnabled
		{
			get
			{
				return linphone_proxy_config_register_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_proxy_config_enable_register(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_remote_push_notification_allowed(IntPtr thiz, char allow);

		/// <summary>
		/// Indicates whether to add to the contact parameters the remote push notification
		/// information (IOS only). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="allow">true to allow remote push notification information, false
		/// otherwise. </param>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public bool RemotePushNotificationAllowed
		{
			set
			{
				linphone_proxy_config_set_remote_push_notification_allowed(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_set_route(IntPtr thiz, string route);

		/// <summary>
		/// Sets a SIP route. 
		/// <para>
		/// When a route is set, all outgoing calls will go to the route&apos;s destination
		/// if this proxy is the default one (see <see cref="Linphone.Core.DefaultProxyConfig">
		/// Linphone.Core.DefaultProxyConfig</see> ). 
		/// </para>
		/// </summary>
		/// <param name="route">the SIP route to set    </param>
		/// <returns>-1 if route is invalid, 0 otherwise. </returns>
		/// deprecated : 08/07/2020 use <see cref="Linphone.ProxyConfig.Routes">
		/// Linphone.ProxyConfig.Routes</see> instead 
		public string Route
		{
			set
			{
				int exception_result = linphone_proxy_config_set_route(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("Route setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_routes(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_set_routes(IntPtr thiz, IntPtr routes);

		/// <summary>
		/// Gets the list of the routes set for this proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The list of routes as string.      </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public IEnumerable<string> Routes
		{
			get
			{
				return MarshalStringArray(linphone_proxy_config_get_routes(nativePtr));
			}
			set
			{
				int exception_result = linphone_proxy_config_set_routes(nativePtr, StringArrayToBctbxList(value));
				CleanStringArrayPtrs();
				if (exception_result != 0) throw new LinphoneException("Routes setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_server_addr(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_set_server_addr(IntPtr thiz, string serverAddress);

		/// <summary>
		/// Gets the proxy config proxy address. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the proxy&apos;s SIP address.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public string ServerAddr
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_server_addr(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				int exception_result = linphone_proxy_config_set_server_addr(nativePtr, value);
				if (exception_result != 0) throw new LinphoneException("ServerAddr setter returned value " + exception_result);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.RegistrationState linphone_proxy_config_get_state(IntPtr thiz);

		/// <summary>
		/// Get the registration state of the given proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.RegistrationState">
		/// Linphone.RegistrationState</see> of the proxy config. </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public Linphone.RegistrationState State
		{
			get
			{
				return linphone_proxy_config_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_transport(IntPtr thiz);

		/// <summary>
		/// Get the transport from either service route, route or addr. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The transport as a string (I.E udp, tcp, tls, dtls)    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public string Transport
		{
			get
			{
				IntPtr stringPtr = linphone_proxy_config_get_transport(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_get_unread_chat_message_count(IntPtr thiz);

		/// <summary>
		/// Return the unread chat message count for a given proxy config. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The unread chat message count. </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public int UnreadChatMessageCount
		{
			get
			{
				return linphone_proxy_config_get_unread_chat_message_count(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_proxy_config_done(IntPtr thiz);

		/// <summary>
		/// Commits modification made to the proxy configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>0 if successful, -1 otherwise </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public void Done()
		{
			int exception_result = linphone_proxy_config_done(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Done returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_edit(IntPtr thiz);

		/// <summary>
		/// Starts editing a proxy configuration. 
		/// <para>
		/// Because proxy configuration must be consistent, applications MUST call <see cref="Linphone.ProxyConfig.Edit()">
		/// Linphone.ProxyConfig.Edit()</see> before doing any attempts to modify proxy
		/// configuration (such as identity, proxy address and so on). Once the
		/// modifications are done, then the application must call <see cref="Linphone.ProxyConfig.Done()">
		/// Linphone.ProxyConfig.Done()</see> to commit the changes. 
		/// </para>
		/// </summary>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public void Edit()
		{
			linphone_proxy_config_edit(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_find_auth_info(IntPtr thiz);

		/// <summary>
		/// Find authentication info matching proxy config, if any, similarly to
		/// linphone_core_find_auth_info. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a <see cref="Linphone.AuthInfo">Linphone.AuthInfo</see> matching proxy
		/// config criteria if possible, null if nothing can be found.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public Linphone.AuthInfo FindAuthInfo()
		{
			IntPtr ptr = linphone_proxy_config_find_auth_info(nativePtr);
			Linphone.AuthInfo returnVal = fromNativePtr<Linphone.AuthInfo>(ptr, true);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_get_custom_header(IntPtr thiz, string headerName);

		/// <summary>
		/// Obtain the value of a header sent by the server in last answer to REGISTER. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">the header name for which to fetch corresponding value
		///    </param>
		/// <returns>the value of the queried header.    </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public string GetCustomHeader(string headerName)
		{
			IntPtr stringPtr = linphone_proxy_config_get_custom_header(nativePtr, headerName);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_normalize_phone_number(IntPtr thiz, string username);

		/// <summary>
		/// Normalize a human readable phone number into a basic string. 
		/// <para>
		/// 888-444-222 becomes 888444222 or +33888444222 depending on the <see cref="Linphone.ProxyConfig">
		/// Linphone.ProxyConfig</see> object. This function will always generate a
		/// normalized username if input is a phone number. 
		/// </para>
		/// </summary>
		/// <param name="username">the string to parse    </param>
		/// <returns>null if input is an invalid phone number, normalized phone number from
		/// username input otherwise.       </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public string NormalizePhoneNumber(string username)
		{
			IntPtr stringPtr = linphone_proxy_config_normalize_phone_number(nativePtr, username);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_proxy_config_normalize_sip_uri(IntPtr thiz, string username);

		/// <summary>
		/// Normalize a human readable sip uri into a fully qualified LinphoneAddress. 
		/// <para>
		/// A sip address should look like DisplayName &lt;sip:username@domain:port&gt; .
		/// Basically this function performs the following tasks
		/// The result is a syntactically correct SIP address. 
		/// </para>
		/// </summary>
		/// <param name="username">the string to parse    </param>
		/// <returns>null if invalid input, normalized sip address otherwise.      
		/// </returns>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public Linphone.Address NormalizeSipUri(string username)
		{
			IntPtr ptr = linphone_proxy_config_normalize_sip_uri(nativePtr, username);
			Linphone.Address returnVal = fromNativePtr<Linphone.Address>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_pause_register(IntPtr thiz);

		/// <summary>
		/// Prevent a proxy config from refreshing its registration. 
		/// <para>
		/// This is useful to let registrations to expire naturally (or) when the
		/// application wants to keep control on when refreshes are sent. However,
		/// linphone_core_set_network_reachable(lc,true) will always request the proxy
		/// configs to refresh their registrations. The refreshing operations can be
		/// resumed with <see cref="Linphone.ProxyConfig.RefreshRegister()">
		/// Linphone.ProxyConfig.RefreshRegister()</see>. 
		/// </para>
		/// </summary>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public void PauseRegister()
		{
			linphone_proxy_config_pause_register(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_refresh_register(IntPtr thiz);

		/// <summary>
		/// Refresh a proxy registration. 
		/// <para>
		/// This is useful if for example you resuming from suspend, thus IP address may
		/// have changed. 
		/// </para>
		/// </summary>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public void RefreshRegister()
		{
			linphone_proxy_config_refresh_register(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_proxy_config_set_custom_header(IntPtr thiz, string headerName, string headerValue);

		/// <summary>
		/// Set the value of a custom header sent to the server in REGISTERs request. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="headerName">the header name    </param>
		/// <param name="headerValue">the header&apos;s value    </param>
		/// deprecated : 06/04/2020 Use <see cref="Linphone.Account">Linphone.Account</see>
		/// object instead 
		public void SetCustomHeader(string headerName, string headerValue)
		{
			linphone_proxy_config_set_custom_header(nativePtr, headerName, headerValue);
			
			
						
		}
	}
	/// <summary>
	/// Object holding push notification config that will be set in the contact URI
	/// parameters of the Contact header in the REGISTER, if the <see cref="Linphone.AccountParams">
	/// Linphone.AccountParams</see> is configured to allow push notifications, see
	/// <see cref="Linphone.AccountParams.PushNotificationAllowed">
	/// Linphone.AccountParams.PushNotificationAllowed</see>. 
	/// <para>
	/// This object can be accessed through the <see cref="Linphone.AccountParams">
	/// Linphone.AccountParams</see> object, which can be obtained from your <see cref="Linphone.Account">
	/// Linphone.Account</see> object. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PushNotificationConfig : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_config_get_bundle_identifier(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_push_notification_config_set_bundle_identifier(IntPtr thiz, string bundleIdentifier);

		/// <summary>
		/// Gets the app&apos;s bundle identifier for &quot;contact uri parameter&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The app&apos;s bundle identifier if set, null otherwise.    </returns>
		public string BundleIdentifier
		{
			get
			{
				IntPtr stringPtr = linphone_push_notification_config_get_bundle_identifier(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_push_notification_config_set_bundle_identifier(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_config_get_call_snd(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_push_notification_config_set_call_snd(IntPtr thiz, string callSnd);

		/// <summary>
		/// Gets the call_snd for &quot;contact uri parameter&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The call_snd, default value &quot;notes_of_the_optimistic.caf&quot;.  
		///  </returns>
		public string CallSnd
		{
			get
			{
				IntPtr stringPtr = linphone_push_notification_config_get_call_snd(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_push_notification_config_set_call_snd(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_config_get_call_str(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_push_notification_config_set_call_str(IntPtr thiz, string callStr);

		/// <summary>
		/// Gets the call_str for &quot;contact uri parameter&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The call_str, default value &quot;IC_MSG&quot;.    </returns>
		public string CallStr
		{
			get
			{
				IntPtr stringPtr = linphone_push_notification_config_get_call_str(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_push_notification_config_set_call_str(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_config_get_group_chat_str(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_push_notification_config_set_group_chat_str(IntPtr thiz, string groupChatStr);

		/// <summary>
		/// Gets the groupchat_str for &quot;contact uri parameter&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The groupchat_str, default value &quot;GC_MSG&quot;.    </returns>
		public string GroupChatStr
		{
			get
			{
				IntPtr stringPtr = linphone_push_notification_config_get_group_chat_str(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_push_notification_config_set_group_chat_str(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_config_get_msg_snd(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_push_notification_config_set_msg_snd(IntPtr thiz, string msgSnd);

		/// <summary>
		/// Gets the msg_snd for &quot;contact uri parameter&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The msg_snd, default value &quot;msg.caf&quot;.    </returns>
		public string MsgSnd
		{
			get
			{
				IntPtr stringPtr = linphone_push_notification_config_get_msg_snd(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_push_notification_config_set_msg_snd(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_config_get_msg_str(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_push_notification_config_set_msg_str(IntPtr thiz, string msgStr);

		/// <summary>
		/// Gets the msg_str for &quot;contact uri parameter&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The msg_str, default value &quot;IM_MSG&quot;.    </returns>
		public string MsgStr
		{
			get
			{
				IntPtr stringPtr = linphone_push_notification_config_get_msg_str(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_push_notification_config_set_msg_str(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_config_get_param(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_push_notification_config_set_param(IntPtr thiz, string param);

		/// <summary>
		/// Gets the param for &quot;contact uri parameter&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The param if set, null otherwise.    </returns>
		public string Param
		{
			get
			{
				IntPtr stringPtr = linphone_push_notification_config_get_param(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_push_notification_config_set_param(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_config_get_prid(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_push_notification_config_set_prid(IntPtr thiz, string prid);

		/// <summary>
		/// Gets the prid for &quot;contact uri parameter&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The prid if set, null otherwise.    </returns>
		public string Prid
		{
			get
			{
				IntPtr stringPtr = linphone_push_notification_config_get_prid(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_push_notification_config_set_prid(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_config_get_provider(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_push_notification_config_set_provider(IntPtr thiz, string provider);

		/// <summary>
		/// Gets the provider for &quot;contact uri parameter&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The provider if set, null otherwise.    </returns>
		public string Provider
		{
			get
			{
				IntPtr stringPtr = linphone_push_notification_config_get_provider(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_push_notification_config_set_provider(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_push_notification_config_set_remote_push_interval(IntPtr thiz, string remotePushInterval);

		/// <summary>
		/// Specifies the interval in seconds between to subsequent remote push
		/// notifications when remote push notifications are used to notify a call invite
		/// to clients that haven&apos;t published any token for VoIP and background push
		/// notifications. 
		/// <para>
		/// In that case, several PNs are sent subsequently until the call is picked up,
		/// declined or canceled. This parameter sets a value for
		/// &apos;pn-call-remote-push-interval&apos; Contact header inside SIP REGISTER
		/// requests. A value of zero will cause the deactivation of push notification
		/// repetitions and the sending of the final notification. Thus, only the first
		/// push notification will be sent. If specified the value must be in [0;30] If not
		/// specified &apos;pn-call-remote-push-interval&apos; will not be added to Contact
		/// header. 
		/// </para>
		/// </summary>
		/// <param name="remotePushInterval">The new remote push interval set for push
		/// notification config.    </param>
		public string RemotePushInterval
		{
			set
			{
				linphone_push_notification_config_set_remote_push_interval(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_config_get_remote_token(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_push_notification_config_set_remote_token(IntPtr thiz, string remoteToken);

		/// <summary>
		/// Gets the remote token for &quot;contact uri parameter&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The remote token if set, null otherwise.    </returns>
		public string RemoteToken
		{
			get
			{
				IntPtr stringPtr = linphone_push_notification_config_get_remote_token(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_push_notification_config_set_remote_token(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_config_get_team_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_push_notification_config_set_team_id(IntPtr thiz, string teamId);

		/// <summary>
		/// Gets the team id for &quot;contact uri parameter&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The team id if set, null otherwise.    </returns>
		public string TeamId
		{
			get
			{
				IntPtr stringPtr = linphone_push_notification_config_get_team_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_push_notification_config_set_team_id(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_config_get_voip_token(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_push_notification_config_set_voip_token(IntPtr thiz, string voipToken);

		/// <summary>
		/// Gets the voip token for &quot;contact uri parameter&quot;. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The voip token if set, null otherwise.    </returns>
		public string VoipToken
		{
			get
			{
				IntPtr stringPtr = linphone_push_notification_config_get_voip_token(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_push_notification_config_set_voip_token(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_config_clone(IntPtr thiz);

		/// <summary>
		/// Instantiate a new push notification parameters with values from source. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The newly created <see cref="Linphone.PushNotificationConfig">
		/// Linphone.PushNotificationConfig</see> object.    </returns>
		public Linphone.PushNotificationConfig Clone()
		{
			IntPtr ptr = linphone_push_notification_config_clone(nativePtr);
			Linphone.PushNotificationConfig returnVal = fromNativePtr<Linphone.PushNotificationConfig>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_push_notification_config_is_equal(IntPtr thiz, IntPtr otherConfig);

		/// <summary>
		/// Checks if two Push Notification Configurations are identical. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="otherConfig">The <see cref="Linphone.PushNotificationConfig">
		/// Linphone.PushNotificationConfig</see> object to compare to.    </param>
		/// <returns>True only if the two configurations are identical.    </returns>
		public bool IsEqual(Linphone.PushNotificationConfig otherConfig)
		{
			bool returnVal = linphone_push_notification_config_is_equal(nativePtr, otherConfig != null ? otherConfig.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			GC.KeepAlive(otherConfig);
			return returnVal;
		}
	}
	/// <summary>
	/// Object holding chat message data received by a push notification on iOS
	/// platform only. 
	/// <para>
	/// This object is a subset of <see cref="Linphone.ChatMessage">
	/// Linphone.ChatMessage</see>, so only a few methods of it&apos;s parent are
	/// available, like linphone_push_notification_message_get_text_content and
	/// linphone_push_notification_message_get_subject, just enough to be able to build
	/// a notification to show the user. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class PushNotificationMessage : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_push_notification_message_is_conference_invitation_cancellation(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this message contains a conference invitation
		/// cancellation. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if this message carries a conference invitation cancellation,
		/// false otherwise. </returns>
		public bool IsConferenceInvitationCancellation
		{
			get
			{
				return linphone_push_notification_message_is_conference_invitation_cancellation(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_push_notification_message_is_conference_invitation_new(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this message contains a new conference invitation. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if this message carries a new conference invitation, false
		/// otherwise. </returns>
		public bool IsConferenceInvitationNew
		{
			get
			{
				return linphone_push_notification_message_is_conference_invitation_new(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_push_notification_message_is_conference_invitation_update(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this message contains a conference invitation update. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if this message carries a conference invitation update, false
		/// otherwise. </returns>
		public bool IsConferenceInvitationUpdate
		{
			get
			{
				return linphone_push_notification_message_is_conference_invitation_update(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_push_notification_message_is_icalendar(IntPtr thiz);

		/// <summary>
		/// Tells whether or not this message contains an icalendar by checking it&apos;s
		/// content type. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if this content type is
		/// &apos;text/calendar;conference-event=yes&apos;, false otherwise. </returns>
		public bool IsIcalendar
		{
			get
			{
				return linphone_push_notification_message_is_icalendar(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_push_notification_message_get_reaction_content(IntPtr thiz);

		/// <summary>
		/// Gets the reaction content. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The reaction content or null.    </returns>
		public string ReactionContent
		{
			get
			{
				IntPtr stringPtr = linphone_push_notification_message_get_reaction_content(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
	}
	/// <summary>
	/// Structure describing a range of integers. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Range : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_range_get_max(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_range_set_max(IntPtr thiz, int max);

		/// <summary>
		/// Gets the higher value of the range. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The higher value </returns>
		public int Max
		{
			get
			{
				return linphone_range_get_max(nativePtr);
			}
			set
			{
				linphone_range_set_max(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_range_get_min(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_range_set_min(IntPtr thiz, int min);

		/// <summary>
		/// Gets the lower value of the range. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The lower value </returns>
		public int Min
		{
			get
			{
				return linphone_range_get_min(nativePtr);
			}
			set
			{
				linphone_range_set_min(nativePtr, value);
				
			}
		}
	}
	/// <summary>
	/// Object used to record the audio or video of a call. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Recorder : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_recorder_get_capture_volume(IntPtr thiz);

		/// <summary>
		/// Get linear volume when capturing audio. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>Linear volume. </returns>
		public float CaptureVolume
		{
			get
			{
				return linphone_recorder_get_capture_volume(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_recorder_get_duration(IntPtr thiz);

		/// <summary>
		/// Gets the duration of the recording. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the duration of the recording, in milliseconds. </returns>
		public int Duration
		{
			get
			{
				return linphone_recorder_get_duration(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_recorder_get_file(IntPtr thiz);

		/// <summary>
		/// Gets the file used for recording. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the file used for the recording if any.    </returns>
		public string File
		{
			get
			{
				IntPtr stringPtr = linphone_recorder_get_file(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_recorder_get_params(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_recorder_set_params(IntPtr thiz, IntPtr parameters);

		/// <summary>
		/// Retrieve the <see cref="Linphone.RecorderParams">Linphone.RecorderParams</see>
		/// object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.RecorderParams">Linphone.RecorderParams</see>
		/// object.    </returns>
		public Linphone.RecorderParams Params
		{
			get
			{
				IntPtr ptr = linphone_recorder_get_params(nativePtr);
				Linphone.RecorderParams obj = fromNativePtr<Linphone.RecorderParams>(ptr, true);
				return obj;
			}
			set
			{
				linphone_recorder_set_params(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.RecorderState linphone_recorder_get_state(IntPtr thiz);

		/// <summary>
		/// Gets the current state of the recorder. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the current <see cref="Linphone.RecorderState">
		/// Linphone.RecorderState</see>. </returns>
		public Linphone.RecorderState State
		{
			get
			{
				return linphone_recorder_get_state(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_recorder_close(IntPtr thiz);

		/// <summary>
		/// Close the opened file. 
		/// <para>
		/// </para>
		/// </summary>
		public void Close()
		{
			linphone_recorder_close(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_recorder_create_content(IntPtr thiz);

		/// <summary>
		/// Create a content from the recording, for example to send it in a chat message. 
		/// <para>
		/// </para>
		/// </summary>
		/// <remarks>Warning : Recorder must be in Closed state! </remarks> 
		/// <returns>the <see cref="Linphone.Content">Linphone.Content</see> matching the
		/// recording, or null.    </returns>
		public Linphone.Content CreateContent()
		{
			IntPtr ptr = linphone_recorder_create_content(nativePtr);
			Linphone.Content returnVal = fromNativePtr<Linphone.Content>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_recorder_open(IntPtr thiz, string file);

		/// <summary>
		/// Open a file for recording. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="file">The path to the file to open.    </param>
		public void Open(string file)
		{
			int exception_result = linphone_recorder_open(nativePtr, file);
			if (exception_result != 0) throw new LinphoneException("Open returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_recorder_pause(IntPtr thiz);

		/// <summary>
		/// Pause the recording. 
		/// <para>
		/// </para>
		/// </summary>
		public void Pause()
		{
			int exception_result = linphone_recorder_pause(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Pause returned value" + exception_result);
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_recorder_start(IntPtr thiz);

		/// <summary>
		/// Start the recording into the opened file. 
		/// <para>
		/// </para>
		/// </summary>
		public void Start()
		{
			int exception_result = linphone_recorder_start(nativePtr);
			if (exception_result != 0) throw new LinphoneException("Start returned value" + exception_result);
			
						
		}
	}
	/// <summary>
	/// Object containing various parameters of a <see cref="Linphone.Recorder">
	/// Linphone.Recorder</see>. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class RecorderParams : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_recorder_params_get_audio_device(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_recorder_params_set_audio_device(IntPtr thiz, IntPtr device);

		/// <summary>
		/// Retrieve the <see cref="Linphone.AudioDevice">Linphone.AudioDevice</see>
		/// object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.AudioDevice">Linphone.AudioDevice</see>
		/// object.    </returns>
		public Linphone.AudioDevice AudioDevice
		{
			get
			{
				IntPtr ptr = linphone_recorder_params_get_audio_device(nativePtr);
				Linphone.AudioDevice obj = fromNativePtr<Linphone.AudioDevice>(ptr, true);
				return obj;
			}
			set
			{
				linphone_recorder_params_set_audio_device(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.RecorderFileFormat linphone_recorder_params_get_file_format(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_recorder_params_set_file_format(IntPtr thiz, int format);

		/// <summary>
		/// Retrieves the <see cref="Linphone.RecorderFileFormat">
		/// Linphone.RecorderFileFormat</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the <see cref="Linphone.RecorderFileFormat">
		/// Linphone.RecorderFileFormat</see>. </returns>
		public Linphone.RecorderFileFormat FileFormat
		{
			get
			{
				return linphone_recorder_params_get_file_format(nativePtr);
			}
			set
			{
				linphone_recorder_params_set_file_format(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_recorder_params_get_video_codec(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_recorder_params_set_video_codec(IntPtr thiz, string videoCodec);

		/// <summary>
		/// Retrieves the video codec. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the video codec.    </returns>
		public string VideoCodec
		{
			get
			{
				IntPtr stringPtr = linphone_recorder_params_get_video_codec(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_recorder_params_set_video_codec(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_recorder_params_get_webcam_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_recorder_params_set_webcam_name(IntPtr thiz, string webcamName);

		/// <summary>
		/// Retrieves the webcam name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the webcam name.    </returns>
		public string WebcamName
		{
			get
			{
				IntPtr stringPtr = linphone_recorder_params_get_webcam_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_recorder_params_set_webcam_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_recorder_params_get_window_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_recorder_params_set_window_id(IntPtr thiz, IntPtr windowId);

		/// <summary>
		/// Retrieves the window id. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the window id.    </returns>
		public IntPtr WindowId
		{
			get
			{
				return linphone_recorder_params_get_window_id(nativePtr);
			}
			set
			{
				linphone_recorder_params_set_window_id(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_recorder_params_clone(IntPtr thiz);

		/// <summary>
		/// Clone a <see cref="Linphone.RecorderParams">Linphone.RecorderParams</see>
		/// object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the cloned <see cref="Linphone.RecorderParams">
		/// Linphone.RecorderParams</see> object.    </returns>
		public Linphone.RecorderParams Clone()
		{
			IntPtr ptr = linphone_recorder_params_clone(nativePtr);
			Linphone.RecorderParams returnVal = fromNativePtr<Linphone.RecorderParams>(ptr, false);
			
						return returnVal;
		}
	}
	/// <summary>
	/// The LinphoneSearchResult object represents a result of a search. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class SearchResult : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_search_result_get_address(IntPtr thiz);

		/// <summary>
		/// Gets the address of the search result if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The associed <see cref="Linphone.Address">Linphone.Address</see> or
		/// null.    </returns>
		public Linphone.Address Address
		{
			get
			{
				IntPtr ptr = linphone_search_result_get_address(nativePtr);
				Linphone.Address obj = fromNativePtr<Linphone.Address>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_search_result_get_capabilities(IntPtr thiz);

		/// <summary>
		/// Returns the capabilities mask of the search result. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the capabilities mask associated to the search result </returns>
		public int Capabilities
		{
			get
			{
				return linphone_search_result_get_capabilities(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_search_result_get_friend(IntPtr thiz);

		/// <summary>
		/// Gets the friend of the search result if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The associated <see cref="Linphone.Friend">Linphone.Friend</see> or
		/// null.    </returns>
		public Linphone.Friend Friend
		{
			get
			{
				IntPtr ptr = linphone_search_result_get_friend(nativePtr);
				Linphone.Friend obj = fromNativePtr<Linphone.Friend>(ptr, true);
				return obj;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_search_result_get_phone_number(IntPtr thiz);

		/// <summary>
		/// Gets the phone number of the search result if any. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The associed phone number or null.    </returns>
		public string PhoneNumber
		{
			get
			{
				IntPtr stringPtr = linphone_search_result_get_phone_number(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_search_result_get_source_flags(IntPtr thiz);

		/// <summary>
		/// Gets source flags of the search result. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the source flags from <see cref="Linphone.MagicSearchSource">
		/// Linphone.MagicSearchSource</see> </returns>
		public int SourceFlags
		{
			get
			{
				return linphone_search_result_get_source_flags(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_search_result_get_weight(IntPtr thiz);

		/// <summary>
		/// Gets the weight of the search result. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the result weight </returns>
		public uint Weight
		{
			get
			{
				return linphone_search_result_get_weight(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_search_result_has_capability(IntPtr thiz, int capability);

		/// <summary>
		/// Returns whether or not the search result has the given capability. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="capability">the <see cref="Linphone.FriendCapability">
		/// Linphone.FriendCapability</see> to check </param>
		/// <returns>true if it has the capability, false otherwise. </returns>
		public bool HasCapability(Linphone.FriendCapability capability)
		{
			bool returnVal = linphone_search_result_has_capability(nativePtr, (int)capability) == (char)0 ? false : true;
			
						return returnVal;
		}
	}
	/// <summary>
	/// Object to get signal (wifi/4G etc...) informations. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class SignalInformation : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SignalType linphone_signal_information_get_signal_type(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_signal_information_set_signal_type(IntPtr thiz, int type);

		/// <summary>
		/// Get the <see cref="Linphone.SignalType">Linphone.SignalType</see> of the <see cref="Linphone.SignalInformation">
		/// Linphone.SignalInformation</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.SignalType">Linphone.SignalType</see>. </returns>
		public Linphone.SignalType SignalType
		{
			get
			{
				return linphone_signal_information_get_signal_type(nativePtr);
			}
			set
			{
				linphone_signal_information_set_signal_type(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.SignalStrengthUnit linphone_signal_information_get_signal_unit(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_signal_information_set_signal_unit(IntPtr thiz, int unit);

		/// <summary>
		/// Get the <see cref="Linphone.SignalStrengthUnit">
		/// Linphone.SignalStrengthUnit</see> value of the <see cref="Linphone.SignalInformation">
		/// Linphone.SignalInformation</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A <see cref="Linphone.SignalStrengthUnit">
		/// Linphone.SignalStrengthUnit</see>. </returns>
		public Linphone.SignalStrengthUnit SignalUnit
		{
			get
			{
				return linphone_signal_information_get_signal_unit(nativePtr);
			}
			set
			{
				linphone_signal_information_set_signal_unit(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern float linphone_signal_information_get_strength(IntPtr thiz);

		/// <summary>
		/// Get the value of the <see cref="Linphone.SignalInformation">
		/// Linphone.SignalInformation</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A float containing the value. </returns>
		public float Strength
		{
			get
			{
				return linphone_signal_information_get_strength(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_signal_information_set_value(IntPtr thiz, float val);

		/// <summary>
		/// Set a new value to a <see cref="Linphone.SignalInformation">
		/// Linphone.SignalInformation</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="val">a float containing the new value to set. </param>
		public float Value
		{
			set
			{
				linphone_signal_information_set_value(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_signal_information_clone(IntPtr thiz);

		/// <summary>
		/// Clone the given signalInformation. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A new signalInformation with exactly same informations that param.   
		/// </returns>
		public Linphone.SignalInformation Clone()
		{
			IntPtr ptr = linphone_signal_information_clone(nativePtr);
			Linphone.SignalInformation returnVal = fromNativePtr<Linphone.SignalInformation>(ptr, false);
			
						return returnVal;
		}
	}
	/// <summary>
	/// SIP transports &amp; ports configuration object. 
	/// <para>
	/// Indicates which transport among UDP, TCP, TLS and DTLS should be enabled and if
	/// so on which port to listen. You can use special values like
	/// LC_SIP_TRANSPORT_DISABLED (0), LC_SIP_TRANSPORT_RANDOM (-1) and
	/// LC_SIP_TRANSPORT_DONTBIND (-2).
	/// Once configuration is complete, use <see cref="Linphone.Core.Transports">
	/// Linphone.Core.Transports</see> to apply it. This will be saved in configuration
	/// file so you don&apos;t have to do it each time the <see cref="Linphone.Core">
	/// Linphone.Core</see> starts. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Transports : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_transports_get_dtls_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_transports_set_dtls_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the DTLS port in the <see cref="Linphone.Transports">
		/// Linphone.Transports</see> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the DTLS port </returns>
		public int DtlsPort
		{
			get
			{
				return linphone_transports_get_dtls_port(nativePtr);
			}
			set
			{
				linphone_transports_set_dtls_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_transports_get_tcp_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_transports_set_tcp_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the TCP port in the <see cref="Linphone.Transports">
		/// Linphone.Transports</see> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the TCP port </returns>
		public int TcpPort
		{
			get
			{
				return linphone_transports_get_tcp_port(nativePtr);
			}
			set
			{
				linphone_transports_set_tcp_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_transports_get_tls_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_transports_set_tls_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the TLS port in the <see cref="Linphone.Transports">
		/// Linphone.Transports</see> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the TLS port </returns>
		public int TlsPort
		{
			get
			{
				return linphone_transports_get_tls_port(nativePtr);
			}
			set
			{
				linphone_transports_set_tls_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_transports_get_udp_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_transports_set_udp_port(IntPtr thiz, int port);

		/// <summary>
		/// Gets the UDP port in the <see cref="Linphone.Transports">
		/// Linphone.Transports</see> object. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the UDP port </returns>
		public int UdpPort
		{
			get
			{
				return linphone_transports_get_udp_port(nativePtr);
			}
			set
			{
				linphone_transports_set_udp_port(nativePtr, value);
				
			}
		}
	}
	/// <summary>
	/// Linphone tunnel object. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Tunnel : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_tunnel_get_activated(IntPtr thiz);

		/// <summary>
		/// Returns whether the tunnel is activated. 
		/// <para>
		/// If mode is set to auto, this gives indication whether the automatic detection
		/// determined that tunnel was necessary or not. 
		/// </para>
		/// </summary>
		/// <returns>true if tunnel is in use, false otherwise. </returns>
		public bool Activated
		{
			get
			{
				return linphone_tunnel_get_activated(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_tunnel_get_domain(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_set_domain(IntPtr thiz, string domain);

		/// <summary>
		/// Get the domain. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The domain.    </returns>
		public string Domain
		{
			get
			{
				IntPtr stringPtr = linphone_tunnel_get_domain(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_tunnel_set_domain(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_tunnel_dual_mode_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_enable_dual_mode(IntPtr thiz, char dualModeEnabled);

		/// <summary>
		/// Get the dual tunnel client mode. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>true if dual tunnel client mode is enabled, false otherwise </returns>
		public bool DualModeEnabled
		{
			get
			{
				return linphone_tunnel_dual_mode_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_tunnel_enable_dual_mode(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.TunnelMode linphone_tunnel_get_mode(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_set_mode(IntPtr thiz, int mode);

		/// <summary>
		/// Get the tunnel mode. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The current <see cref="Linphone.TunnelMode">Linphone.TunnelMode</see>
		/// </returns>
		public Linphone.TunnelMode Mode
		{
			get
			{
				return linphone_tunnel_get_mode(nativePtr);
			}
			set
			{
				linphone_tunnel_set_mode(nativePtr, (int)value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_tunnel_get_servers(IntPtr thiz);

		/// <summary>
		/// Get added servers. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The list of servers.      </returns>
		public IEnumerable<Linphone.TunnelConfig> Servers
		{
			get
			{
				return MarshalBctbxList<Linphone.TunnelConfig>(linphone_tunnel_get_servers(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_tunnel_sip_enabled(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_enable_sip(IntPtr thiz, char enable);

		/// <summary>
		/// Check whether tunnel is set to transport SIP packets. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether SIP packets shall pass through the
		/// tunnel </returns>
		public bool SipEnabled
		{
			get
			{
				return linphone_tunnel_sip_enabled(nativePtr) != 0;
			}
			set
			{
				linphone_tunnel_enable_sip(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_tunnel_get_username(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_set_username(IntPtr thiz, string username);

		/// <summary>
		/// Get the username. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The username.    </returns>
		public string Username
		{
			get
			{
				IntPtr stringPtr = linphone_tunnel_get_username(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_tunnel_set_username(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_add_server(IntPtr thiz, IntPtr tunnelConfig);

		/// <summary>
		/// Add a tunnel server configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="tunnelConfig"><see cref="Linphone.TunnelConfig">
		/// Linphone.TunnelConfig</see> object    </param>
		public void AddServer(Linphone.TunnelConfig tunnelConfig)
		{
			linphone_tunnel_add_server(nativePtr, tunnelConfig != null ? tunnelConfig.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(tunnelConfig);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_clean_servers(IntPtr thiz);

		/// <summary>
		/// Remove all tunnel server addresses previously entered with <see cref="Linphone.Tunnel.AddServer()">
		/// Linphone.Tunnel.AddServer()</see> 
		/// <para>
		/// </para>
		/// </summary>
		public void CleanServers()
		{
			linphone_tunnel_clean_servers(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_tunnel_connected(IntPtr thiz);

		/// <summary>
		/// Check whether the tunnel is connected. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling if the tunnel is connected </returns>
		public bool Connected()
		{
			bool returnVal = linphone_tunnel_connected(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_reconnect(IntPtr thiz);

		/// <summary>
		/// Force reconnection to the tunnel server. 
		/// <para>
		/// This method is useful when the device switches from wifi to Edge/3G or vice
		/// versa. In most cases the tunnel client socket won&apos;t be notified promptly
		/// that its connection is now zombie, so it is recommended to call this method
		/// that will cause the lost connection to be closed and new connection to be
		/// issued. 
		/// </para>
		/// </summary>
		public void Reconnect()
		{
			linphone_tunnel_reconnect(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_remove_server(IntPtr thiz, IntPtr tunnelConfig);

		/// <summary>
		/// Remove a tunnel server configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="tunnelConfig"><see cref="Linphone.TunnelConfig">
		/// Linphone.TunnelConfig</see> object    </param>
		public void RemoveServer(Linphone.TunnelConfig tunnelConfig)
		{
			linphone_tunnel_remove_server(nativePtr, tunnelConfig != null ? tunnelConfig.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(tunnelConfig);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_set_http_proxy(IntPtr thiz, string host, int port, string username, string passwd);

		/// <summary>
		/// Set an optional http proxy to go through when connecting to tunnel server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="host">http proxy host    </param>
		/// <param name="port">http proxy port </param>
		/// <param name="username">Optional http proxy username if the proxy request
		/// authentication. Currently only basic authentication is supported. Use null if
		/// not needed.    </param>
		/// <param name="passwd">Optional http proxy password. Use null if not needed.   
		/// </param>
		public void SetHttpProxy(string host, int port, string username, string passwd)
		{
			linphone_tunnel_set_http_proxy(nativePtr, host, port, username, passwd);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_set_http_proxy_auth_info(IntPtr thiz, string username, string passwd);

		/// <summary>
		/// Set authentication info for the http proxy. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="username">User name    </param>
		/// <param name="passwd">Password    </param>
		public void SetHttpProxyAuthInfo(string username, string passwd)
		{
			linphone_tunnel_set_http_proxy_auth_info(nativePtr, username, passwd);
			
			
						
		}
	}
	/// <summary>
	/// Tunnel settings. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class TunnelConfig : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_tunnel_config_get_delay(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_config_set_delay(IntPtr thiz, int delay);

		/// <summary>
		/// Get the UDP packet round trip delay in ms for a tunnel configuration. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The UDP packet round trip delay in ms. </returns>
		public int Delay
		{
			get
			{
				return linphone_tunnel_config_get_delay(nativePtr);
			}
			set
			{
				linphone_tunnel_config_set_delay(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_tunnel_config_get_host(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_config_set_host(IntPtr thiz, string host);

		/// <summary>
		/// Get the IP address or hostname of the tunnel server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The tunnel server IP address or hostname.    </returns>
		public string Host
		{
			get
			{
				IntPtr stringPtr = linphone_tunnel_config_get_host(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_tunnel_config_set_host(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_tunnel_config_get_host2(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_config_set_host2(IntPtr thiz, string host);

		/// <summary>
		/// Get the IP address or hostname of the second tunnel server when using dual
		/// tunnel client. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The tunnel server IP address or hostname.    </returns>
		public string Host2
		{
			get
			{
				IntPtr stringPtr = linphone_tunnel_config_get_host2(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_tunnel_config_set_host2(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_tunnel_config_get_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_config_set_port(IntPtr thiz, int port);

		/// <summary>
		/// Get the TLS port of the tunnel server. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The TLS port of the tunnel server </returns>
		public int Port
		{
			get
			{
				return linphone_tunnel_config_get_port(nativePtr);
			}
			set
			{
				linphone_tunnel_config_set_port(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_tunnel_config_get_port2(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_config_set_port2(IntPtr thiz, int port);

		/// <summary>
		/// Get the TLS port of the second tunnel server when using dual tunnel client. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The TLS port of the tunnel server </returns>
		public int Port2
		{
			get
			{
				return linphone_tunnel_config_get_port2(nativePtr);
			}
			set
			{
				linphone_tunnel_config_set_port2(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_tunnel_config_get_remote_udp_mirror_port(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_tunnel_config_set_remote_udp_mirror_port(IntPtr thiz, int remoteUdpMirrorPort);

		/// <summary>
		/// Get the remote port on the tunnel server side used to test UDP reachability. 
		/// <para>
		/// This is used when the mode is set auto, to detect whether the tunnel has to be
		/// enabled or not. 
		/// </para>
		/// </summary>
		/// <returns>The remote port on the tunnel server side used to test UDP
		/// reachability </returns>
		public int RemoteUdpMirrorPort
		{
			get
			{
				return linphone_tunnel_config_get_remote_udp_mirror_port(nativePtr);
			}
			set
			{
				linphone_tunnel_config_set_remote_udp_mirror_port(nativePtr, value);
				
			}
		}
	}
	/// <summary>
	/// Object storing contact information using vCard 4.0 format. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class Vcard : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_etag(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_etag(IntPtr thiz, string etag);

		/// <summary>
		/// Gets the eTag of the vCard. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the eTag of the vCard in the CardDAV server, otherwise null.   
		/// </returns>
		public string Etag
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_etag(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_etag(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_family_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_family_name(IntPtr thiz, string name);

		/// <summary>
		/// Returns the family name in the N attribute of the vCard, or null if it
		/// isn&apos;t set yet. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the family name of the vCard, or null    </returns>
		public string FamilyName
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_family_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_family_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_full_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_full_name(IntPtr thiz, string name);

		/// <summary>
		/// Returns the FN attribute of the vCard, or null if it isn&apos;t set yet. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the display name of the vCard, or null.    </returns>
		public string FullName
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_full_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_full_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_given_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_given_name(IntPtr thiz, string name);

		/// <summary>
		/// Returns the given name in the N attribute of the vCard, or null if it
		/// isn&apos;t set yet. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the given name of the vCard, or null    </returns>
		public string GivenName
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_given_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_given_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_job_title(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_job_title(IntPtr thiz, string jobTitle);

		/// <summary>
		/// Gets the Title of the vCard. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the Title of the vCard or null.    </returns>
		public string JobTitle
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_job_title(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_job_title(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_organization(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_organization(IntPtr thiz, string organization);

		/// <summary>
		/// Gets the Organization of the vCard. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the Organization of the vCard or null.    </returns>
		public string Organization
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_organization(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_organization(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_phone_numbers(IntPtr thiz);

		/// <summary>
		/// Returns the list of phone numbers in the vCard (all the TEL attributes) or
		/// null. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The phone numbers as string.         </returns>
		public IEnumerable<string> PhoneNumbers
		{
			get
			{
				return MarshalStringArray(linphone_vcard_get_phone_numbers(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_phone_numbers_with_label(IntPtr thiz);

		/// <summary>
		/// Returns the list of phone numbers in the vCard (all the TEL attributes) or
		/// null. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The phone numbers as <see cref="Linphone.FriendPhoneNumber">
		/// Linphone.FriendPhoneNumber</see>.         </returns>
		public IEnumerable<Linphone.FriendPhoneNumber> PhoneNumbersWithLabel
		{
			get
			{
				return MarshalBctbxList<Linphone.FriendPhoneNumber>(linphone_vcard_get_phone_numbers_with_label(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_photo(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_photo(IntPtr thiz, string picture);

		/// <summary>
		/// Returns the first PHOTO property or null. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The picture URI as string or null if none has been set.    </returns>
		public string Photo
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_photo(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_photo(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_sip_addresses(IntPtr thiz);

		/// <summary>
		/// Returns the list of SIP addresses in the vCard (all the IMPP attributes that
		/// has an URI value starting by &quot;sip:&quot;) or null. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The SIP addresses.      </returns>
		public IEnumerable<Linphone.Address> SipAddresses
		{
			get
			{
				return MarshalBctbxList<Linphone.Address>(linphone_vcard_get_sip_addresses(nativePtr), true);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_vcard_get_skip_validation(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_skip_validation(IntPtr thiz, char skip);

		/// <summary>
		/// Returns the skipFieldValidation property of the vcard. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the skipFieldValidation property of the vcard </returns>
		public bool SkipValidation
		{
			get
			{
				return linphone_vcard_get_skip_validation(nativePtr) != 0;
			}
			set
			{
				linphone_vcard_set_skip_validation(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_uid(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_uid(IntPtr thiz, string uid);

		/// <summary>
		/// Gets the UID of the vCard. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the UID of the vCard, otherwise null.    </returns>
		public string Uid
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_uid(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_uid(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_url(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_set_url(IntPtr thiz, string url);

		/// <summary>
		/// Gets the URL of the vCard. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>the URL of the vCard in the CardDAV server, otherwise null.   
		/// </returns>
		public string Url
		{
			get
			{
				IntPtr stringPtr = linphone_vcard_get_url(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_vcard_set_url(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_add_extended_property(IntPtr thiz, string name, string val);

		/// <summary>
		/// Adds an extended property to the vCard. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the name of the extended property to add    </param>
		/// <param name="val">the value of the extended property to add    </param>
		public void AddExtendedProperty(string name, string val)
		{
			linphone_vcard_add_extended_property(nativePtr, name, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_add_phone_number(IntPtr thiz, string phone);

		/// <summary>
		/// Adds a phone number in the vCard, using the TEL property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phone">the phone number to add    </param>
		public void AddPhoneNumber(string phone)
		{
			linphone_vcard_add_phone_number(nativePtr, phone);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_add_phone_number_with_label(IntPtr thiz, IntPtr phoneNumber);

		/// <summary>
		/// Adds a <see cref="Linphone.FriendPhoneNumber">Linphone.FriendPhoneNumber</see>
		/// in the vCard, using the TEL property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">the <see cref="Linphone.FriendPhoneNumber">
		/// Linphone.FriendPhoneNumber</see> to add    </param>
		public void AddPhoneNumberWithLabel(Linphone.FriendPhoneNumber phoneNumber)
		{
			linphone_vcard_add_phone_number_with_label(nativePtr, phoneNumber != null ? phoneNumber.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(phoneNumber);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_add_sip_address(IntPtr thiz, string sipAddress);

		/// <summary>
		/// Adds a SIP address in the vCard, using the IMPP property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="sipAddress">the SIP address to add    </param>
		public void AddSipAddress(string sipAddress)
		{
			linphone_vcard_add_sip_address(nativePtr, sipAddress);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_as_vcard4_string(IntPtr thiz);

		/// <summary>
		/// Returns the vCard4 representation of the LinphoneVcard. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a const char * that represents the vCard.    </returns>
		public string AsVcard4String()
		{
			IntPtr stringPtr = linphone_vcard_as_vcard4_string(nativePtr);
			string returnVal = Marshal.PtrToStringAnsi(stringPtr);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_clone(IntPtr thiz);

		/// <summary>
		/// Clone a <see cref="Linphone.Vcard">Linphone.Vcard</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>a new <see cref="Linphone.Vcard">Linphone.Vcard</see> object   
		/// </returns>
		public Linphone.Vcard Clone()
		{
			IntPtr ptr = linphone_vcard_clone(nativePtr);
			Linphone.Vcard returnVal = fromNativePtr<Linphone.Vcard>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_edit_main_sip_address(IntPtr thiz, string sipAddress);

		/// <summary>
		/// Edits the preferred SIP address in the vCard (or the first one), using the IMPP
		/// property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="sipAddress">the new SIP address    </param>
		public void EditMainSipAddress(string sipAddress)
		{
			linphone_vcard_edit_main_sip_address(nativePtr, sipAddress);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_vcard_generate_unique_id(IntPtr thiz);

		/// <summary>
		/// Generates a random unique id for the vCard. 
		/// <para>
		/// If is required to be able to synchronize the vCard with a CardDAV server 
		/// </para>
		/// </summary>
		/// <returns>true if operation is successful, otherwise false (for example if it
		/// already has an unique ID) </returns>
		public bool GenerateUniqueId()
		{
			bool returnVal = linphone_vcard_generate_unique_id(nativePtr) == (char)0 ? false : true;
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_vcard_get_extended_properties_values_by_name(IntPtr thiz, string name);

		/// <summary>
		/// Get the vCard extended properties values per property name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the name to filter the extended properties on.    </param>
		/// <returns>The extended properties values as string.         </returns>
		public IEnumerable<string> GetExtendedPropertiesValuesByName(string name)
		{
			IEnumerable<string> returnVal = MarshalStringArray(linphone_vcard_get_extended_properties_values_by_name(nativePtr, name));
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_remove_extented_properties_by_name(IntPtr thiz, string name);

		/// <summary>
		/// Remove all the extend properties per property name. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="name">the name to remove the extended properties on.    </param>
		public void RemoveExtentedPropertiesByName(string name)
		{
			linphone_vcard_remove_extented_properties_by_name(nativePtr, name);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_remove_job_title(IntPtr thiz);

		/// <summary>
		/// Removes the Title field of the vCard. 
		/// <para>
		/// </para>
		/// </summary>
		public void RemoveJobTitle()
		{
			linphone_vcard_remove_job_title(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_remove_organization(IntPtr thiz);

		/// <summary>
		/// Removes the Organization field of the vCard. 
		/// <para>
		/// </para>
		/// </summary>
		public void RemoveOrganization()
		{
			linphone_vcard_remove_organization(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_remove_phone_number(IntPtr thiz, string phone);

		/// <summary>
		/// Removes a phone number in the vCard (if it exists), using the TEL property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phone">the phone number to remove    </param>
		public void RemovePhoneNumber(string phone)
		{
			linphone_vcard_remove_phone_number(nativePtr, phone);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_remove_phone_number_with_label(IntPtr thiz, IntPtr phoneNumber);

		/// <summary>
		/// Removes a <see cref="Linphone.FriendPhoneNumber">
		/// Linphone.FriendPhoneNumber</see> in the vCard (if it exists), using the TEL
		/// property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="phoneNumber">the <see cref="Linphone.FriendPhoneNumber">
		/// Linphone.FriendPhoneNumber</see> to remove    </param>
		public void RemovePhoneNumberWithLabel(Linphone.FriendPhoneNumber phoneNumber)
		{
			linphone_vcard_remove_phone_number_with_label(nativePtr, phoneNumber != null ? phoneNumber.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(phoneNumber);
			
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_remove_photo(IntPtr thiz);

		/// <summary>
		/// Removes any existing PHOTO property. 
		/// <para>
		/// </para>
		/// </summary>
		public void RemovePhoto()
		{
			linphone_vcard_remove_photo(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_vcard_remove_sip_address(IntPtr thiz, string sipAddress);

		/// <summary>
		/// Removes a SIP address in the vCard (if it exists), using the IMPP property. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="sipAddress">the SIP address to remove    </param>
		public void RemoveSipAddress(string sipAddress)
		{
			linphone_vcard_remove_sip_address(nativePtr, sipAddress);
			
			
						
		}
	}
	/// <summary>
	/// Object describing policy regarding video streams establishments. 
	/// <para>
	/// Use <see cref="Linphone.VideoActivationPolicy.AutomaticallyAccept">
	/// Linphone.VideoActivationPolicy.AutomaticallyAccept</see> and <see cref="Linphone.VideoActivationPolicy.AutomaticallyInitiate">
	/// Linphone.VideoActivationPolicy.AutomaticallyInitiate</see> to tell the Core to
	/// automatically accept or initiate video during calls.
	/// Even if disabled, you&apos;ll still be able to add it later while the call is
	/// running. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class VideoActivationPolicy : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_video_activation_policy_get_automatically_accept(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_activation_policy_set_automatically_accept(IntPtr thiz, char enable);

		/// <summary>
		/// Gets the value for the automatically accept video policy. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>whether or not to automatically accept video requests is enabled
		/// </returns>
		public bool AutomaticallyAccept
		{
			get
			{
				return linphone_video_activation_policy_get_automatically_accept(nativePtr) != 0;
			}
			set
			{
				linphone_video_activation_policy_set_automatically_accept(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_video_activation_policy_get_automatically_initiate(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_activation_policy_set_automatically_initiate(IntPtr thiz, char enable);

		/// <summary>
		/// Gets the value for the automatically initiate video policy. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>whether or not to automatically initiate video calls is enabled
		/// </returns>
		public bool AutomaticallyInitiate
		{
			get
			{
				return linphone_video_activation_policy_get_automatically_initiate(nativePtr) != 0;
			}
			set
			{
				linphone_video_activation_policy_set_automatically_initiate(nativePtr, value ? (char)1 : (char)0);
				
			}
		}
	}
	/// <summary>
	/// This object represents a video definition, eg. 
	/// <para>
	/// it&apos;s width, it&apos;s height and possibly it&apos;s name.
	/// It is mostly used to configure the default video size sent by your camera
	/// during a video call with <see cref="Linphone.Core.PreferredVideoDefinition">
	/// Linphone.Core.PreferredVideoDefinition</see> method. 
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class VideoDefinition : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_video_definition_get_height(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_definition_set_height(IntPtr thiz, uint height);

		/// <summary>
		/// Get the height of the video definition. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The height of the video definition </returns>
		public uint Height
		{
			get
			{
				return linphone_video_definition_get_height(nativePtr);
			}
			set
			{
				linphone_video_definition_set_height(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_video_definition_is_undefined(IntPtr thiz);

		/// <summary>
		/// Tells whether a <see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see> is undefined. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A boolean value telling whether the <see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see> is undefined. </returns>
		public bool IsUndefined
		{
			get
			{
				return linphone_video_definition_is_undefined(nativePtr) != 0;
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_video_definition_get_name(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_definition_set_name(IntPtr thiz, string name);

		/// <summary>
		/// Get the name of the video definition. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The name of the video definition    </returns>
		public string Name
		{
			get
			{
				IntPtr stringPtr = linphone_video_definition_get_name(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_video_definition_set_name(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern uint linphone_video_definition_get_width(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_definition_set_width(IntPtr thiz, uint width);

		/// <summary>
		/// Get the width of the video definition. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The width of the video definition </returns>
		public uint Width
		{
			get
			{
				return linphone_video_definition_get_width(nativePtr);
			}
			set
			{
				linphone_video_definition_set_width(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_video_definition_clone(IntPtr thiz);

		/// <summary>
		/// Clone a video definition. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The new clone of the video definition    </returns>
		public Linphone.VideoDefinition Clone()
		{
			IntPtr ptr = linphone_video_definition_clone(nativePtr);
			Linphone.VideoDefinition returnVal = fromNativePtr<Linphone.VideoDefinition>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_video_definition_equals(IntPtr thiz, IntPtr videoDefinition2);

		/// <summary>
		/// Tells whether two <see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see> objects are equal (the widths and the heights
		/// are the same but can be switched). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="videoDefinition2"><see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see> object    </param>
		/// <returns>A boolean value telling whether the two <see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see> objects are equal. </returns>
		public bool Equals(Linphone.VideoDefinition videoDefinition2)
		{
			bool returnVal = linphone_video_definition_equals(nativePtr, videoDefinition2 != null ? videoDefinition2.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			GC.KeepAlive(videoDefinition2);
			return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_definition_set_definition(IntPtr thiz, uint width, uint height);

		/// <summary>
		/// Set the width and the height of the video definition. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="width">The width of the video definition </param>
		/// <param name="height">The height of the video definition </param>
		public void SetDefinition(uint width, uint height)
		{
			linphone_video_definition_set_definition(nativePtr, width, height);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern char linphone_video_definition_strict_equals(IntPtr thiz, IntPtr videoDefinition2);

		/// <summary>
		/// Tells whether two <see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see> objects are strictly equal (the widths are the
		/// same and the heights are the same). 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="videoDefinition2"><see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see> object    </param>
		/// <returns>A boolean value telling whether the two <see cref="Linphone.VideoDefinition">
		/// Linphone.VideoDefinition</see> objects are strictly equal. </returns>
		public bool StrictEquals(Linphone.VideoDefinition videoDefinition2)
		{
			bool returnVal = linphone_video_definition_strict_equals(nativePtr, videoDefinition2 != null ? videoDefinition2.nativePtr : IntPtr.Zero) == (char)0 ? false : true;
			
			GC.KeepAlive(videoDefinition2);
			return returnVal;
		}
	}
	/// <summary>
	/// Object that is used to describe a video source. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class VideoSourceDescriptor : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_video_source_descriptor_get_call(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_source_descriptor_set_call(IntPtr thiz, IntPtr call);

		/// <summary>
		/// Gets the call of a <see cref="Linphone.VideoSourceDescriptor">
		/// Linphone.VideoSourceDescriptor</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.Call">Linphone.Call</see> of the video source
		/// descriptor if it&apos;s type is LinphoneVideoSourceCall, null otherwise.   
		/// </returns>
		public Linphone.Call Call
		{
			get
			{
				IntPtr ptr = linphone_video_source_descriptor_get_call(nativePtr);
				Linphone.Call obj = fromNativePtr<Linphone.Call>(ptr, true);
				return obj;
			}
			set
			{
				linphone_video_source_descriptor_set_call(nativePtr, value.nativePtr);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_video_source_descriptor_get_camera_id(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_source_descriptor_set_camera_id(IntPtr thiz, string cameraId);

		/// <summary>
		/// Gets the camera id of a <see cref="Linphone.VideoSourceDescriptor">
		/// Linphone.VideoSourceDescriptor</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The camera id of the video source descriptor if it&apos;s type is
		/// LinphoneVideoSourceCamera, null otherwise.    </returns>
		public string CameraId
		{
			get
			{
				IntPtr stringPtr = linphone_video_source_descriptor_get_camera_id(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_video_source_descriptor_set_camera_id(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_video_source_descriptor_get_image(IntPtr thiz);
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_video_source_descriptor_set_image(IntPtr thiz, string imagePath);

		/// <summary>
		/// Gets the image path of a <see cref="Linphone.VideoSourceDescriptor">
		/// Linphone.VideoSourceDescriptor</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The image path of the video source descriptor if it&apos;s type is
		/// LinphoneVideoSourceImage, null otherwise.    </returns>
		public string Image
		{
			get
			{
				IntPtr stringPtr = linphone_video_source_descriptor_get_image(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
			set
			{
				linphone_video_source_descriptor_set_image(nativePtr, value);
				
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.VideoSourceType linphone_video_source_descriptor_get_type(IntPtr thiz);

		/// <summary>
		/// Gets the type of a <see cref="Linphone.VideoSourceDescriptor">
		/// Linphone.VideoSourceDescriptor</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.VideoSourceType">
		/// Linphone.VideoSourceType</see> corresponding to this video source descriptor.
		/// </returns>
		public Linphone.VideoSourceType Type
		{
			get
			{
				return linphone_video_source_descriptor_get_type(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_video_source_descriptor_clone(IntPtr thiz);

		/// <summary>
		/// Instantiate a new video source descriptor with values from source. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The newly created <see cref="Linphone.VideoSourceDescriptor">
		/// Linphone.VideoSourceDescriptor</see> object.    </returns>
		public Linphone.VideoSourceDescriptor Clone()
		{
			IntPtr ptr = linphone_video_source_descriptor_clone(nativePtr);
			Linphone.VideoSourceDescriptor returnVal = fromNativePtr<Linphone.VideoSourceDescriptor>(ptr, false);
			
						return returnVal;
		}
	}
	/// <summary>
	/// The <see cref="Linphone.XmlRpcRequest">Linphone.XmlRpcRequest</see> object
	/// representing a XML-RPC request to be sent. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class XmlRpcRequest : LinphoneObject
	{

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_get();

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_factory_create_xml_rpc_request_cbs(IntPtr factory);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_add_callbacks(IntPtr thiz, IntPtr cbs);

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_remove_callbacks(IntPtr thiz, IntPtr cbs);

		private XmlRpcRequestListener listener;

		public XmlRpcRequestListener Listener
		{
			get {
				if (listener == null)
				{
					IntPtr nativeListener = linphone_factory_create_xml_rpc_request_cbs(linphone_factory_get());
					listener = fromNativePtr<XmlRpcRequestListener>(nativeListener, false, true);
					linphone_xml_rpc_request_add_callbacks(nativePtr, nativeListener);
					belle_sip_object_unref(nativeListener);
				}
				return listener;
			}
			set {
				if (listener != null && value == null) {
					linphone_xml_rpc_request_remove_callbacks(nativePtr, listener.nativePtr);
				}
				listener = value;
			}
		}

		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_get_content(IntPtr thiz);

		/// <summary>
		/// Get the content of the XML-RPC request. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The string representation of the content of the XML-RPC request.   
		/// </returns>
		public string Content
		{
			get
			{
				IntPtr stringPtr = linphone_xml_rpc_request_get_content(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern int linphone_xml_rpc_request_get_int_response(IntPtr thiz);

		/// <summary>
		/// Get the response to an XML-RPC request sent with <see cref="Linphone.XmlRpcSession.SendRequest()">
		/// Linphone.XmlRpcSession.SendRequest()</see> and returning an integer response. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The integer response to the XML-RPC request. </returns>
		public int IntResponse
		{
			get
			{
				return linphone_xml_rpc_request_get_int_response(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_get_list_response(IntPtr thiz);

		/// <summary>
		/// Get the response to an XML-RPC request sent with <see cref="Linphone.XmlRpcSession.SendRequest()">
		/// Linphone.XmlRpcSession.SendRequest()</see> and returning a string response. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>A list of all string responses in the XML-RPC request.      </returns>
		public IEnumerable<string> ListResponse
		{
			get
			{
				return MarshalStringArray(linphone_xml_rpc_request_get_list_response(nativePtr));
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_get_raw_response(IntPtr thiz);

		/// <summary>
		/// Get the raw response to an XML-RPC request sent with <see cref="Linphone.XmlRpcSession.SendRequest()">
		/// Linphone.XmlRpcSession.SendRequest()</see> and returning http body as string. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The string response to the XML-RPC request.    </returns>
		public string RawResponse
		{
			get
			{
				IntPtr stringPtr = linphone_xml_rpc_request_get_raw_response(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern Linphone.XmlRpcStatus linphone_xml_rpc_request_get_status(IntPtr thiz);

		/// <summary>
		/// Get the status of the XML-RPC request. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The <see cref="Linphone.XmlRpcStatus">Linphone.XmlRpcStatus</see> of
		/// the XML-RPC request. </returns>
		public Linphone.XmlRpcStatus Status
		{
			get
			{
				return linphone_xml_rpc_request_get_status(nativePtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_request_get_string_response(IntPtr thiz);

		/// <summary>
		/// Get the response to an XML-RPC request sent with <see cref="Linphone.XmlRpcSession.SendRequest()">
		/// Linphone.XmlRpcSession.SendRequest()</see> and returning a string response. 
		/// <para>
		/// </para>
		/// </summary>
		/// <returns>The string response to the XML-RPC request.    </returns>
		public string StringResponse
		{
			get
			{
				IntPtr stringPtr = linphone_xml_rpc_request_get_string_response(nativePtr);
				return Marshal.PtrToStringAnsi(stringPtr);
			}
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_xml_rpc_request_add_int_arg(IntPtr thiz, int val);

		/// <summary>
		/// Add an integer argument to an XML-RPC request. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="val">The integer value of the added argument. </param>
		public void AddIntArg(int val)
		{
			linphone_xml_rpc_request_add_int_arg(nativePtr, val);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_xml_rpc_request_add_string_arg(IntPtr thiz, string val);

		/// <summary>
		/// Add a string argument to an XML-RPC request. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="val">The string value of the added argument.    </param>
		public void AddStringArg(string val)
		{
			linphone_xml_rpc_request_add_string_arg(nativePtr, val);
			
			
						
		}
	}
	/// <summary>
	/// The <see cref="Linphone.XmlRpcSession">Linphone.XmlRpcSession</see> object used
	/// to send XML-RPC requests and handle their responses. 
	/// <para>
	/// </para>
	/// </summary>
	[StructLayout(LayoutKind.Sequential)]
	public class XmlRpcSession : LinphoneObject
	{


		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr linphone_xml_rpc_session_create_request(IntPtr thiz, int returnType, string method);

		/// <summary>
		/// Creates a <see cref="Linphone.XmlRpcRequest">Linphone.XmlRpcRequest</see> from
		/// a <see cref="Linphone.XmlRpcSession">Linphone.XmlRpcSession</see>. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="returnType">the return type of the request as a <see cref="Linphone.XmlRpcArgType">
		/// Linphone.XmlRpcArgType</see> </param>
		/// <param name="method">the function name to call    </param>
		/// <returns>a <see cref="Linphone.XmlRpcRequest">Linphone.XmlRpcRequest</see>
		/// object    </returns>
		public Linphone.XmlRpcRequest CreateRequest(Linphone.XmlRpcArgType returnType, string method)
		{
			IntPtr ptr = linphone_xml_rpc_session_create_request(nativePtr, (int)returnType, method);
			Linphone.XmlRpcRequest returnVal = fromNativePtr<Linphone.XmlRpcRequest>(ptr, false);
			
						return returnVal;
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_xml_rpc_session_release(IntPtr thiz);

		/// <summary>
		/// Stop and unref an XML rpc session. 
		/// <para>
		/// Pending requests will be aborted. 
		/// </para>
		/// </summary>
		public void Release()
		{
			linphone_xml_rpc_session_release(nativePtr);
			
			
						
		}
		[DllImport(LinphoneWrapper.LIB_NAME, CallingConvention = CallingConvention.Cdecl)]
		static extern void linphone_xml_rpc_session_send_request(IntPtr thiz, IntPtr request);

		/// <summary>
		/// Send an XML-RPC request. 
		/// <para>
		/// </para>
		/// </summary>
		/// <param name="request">The <see cref="Linphone.XmlRpcRequest">
		/// Linphone.XmlRpcRequest</see> to be sent.    </param>
		public void SendRequest(Linphone.XmlRpcRequest request)
		{
			linphone_xml_rpc_session_send_request(nativePtr, request != null ? request.nativePtr : IntPtr.Zero);
			
			
			GC.KeepAlive(request);
			
		}
	}
#endregion
}
